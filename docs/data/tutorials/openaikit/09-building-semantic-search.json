{"metadata":{"categoryPathComponent":"OpenAIKit-Tutorials","role":"project","title":"Building Semantic Search","category":"OpenAIKit"},"variants":[{"paths":["\/tutorials\/openaikit\/09-building-semantic-search"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"project","identifier":{"interfaceLanguage":"swift","url":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search"},"schemaVersion":{"major":0,"patch":0,"minor":3},"hierarchy":{"modules":[{"projects":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit","sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Install-OpenAIKit","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Obtain-an-API-Key","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Configure-OpenAIKit","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Set-Environment-Variables","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Check-Your-Understanding","kind":"assessment"}]},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion","sections":[{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Create-a-Simple-Chat-Request"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Understanding-Chat-Messages"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Customizing-Model-Parameters"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Building-a-Chat-Interface"},{"kind":"assessment","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Check-Your-Understanding"}]},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors","sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Understanding-OpenAIKit-Errors","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Implementing-Retry-Logic","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#User-Friendly-Error-Messages","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Building-a-Robust-Error-Handler","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Check-Your-Understanding","kind":"assessment"}]}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Getting-Started"},{"projects":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations","sections":[{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Managing-Conversation-Context"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Implementing-Conversation-Memory"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Creating-Dynamic-Personas"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Advanced-Conversation-Patterns"},{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Building-a-Complete-Chatbot"},{"kind":"assessment","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Check-Your-Understanding"}]},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses","sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Understanding-Streaming","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Building-a-Streaming-UI","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Handling-Stream-Interruptions","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Advanced-Streaming-Features","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Cross-Platform-Streaming","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Check-Your-Understanding","kind":"assessment"}]},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions","sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Understanding-Function-Calling","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Implementing-the-Weather-Function","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Handling-Function-Calls","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Building-the-Complete-Assistant","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Advanced-Function-Patterns","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Check-Your-Understanding","kind":"assessment"}]}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Chat-Completions"},{"projects":[{"sections":[{"kind":"task","reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/07-Generating-Images#Understanding-Image-Models"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/07-Generating-Images"},{"sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Basic-Audio-Transcription","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Advanced-Transcription-Options","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Audio-Translation","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Building-a-Voice-Notes-App","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Handling-Large-Audio-Files","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Check-Your-Understanding","kind":"assessment"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio"},{"sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Understanding-Embeddings","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Vector-Similarity-Search","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Building-a-Vector-Database","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Semantic-Search-Engine","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Building-a-Knowledge-Base-App","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Advanced-Techniques","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Check-Your-Understanding","kind":"assessment"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Multimodal-AI"},{"projects":[{"sections":[{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Introduction-to-DeepResearch","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Web-Search-Research","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Code-Interpreter-for-Data-Analysis","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Working-with-MCP-Servers","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Streaming-Research-Responses","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Best-Practices-for-Research-Prompting","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Security-and-Privacy-Considerations","kind":"task"},{"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Check-Your-Understanding","kind":"assessment"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis"}],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Advanced-Research"}],"paths":[["doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials","doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/$volume","doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Multimodal-AI"]],"reference":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials"},"sections":[{"kind":"hero","content":[{"inlineContent":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Build a knowledge base app that understands meaning, not just keywords."}],"type":"paragraph"}],"estimatedTimeInMinutes":20,"chapter":"Multimodal AI","title":"Building Semantic Search"},{"kind":"tasks","tasks":[{"contentSection":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Learn how embeddings convert text into numerical vectors that capture semantic meaning.","type":"text"}]}],"kind":"contentAndMedia","mediaPosition":"trailing"}],"title":"Understanding Embeddings","stepsSection":[{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Create a new file for embedding generation.","type":"text"}]}],"caption":[],"media":null,"runtimePreview":null,"code":"embeddings-01-empty.swift"},{"type":"step","content":[{"inlineContent":[{"type":"text","text":"Import OpenAIKit and create an embedding function."}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null,"code":"embeddings-02-function.swift"},{"type":"step","content":[{"inlineContent":[{"text":"Create an embedding request for a text string.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null,"runtimePreview":null,"code":"embeddings-03-request.swift"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Extract the embedding vector from the response.","type":"text"}]}],"caption":[],"media":null,"runtimePreview":null,"code":"embeddings-04-response.swift"},{"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Process multiple texts in a batch for efficiency."}]}],"caption":[],"media":null,"runtimePreview":null,"code":"embeddings-05-batch.swift"}],"anchor":"Understanding-Embeddings"},{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement vector similarity calculations to find related content."}]}],"mediaPosition":"trailing"}],"title":"Vector Similarity Search","stepsSection":[{"code":"similarity-01-calculator.swift","type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a vector similarity calculator."}]}],"media":null,"caption":[]},{"code":null,"type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement cosine similarity calculation."}]}],"media":null,"caption":[]},{"code":null,"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Add dot product similarity option."}],"type":"paragraph"}],"media":null,"caption":[]},{"code":null,"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Create a similarity ranking system."}],"type":"paragraph"}],"media":null,"caption":[]},{"code":"similarity-05-threshold.swift","type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement similarity thresholds and filtering."}]}],"media":null,"caption":[]}],"anchor":"Vector-Similarity-Search"},{"contentSection":[{"mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create an efficient vector storage system for semantic search at scale."}]}],"kind":"contentAndMedia"}],"title":"Building a Vector Database","stepsSection":[{"type":"step","code":"database-01-model.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Design a document model with embeddings.","type":"text"}]}],"caption":[],"media":null},{"type":"step","code":"database-02-index.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Create a vector index for fast searching.","type":"text"}],"type":"paragraph"}],"caption":[],"media":null},{"type":"step","code":"database-03-storage.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Implement document storage with Core Data.","type":"text"}]}],"caption":[],"media":null},{"type":"step","code":"database-04-knn.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"text":"Add efficient k-nearest neighbor search.","type":"text"}]}],"caption":[],"media":null},{"type":"step","code":"database-05-hybrid.swift","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Create metadata filtering for hybrid search."}],"type":"paragraph"}],"caption":[],"media":null}],"anchor":"Building-a-Vector-Database"},{"contentSection":[{"kind":"contentAndMedia","mediaPosition":"trailing","content":[{"type":"paragraph","inlineContent":[{"text":"Combine embeddings and vector search to build a complete semantic search system.","type":"text"}]}]}],"title":"Semantic Search Engine","stepsSection":[{"code":"engine-01-class.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create the main search engine class."}]}],"media":null},{"code":"engine-02-index.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"text":"Implement document indexing with embeddings.","type":"text"}],"type":"paragraph"}],"media":null},{"code":"engine-03-query.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add query processing and embedding."}]}],"media":null},{"code":"engine-04-ranking.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"inlineContent":[{"type":"text","text":"Create result ranking and relevance scoring."}],"type":"paragraph"}],"media":null},{"code":"engine-05-cache.swift","caption":[],"type":"step","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement search result caching."}]}],"media":null}],"anchor":"Semantic-Search-Engine"},{"contentSection":[{"kind":"contentAndMedia","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create a complete knowledge base application with semantic search capabilities."}]}],"mediaPosition":"trailing"}],"title":"Building a Knowledge Base App","stepsSection":[{"media":null,"code":"app-01-ingest.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Create a document ingestion system."}],"type":"paragraph"}],"caption":[]},{"media":null,"code":"app-02-interface.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Build a search interface with SwiftUI."}],"type":"paragraph"}],"caption":[]},{"media":null,"code":"app-03-preview.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Add document preview and highlighting."}],"type":"paragraph"}],"caption":[]},{"media":null,"code":"app-04-related.swift","runtimePreview":null,"type":"step","content":[{"inlineContent":[{"type":"text","text":"Implement related document suggestions."}],"type":"paragraph"}],"caption":[]},{"media":null,"code":"app-05-analytics.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create search analytics and insights."}]}],"caption":[]},{"media":null,"code":"app-06-categorize.swift","runtimePreview":null,"type":"step","content":[{"type":"paragraph","inlineContent":[{"text":"Add document categorization using embeddings.","type":"text"}]}],"caption":[]}],"anchor":"Building-a-Knowledge-Base-App"},{"contentSection":[{"mediaPosition":"trailing","content":[{"inlineContent":[{"type":"text","text":"Explore advanced embedding techniques for improved search quality."}],"type":"paragraph"}],"kind":"contentAndMedia"}],"title":"Advanced Techniques","stepsSection":[{"media":null,"code":"advanced-01-chunking.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Implement text chunking strategies."}]}],"caption":[],"type":"step"},{"media":null,"code":"advanced-02-expansion.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Add query expansion for better recall."}]}],"caption":[],"type":"step"},{"media":null,"code":"advanced-03-finetune.swift","runtimePreview":null,"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Create embedding fine-tuning for domains."}]}],"caption":[],"type":"step"},{"media":null,"code":"advanced-04-multilang.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Implement multi-language search support.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step"},{"media":null,"code":"advanced-05-realtime.swift","runtimePreview":null,"content":[{"inlineContent":[{"text":"Add real-time index updates.","type":"text"}],"type":"paragraph"}],"caption":[],"type":"step"}],"anchor":"Advanced-Techniques"}]},{"kind":"assessments","assessments":[{"content":[],"choices":[{"content":[{"type":"paragraph","inlineContent":[{"text":"1536","type":"text"}]}],"isCorrect":true,"justification":[{"type":"paragraph","inlineContent":[{"text":"The text-embedding-3-small model produces 1536-dimensional vectors.","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"768"}],"type":"paragraph"}],"isCorrect":false,"justification":[{"inlineContent":[{"text":"This is a common dimension for other models, but not OpenAI’s current embeddings.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"3072"}]}],"isCorrect":false,"justification":[{"type":"paragraph","inlineContent":[{"type":"text","text":"This is the dimension for text-embedding-3-large, not small."}]}]}],"type":"multiple-choice","title":[{"inlineContent":[{"text":"What dimension are OpenAI’s text-embedding-3-small vectors?","type":"text"}],"type":"paragraph"}]},{"content":[],"choices":[{"content":[{"type":"paragraph","inlineContent":[{"text":"Cosine similarity","type":"text"}]}],"isCorrect":true,"justification":[{"type":"paragraph","inlineContent":[{"text":"Cosine similarity is standard for normalized embedding vectors.","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Euclidean distance","type":"text"}],"type":"paragraph"}],"isCorrect":false,"justification":[{"inlineContent":[{"text":"While usable, cosine similarity is more common for embeddings.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Manhattan distance"}]}],"isCorrect":false,"justification":[{"type":"paragraph","inlineContent":[{"text":"This metric is rarely used for embedding similarity.","type":"text"}]}]}],"title":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Which similarity metric is most commonly used for embeddings?"}]}],"type":"multiple-choice"}],"anchor":"Check-Your-Understanding"},{"kind":"callToAction","action":{"overridingTitle":"Get started","isActive":true,"type":"reference","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis","overridingTitleInlineContent":[{"type":"text","text":"Get started"}]},"featuredEyebrow":"Tutorial","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"title":"Deep Research and Analysis"}],"references":{"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Advanced-Streaming-Features":{"title":"Advanced Streaming Features","abstract":[{"type":"text","text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Advanced-Streaming-Features","url":"\/tutorials\/openaikit\/06-streaming-responses#Advanced-Streaming-Features"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Check-Your-Understanding":{"url":"\/tutorials\/openaikit\/09-deep-research-analysis#Check-Your-Understanding","title":"Check Your Understanding","titleInlineContent":[{"type":"text","text":"Check Your Understanding"}],"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Check-Your-Understanding","type":"link"},"doc://OpenAIKit/tutorials/OpenAIKit-Tutorials/Multimodal-AI":{"title":"Multimodal AI","abstract":[],"role":"article","kind":"article","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Multimodal-AI","url":"\/tutorials\/openaikit-tutorials\/multimodal-ai"},"app-04-related.swift":{"fileName":"KnowledgeBaseApp.swift","fileType":"swift","identifier":"app-04-related.swift","highlights":[{"line":4},{"line":5},{"line":7},{"line":8},{"line":12},{"line":13},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":34},{"line":35},{"line":36},{"line":37},{"line":40},{"line":41},{"line":42},{"line":43},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":81},{"line":82},{"line":83},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":122},{"line":123},{"line":125},{"line":126},{"line":130},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":158},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":242},{"line":243},{"line":244},{"line":245},{"line":249},{"line":251},{"line":253},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":263},{"line":264},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":284},{"line":285},{"line":286},{"line":288},{"line":290},{"line":291},{"line":292},{"line":294},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":308},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":332},{"line":335},{"line":336},{"line":337},{"line":338},{"line":341},{"line":342},{"line":343},{"line":344},{"line":345},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":355},{"line":356},{"line":357},{"line":358},{"line":361},{"line":362},{"line":365},{"line":366},{"line":367},{"line":368},{"line":369},{"line":374},{"line":375},{"line":377},{"line":378},{"line":379},{"line":380},{"line":381},{"line":384},{"line":385},{"line":386},{"line":387},{"line":388},{"line":389},{"line":390},{"line":391},{"line":392},{"line":393},{"line":394},{"line":395},{"line":396},{"line":397},{"line":400},{"line":401},{"line":402},{"line":403}],"content":["import OpenAIKit","import Foundation","","\/\/ Finding related documents","class RelatedDocumentsFinder {","    let openAI: OpenAI","    let vectorStore: VectorStore","    let similarityAnalyzer: SimilarityAnalyzer","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.vectorStore = VectorStore()","        self.similarityAnalyzer = SimilarityAnalyzer(openAI: openAI)","    }","    ","    \/\/ Find related documents for a given document","    func findRelated(","        to documentId: String,","        limit: Int = 5,","        strategy: RelatedSearchStrategy = .hybrid","    ) async throws -> [RelatedDocument] {","        \/\/ Get the original document","        guard let originalDoc = try await vectorStore.getDocument(id: documentId) else {","            throw RelatedDocumentError.documentNotFound","        }","        ","        \/\/ Find related documents based on strategy","        let relatedDocs = try await findRelatedByStrategy(","            document: originalDoc,","            strategy: strategy,","            limit: limit * 2 \/\/ Get more candidates for filtering","        )","        ","        \/\/ Analyze relationships","        let analyzedDocs = try await analyzeRelationships(","            original: originalDoc,","            candidates: relatedDocs","        )","        ","        \/\/ Filter and rank","        let rankedDocs = rankRelatedDocuments(analyzedDocs)","            .prefix(limit)","            .map { $0 }","        ","        return rankedDocs","    }","    ","    \/\/ Find related documents by strategy","    private func findRelatedByStrategy(","        document: ChunkDocument,","        strategy: RelatedSearchStrategy,","        limit: Int","    ) async throws -> [SearchResult] {","        switch strategy {","        case .embedding:","            return try await findByEmbedding(document: document, limit: limit)","            ","        case .content:","            return try await findByContent(document: document, limit: limit)","            ","        case .metadata:","            return try await findByMetadata(document: document, limit: limit)","            ","        case .hybrid:","            \/\/ Combine multiple strategies","            let embeddingResults = try await findByEmbedding(document: document, limit: limit \/ 2)","            let contentResults = try await findByContent(document: document, limit: limit \/ 2)","            let metadataResults = try await findByMetadata(document: document, limit: limit \/ 2)","            ","            \/\/ Merge and deduplicate","            return mergeResults([embeddingResults, contentResults, metadataResults])","        }","    }","    ","    \/\/ Find by embedding similarity","    private func findByEmbedding(document: ChunkDocument, limit: Int) async throws -> [SearchResult] {","        let results = try await vectorStore.search(","            embedding: document.embedding,","            limit: limit + 1 \/\/ +1 to exclude self","        )","        ","        \/\/ Filter out the original document","        return results.filter { $0.document.id != document.id }","    }","    ","    \/\/ Find by content analysis","    private func findByContent(document: ChunkDocument, limit: Int) async throws -> [SearchResult] {","        \/\/ Extract key concepts from document","        let concepts = try await extractKeyConcepts(from: document.content)","        ","        \/\/ Generate embedding for concepts","        let conceptsText = concepts.joined(separator: \" \")","        let embedding = try await generateEmbedding(for: conceptsText)","        ","        \/\/ Search using concepts embedding","        return try await vectorStore.search(","            embedding: embedding,","            limit: limit","        ).filter { $0.document.id != document.id }","    }","    ","    \/\/ Find by metadata similarity","    private func findByMetadata(document: ChunkDocument, limit: Int) async throws -> [SearchResult] {","        \/\/ Create metadata-based query","        let metadataQuery = \"\"\"","        \\(document.metadata.category) \\(document.metadata.tags.joined(separator: \" \"))","        \"\"\"","        ","        let embedding = try await generateEmbedding(for: metadataQuery)","        ","        return try await vectorStore.search(","            embedding: embedding,","            limit: limit","        ).filter { $0.document.id != document.id }","    }","    ","    \/\/ Extract key concepts using LLM","    private func extractKeyConcepts(from content: String) async throws -> [String] {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Extract 5-10 key concepts or topics from the text.\"),","                .user(\"Text: \\(content)\\n\\nKey concepts:\")","            ],","            temperature: 0.3,","            maxTokens: 100","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let conceptsText = response.choices.first?.message.content ?? \"\"","        ","        return conceptsText","            .components(separatedBy: .newlines)","            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }","            .filter { !$0.isEmpty }","    }","    ","    \/\/ Analyze relationships between documents","    private func analyzeRelationships(","        original: ChunkDocument,","        candidates: [SearchResult]","    ) async throws -> [RelatedDocument] {","        var relatedDocs: [RelatedDocument] = []","        ","        for candidate in candidates {","            let relationship = try await similarityAnalyzer.analyze(","                document1: original,","                document2: candidate.document","            )","            ","            relatedDocs.append(RelatedDocument(","                document: candidate.document,","                relationship: relationship,","                similarityScore: candidate.score","            ))","        }","        ","        return relatedDocs","    }","    ","    \/\/ Rank related documents","    private func rankRelatedDocuments(_ documents: [RelatedDocument]) -> [RelatedDocument] {","        return documents.sorted { doc1, doc2 in","            \/\/ Combined score from similarity and relationship strength","            let score1 = doc1.similarityScore * 0.6 + doc1.relationship.strength * 0.4","            let score2 = doc2.similarityScore * 0.6 + doc2.relationship.strength * 0.4","            return score1 > score2","        }","    }","    ","    \/\/ Generate embedding","    private func generateEmbedding(for text: String) async throws -> [Double] {","        let request = CreateEmbeddingRequest(","            model: .textEmbeddingAda002,","            input: .text(text)","        )","        ","        let response = try await openAI.embeddings.create(request)","        return response.data.first?.embedding ?? []","    }","    ","    \/\/ Merge and deduplicate results","    private func mergeResults(_ resultSets: [[SearchResult]]) -> [SearchResult] {","        var merged: [String: SearchResult] = [:]","        ","        for results in resultSets {","            for result in results {","                let id = result.document.id","                if let existing = merged[id] {","                    \/\/ Keep the one with higher score","                    if result.score > existing.score {","                        merged[id] = result","                    }","                } else {","                    merged[id] = result","                }","            }","        }","        ","        return Array(merged.values).sorted { $0.score > $1.score }","    }","}","","\/\/ Similarity analyzer","class SimilarityAnalyzer {","    let openAI: OpenAI","    ","    init(openAI: OpenAI) {","        self.openAI = openAI","    }","    ","    func analyze(","        document1: ChunkDocument,","        document2: ChunkDocument","    ) async throws -> DocumentRelationship {","        \/\/ Analyze semantic relationship","        let semanticRelation = try await analyzeSemanticRelation(","            content1: document1.content,","            content2: document2.content","        )","        ","        \/\/ Calculate metadata similarity","        let metadataSimilarity = calculateMetadataSimilarity(","            metadata1: document1.metadata,","            metadata2: document2.metadata","        )","        ","        \/\/ Determine relationship type","        let relationType = determineRelationType(","            semantic: semanticRelation,","            metadataSimilarity: metadataSimilarity","        )","        ","        return DocumentRelationship(","            type: relationType,","            strength: semanticRelation.similarity,","            commonTopics: semanticRelation.commonTopics,","            explanation: semanticRelation.explanation","        )","    }","    ","    private func analyzeSemanticRelation(","        content1: String,","        content2: String","    ) async throws -> SemanticRelation {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Analyze the semantic relationship between two documents.\"),","                .user(\"\"\"","                Document 1: \\(content1.prefix(500))...","                ","                Document 2: \\(content2.prefix(500))...","                ","                Provide:","                1. Similarity score (0-1)","                2. Common topics","                3. Relationship explanation","                ","                Format as JSON.","                \"\"\")","            ],","            temperature: 0.2,","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse response (simplified for example)","        return SemanticRelation(","            similarity: 0.75,","            commonTopics: [\"machine learning\", \"algorithms\"],","            explanation: \"Both documents discuss machine learning concepts\"","        )","    }","    ","    private func calculateMetadataSimilarity(","        metadata1: ChunkMetadata,","        metadata2: ChunkMetadata","    ) -> Double {","        var similarity = 0.0","        var factors = 0.0","        ","        \/\/ Category similarity","        if metadata1.category == metadata2.category {","            similarity += 0.3","        }","        factors += 0.3","        ","        \/\/ Author similarity","        if metadata1.author == metadata2.author {","            similarity += 0.2","        }","        factors += 0.2","        ","        \/\/ Tags similarity","        let tags1 = Set(metadata1.tags)","        let tags2 = Set(metadata2.tags)","        let commonTags = tags1.intersection(tags2)","        let allTags = tags1.union(tags2)","        ","        if !allTags.isEmpty {","            let tagSimilarity = Double(commonTags.count) \/ Double(allTags.count)","            similarity += tagSimilarity * 0.5","        }","        factors += 0.5","        ","        return factors > 0 ? similarity \/ factors : 0","    }","    ","    private func determineRelationType(","        semantic: SemanticRelation,","        metadataSimilarity: Double","    ) -> RelationType {","        if semantic.similarity > 0.8 && metadataSimilarity > 0.7 {","            return .stronglyRelated","        } else if semantic.similarity > 0.6 {","            return .related","        } else if metadataSimilarity > 0.5 {","            return .weaklyRelated","        } else {","            return .tangential","        }","    }","}","","\/\/ Models","enum RelatedSearchStrategy {","    case embedding","    case content","    case metadata","    case hybrid","}","","struct RelatedDocument {","    let document: ChunkDocument","    let relationship: DocumentRelationship","    let similarityScore: Double","}","","struct DocumentRelationship {","    let type: RelationType","    let strength: Double","    let commonTopics: [String]","    let explanation: String","}","","enum RelationType {","    case stronglyRelated","    case related","    case weaklyRelated","    case tangential","}","","struct SemanticRelation {","    let similarity: Double","    let commonTopics: [String]","    let explanation: String","}","","enum RelatedDocumentError: Error {","    case documentNotFound","}","","\/\/ Extension for VectorStore","extension VectorStore {","    func getDocument(id: String) async throws -> ChunkDocument? {","        \/\/ In a real implementation, this would fetch from storage","        return nil","    }","}","","\/\/ Usage example","func demonstrateRelatedDocuments() async throws {","    let finder = RelatedDocumentsFinder(apiKey: \"your-api-key\")","    ","    \/\/ Find related documents using hybrid strategy","    let relatedDocs = try await finder.findRelated(","        to: \"doc001_0\",","        limit: 5,","        strategy: .hybrid","    )","    ","    print(\"Related Documents:\")","    for (index, related) in relatedDocs.enumerated() {","        print(\"\\n\\(index + 1). \\(related.document.metadata.title)\")","        print(\"   Relationship: \\(related.relationship.type)\")","        print(\"   Strength: \\(String(format: \"%.2f\", related.relationship.strength))\")","        print(\"   Common Topics: \\(related.relationship.commonTopics.joined(separator: \", \"))\")","        print(\"   \\(related.relationship.explanation)\")","    }","    ","    \/\/ Find related by specific strategy","    let contentRelated = try await finder.findRelated(","        to: \"doc001_0\",","        limit: 3,","        strategy: .content","    )","    ","    print(\"\\n\\nContent-based Related Documents:\")","    for related in contentRelated {","        print(\"- \\(related.document.metadata.title)\")","    }","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Building-a-Knowledge-Base-App":{"title":"Building a Knowledge Base App","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Building-a-Knowledge-Base-App","url":"\/tutorials\/openaikit\/09-building-semantic-search#Building-a-Knowledge-Base-App"},"advanced-04-multilang.swift":{"syntax":"swift","highlights":[{"line":4},{"line":6},{"line":8},{"line":10},{"line":11},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":28},{"line":29},{"line":30},{"line":33},{"line":34},{"line":36},{"line":37},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":73},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":100},{"line":102},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":135},{"line":136},{"line":137},{"line":138},{"line":141},{"line":142},{"line":143},{"line":146},{"line":147},{"line":148},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":200},{"line":201},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":246},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":252},{"line":253},{"line":254},{"line":255},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":285},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":321},{"line":322},{"line":323},{"line":324},{"line":325},{"line":326},{"line":328},{"line":330},{"line":336},{"line":338},{"line":339},{"line":340},{"line":341},{"line":342},{"line":343},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":366},{"line":369},{"line":370},{"line":371},{"line":374},{"line":375},{"line":376},{"line":377},{"line":378},{"line":379},{"line":380},{"line":381},{"line":384},{"line":388},{"line":389},{"line":390},{"line":391},{"line":392},{"line":393},{"line":394},{"line":395},{"line":397},{"line":398},{"line":400},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":408},{"line":409},{"line":410},{"line":411},{"line":412},{"line":413},{"line":414},{"line":415},{"line":416},{"line":417},{"line":418},{"line":419},{"line":420},{"line":421},{"line":422},{"line":423},{"line":425},{"line":426},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":444},{"line":445},{"line":449},{"line":450},{"line":451},{"line":452},{"line":453},{"line":454},{"line":455},{"line":456},{"line":457},{"line":458},{"line":459},{"line":460},{"line":461},{"line":464},{"line":465},{"line":466},{"line":467},{"line":468},{"line":469},{"line":470},{"line":471},{"line":472},{"line":473},{"line":476},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":482},{"line":483},{"line":484},{"line":485},{"line":486},{"line":489},{"line":490},{"line":491},{"line":492},{"line":493},{"line":494},{"line":495},{"line":497},{"line":498},{"line":499},{"line":502},{"line":503},{"line":504},{"line":505},{"line":508},{"line":509},{"line":510},{"line":511},{"line":514},{"line":515},{"line":516},{"line":519},{"line":520},{"line":521},{"line":524},{"line":525},{"line":526},{"line":529},{"line":530},{"line":531},{"line":532},{"line":535},{"line":536},{"line":537},{"line":538},{"line":539},{"line":540},{"line":543},{"line":544},{"line":545},{"line":546},{"line":549},{"line":550},{"line":551},{"line":554},{"line":555},{"line":556},{"line":557},{"line":560},{"line":563},{"line":564},{"line":565},{"line":568},{"line":569},{"line":570},{"line":571},{"line":572},{"line":575},{"line":576},{"line":577},{"line":578},{"line":581},{"line":582},{"line":583},{"line":584},{"line":585},{"line":586},{"line":587},{"line":588},{"line":589},{"line":590},{"line":591},{"line":592},{"line":593},{"line":594},{"line":595},{"line":596},{"line":597},{"line":598},{"line":599},{"line":602},{"line":603},{"line":604},{"line":607},{"line":608},{"line":609},{"line":610},{"line":613},{"line":614},{"line":615},{"line":616},{"line":619},{"line":620},{"line":621},{"line":622},{"line":625},{"line":626},{"line":627},{"line":628},{"line":629},{"line":630},{"line":633},{"line":634},{"line":635},{"line":636},{"line":637},{"line":638},{"line":640},{"line":641},{"line":642},{"line":645},{"line":646},{"line":647},{"line":648},{"line":651},{"line":652},{"line":653},{"line":654},{"line":657},{"line":658},{"line":659},{"line":660},{"line":661},{"line":662},{"line":665},{"line":666},{"line":667},{"line":668},{"line":671},{"line":672},{"line":673},{"line":676},{"line":677},{"line":678},{"line":679},{"line":680},{"line":683},{"line":684},{"line":685},{"line":686},{"line":689},{"line":690},{"line":691},{"line":694},{"line":695},{"line":696},{"line":700},{"line":702},{"line":704},{"line":705},{"line":706},{"line":709},{"line":710},{"line":711},{"line":712},{"line":713},{"line":716},{"line":717},{"line":718},{"line":719},{"line":720},{"line":721},{"line":722},{"line":725},{"line":727},{"line":729},{"line":731},{"line":732},{"line":733},{"line":734},{"line":735},{"line":736},{"line":740},{"line":742},{"line":745}],"fileName":"AdvancedEmbeddings.swift","fileType":"swift","type":"file","identifier":"advanced-04-multilang.swift","content":["import OpenAIKit","import Foundation","","\/\/ Multi-language semantic search with cross-lingual capabilities","","struct MultilingualSemanticSearch {","    let openAI: OpenAI","    let supportedLanguages: Set<Language>","    ","    \/\/ Cross-lingual embedding generation","    func generateCrossLingualEmbedding(","        text: String,","        sourceLanguage: Language,","        alignmentStrategy: AlignmentStrategy = .multilingual","    ) async throws -> CrossLingualEmbedding {","        \/\/ Detect language if not specified","        let detectedLanguage = sourceLanguage == .auto ","            ? try await detectLanguage(text) ","            : sourceLanguage","        ","        \/\/ Preprocess text for language-specific features","        let preprocessed = preprocessForLanguage(","            text: text,","            language: detectedLanguage","        )","        ","        \/\/ Generate base embedding","        let baseEmbedding = try await generateBaseEmbedding(","            text: preprocessed,","            language: detectedLanguage","        )","        ","        \/\/ Apply cross-lingual alignment","        let alignedEmbedding = try await applyCrossLingualAlignment(","            embedding: baseEmbedding,","            sourceLanguage: detectedLanguage,","            strategy: alignmentStrategy","        )","        ","        return CrossLingualEmbedding(","            vector: alignedEmbedding,","            sourceLanguage: detectedLanguage,","            languageFeatures: extractLanguageFeatures(text, detectedLanguage),","            alignmentMetadata: AlignmentMetadata(","                strategy: alignmentStrategy,","                confidence: calculateAlignmentConfidence(alignedEmbedding)","            )","        )","    }","    ","    \/\/ Multi-language query processing","    func processMultilingualQuery(","        query: String,","        targetLanguages: Set<Language>? = nil,","        searchStrategy: MultilingualSearchStrategy = .unified","    ) async throws -> MultilingualQuery {","        \/\/ Detect query language","        let queryLanguage = try await detectLanguage(query)","        ","        \/\/ Determine target languages","        let searchLanguages = targetLanguages ?? supportedLanguages","        ","        \/\/ Translate query to target languages","        var translations: [Language: Translation] = [:]","        ","        for language in searchLanguages where language != queryLanguage {","            let translation = try await translateQuery(","                query: query,","                from: queryLanguage,","                to: language,","                preserveIntent: true","            )","            translations[language] = translation","        }","        ","        \/\/ Generate unified query representation","        let unifiedRepresentation = try await createUnifiedQueryRepresentation(","            originalQuery: query,","            originalLanguage: queryLanguage,","            translations: translations,","            strategy: searchStrategy","        )","        ","        return MultilingualQuery(","            original: query,","            originalLanguage: queryLanguage,","            translations: translations,","            unifiedRepresentation: unifiedRepresentation,","            searchStrategy: searchStrategy","        )","    }","    ","    \/\/ Cross-lingual similarity computation","    func crossLingualSimilarity(","        query: CrossLingualEmbedding,","        document: CrossLingualEmbedding,","        similarityMetric: CrossLingualMetric = .adaptive","    ) -> CrossLingualSimilarityScore {","        \/\/ Base cosine similarity","        let baseSimilarity = cosineSimilarity(query.vector, document.vector)","        ","        \/\/ Language-aware adjustments","        var adjustedScore = baseSimilarity","        ","        \/\/ Apply language distance penalty\/bonus","        let languageDistance = calculateLanguageDistance(","            query.sourceLanguage,","            document.sourceLanguage","        )","        ","        switch similarityMetric {","        case .strict:","            \/\/ Penalize cross-language matches more heavily","            if query.sourceLanguage != document.sourceLanguage {","                adjustedScore *= (1.0 - languageDistance * 0.3)","            }","            ","        case .lenient:","            \/\/ Minimal penalty for cross-language matches","            if query.sourceLanguage != document.sourceLanguage {","                adjustedScore *= (1.0 - languageDistance * 0.1)","            }","            ","        case .adaptive:","            \/\/ Adaptive based on language similarity","            let adaptiveFactor = calculateAdaptiveFactor(","                queryLang: query.sourceLanguage,","                docLang: document.sourceLanguage,","                queryFeatures: query.languageFeatures,","                docFeatures: document.languageFeatures","            )","            adjustedScore *= adaptiveFactor","        }","        ","        \/\/ Apply linguistic feature matching","        let featureBoost = calculateLinguisticFeatureBoost(","            queryFeatures: query.languageFeatures,","            docFeatures: document.languageFeatures","        )","        ","        adjustedScore += featureBoost","        ","        return CrossLingualSimilarityScore(","            baseScore: baseSimilarity,","            adjustedScore: min(adjustedScore, 1.0),","            languageDistance: languageDistance,","            featureMatchScore: featureBoost,","            confidence: calculateConfidence(query, document)","        )","    }","    ","    \/\/ Language-specific indexing strategies","    func createMultilingualIndex(","        documents: [MultilingualDocument],","        indexingStrategy: MultilingualIndexingStrategy = .unified","    ) async throws -> MultilingualSearchIndex {","        var index = MultilingualSearchIndex()","        ","        switch indexingStrategy {","        case .unified:","            \/\/ Create unified multilingual index","            for document in documents {","                let unifiedEmbedding = try await createUnifiedDocumentEmbedding(","                    document: document","                )","                index.addDocument(","                    id: document.id,","                    embedding: unifiedEmbedding,","                    languages: document.languages","                )","            }","            ","        case .perLanguage:","            \/\/ Create separate indices per language","            for language in supportedLanguages {","                let languageDocuments = documents.filter { ","                    $0.languages.contains(language) ","                }","                ","                for document in languageDocuments {","                    if let content = document.content[language] {","                        let embedding = try await generateCrossLingualEmbedding(","                            text: content,","                            sourceLanguage: language","                        )","                        index.addToLanguageIndex(","                            language: language,","                            documentId: document.id,","                            embedding: embedding","                        )","                    }","                }","            }","            ","        case .hybrid:","            \/\/ Combine unified and per-language approaches","            try await createHybridIndex(documents: documents, index: &index)","        }","        ","        \/\/ Build language-specific optimizations","        index.buildLanguageOptimizations()","        ","        return index","    }","    ","    \/\/ Multilingual result ranking and fusion","    func rankMultilingualResults(","        query: MultilingualQuery,","        candidates: [MultilingualSearchResult],","        rankingStrategy: MultilingualRankingStrategy = .weighted","    ) async throws -> [RankedMultilingualResult] {","        var rankedResults: [RankedMultilingualResult] = []","        ","        for candidate in candidates {","            var scores: [Language: Float] = [:]","            var explanations: [Language: String] = [:]","            ","            \/\/ Score against original query","            let originalScore = try await scoreCandidate(","                query: query.original,","                queryLanguage: query.originalLanguage,","                candidate: candidate","            )","            scores[query.originalLanguage] = originalScore.score","            explanations[query.originalLanguage] = originalScore.explanation","            ","            \/\/ Score against translations","            for (language, translation) in query.translations {","                let translationScore = try await scoreCandidate(","                    query: translation.text,","                    queryLanguage: language,","                    candidate: candidate","                )","                scores[language] = translationScore.score","                explanations[language] = translationScore.explanation","            }","            ","            \/\/ Combine scores based on ranking strategy","            let combinedScore = combineMultilingualScores(","                scores: scores,","                strategy: rankingStrategy,","                queryLanguage: query.originalLanguage,","                documentLanguages: candidate.languages","            )","            ","            rankedResults.append(RankedMultilingualResult(","                result: candidate,","                combinedScore: combinedScore,","                languageScores: scores,","                explanations: explanations,","                primaryLanguage: determinePrimaryLanguage(","                    candidate: candidate,","                    queryLanguage: query.originalLanguage","                )","            ))","        }","        ","        \/\/ Sort by combined score","        return rankedResults.sorted { $0.combinedScore > $1.combinedScore }","    }","    ","    \/\/ Language-aware snippet generation","    func generateMultilingualSnippet(","        document: MultilingualDocument,","        query: MultilingualQuery,","        snippetLanguage: Language? = nil","    ) async throws -> MultilingualSnippet {","        \/\/ Determine snippet language","        let targetLanguage = snippetLanguage ?? query.originalLanguage","        ","        \/\/ Find best matching content","        let matchingContent = findBestMatchingContent(","            document: document,","            query: query,","            targetLanguage: targetLanguage","        )","        ","        \/\/ Generate snippet in target language","        let snippet = try await generateSnippet(","            content: matchingContent.content,","            query: query.translations[targetLanguage]?.text ?? query.original,","            language: targetLanguage","        )","        ","        \/\/ Generate translations if needed","        var snippetTranslations: [Language: String] = [:]","        ","        if query.searchStrategy == .unified {","            for language in query.translations.keys where language != targetLanguage {","                let translatedSnippet = try await translateSnippet(","                    snippet: snippet,","                    from: targetLanguage,","                    to: language","                )","                snippetTranslations[language] = translatedSnippet","            }","        }","        ","        return MultilingualSnippet(","            primary: snippet,","            primaryLanguage: targetLanguage,","            translations: snippetTranslations,","            highlights: extractHighlights(","                snippet: snippet,","                query: query,","                language: targetLanguage","            )","        )","    }","    ","    \/\/ Cultural and linguistic adaptation","    func adaptSearchForCulture(","        query: String,","        sourceLanguage: Language,","        targetCulture: Culture","    ) async throws -> CulturallyAdaptedQuery {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"\"\"","                Adapt the search query for \\(targetCulture.name) cultural context.","                Consider:","                1. Cultural references and idioms","                2. Local terminology and expressions","                3. Regional variations","                4. Cultural sensitivities","                ","                Maintain search intent while adapting for cultural relevance.","                \"\"\"),","                .user(\"Query: \\(query)\\nSource Language: \\(sourceLanguage.code)\")","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let adaptation = try parseCulturalAdaptation(response.choices.first?.message.content ?? \"\")","        ","        return CulturallyAdaptedQuery(","            original: query,","            adapted: adaptation.adaptedQuery,","            culturalNotes: adaptation.notes,","            modifications: adaptation.modifications,","            confidence: adaptation.confidence","        )","    }","    ","    \/\/ Zero-shot cross-lingual transfer","    func zeroShotCrossLingualSearch(","        query: String,","        sourceLanguage: Language,","        targetDocuments: [Document],","        targetLanguage: Language","    ) async throws -> [CrossLingualMatch] {","        \/\/ Generate language-agnostic representation","        let queryRepresentation = try await generateLanguageAgnosticRepresentation(","            text: query,","            language: sourceLanguage","        )","        ","        \/\/ Score against target language documents","        var matches: [CrossLingualMatch] = []","        ","        for document in targetDocuments {","            let docRepresentation = try await generateLanguageAgnosticRepresentation(","                text: document.content,","                language: targetLanguage","            )","            ","            let similarity = calculateAgnosticSimilarity(","                queryRepresentation,","                docRepresentation","            )","            ","            if similarity.score > 0.5 {","                matches.append(CrossLingualMatch(","                    document: document,","                    score: similarity.score,","                    confidence: similarity.confidence,","                    matchType: .zeroShot","                ))","            }","        }","        ","        return matches.sorted { $0.score > $1.score }","    }","    ","    \/\/ Helper functions","    private func detectLanguage(_ text: String) async throws -> Language {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"Detect the language of the text. Return only the ISO 639-1 language code.\"),","                .user(text)","            ]","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let code = response.choices.first?.message.content?.trimmingCharacters(in: .whitespacesAndNewlines) ?? \"en\"","        ","        return Language(code: code)","    }","    ","    private func translateQuery(","        query: String,","        from: Language,","        to: Language,","        preserveIntent: Bool","    ) async throws -> Translation {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"\"\"","                Translate the search query from \\(from.code) to \\(to.code).","                \\(preserveIntent ? \"Preserve the search intent and information retrieval effectiveness.\" : \"\")","                Return JSON with:","                - text: translated query","                - confidence: translation confidence (0-1)","                - notes: any translation notes","                \"\"\"),","                .user(query)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        return try parseTranslation(response.choices.first?.message.content ?? \"\")","    }","    ","    private func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","    ","    private func calculateLanguageDistance(_ lang1: Language, _ lang2: Language) -> Float {","        \/\/ Simple language distance calculation","        if lang1 == lang2 { return 0.0 }","        if lang1.family == lang2.family { return 0.3 }","        if lang1.script == lang2.script { return 0.5 }","        return 0.8","    }","}","","\/\/ Data structures","struct Language: Equatable, Hashable {","    let code: String","    var family: String? { LanguageFamily.family(for: code) }","    var script: String? { LanguageScript.script(for: code) }","    ","    static let auto = Language(code: \"auto\")","    static let english = Language(code: \"en\")","    static let spanish = Language(code: \"es\")","    static let french = Language(code: \"fr\")","    static let german = Language(code: \"de\")","    static let chinese = Language(code: \"zh\")","    static let japanese = Language(code: \"ja\")","    static let arabic = Language(code: \"ar\")","}","","struct LanguageFamily {","    static func family(for code: String) -> String? {","        switch code {","        case \"en\", \"de\", \"nl\", \"sv\": return \"germanic\"","        case \"es\", \"fr\", \"it\", \"pt\": return \"romance\"","        case \"zh\", \"ja\", \"ko\": return \"east-asian\"","        case \"ar\", \"he\": return \"semitic\"","        default: return nil","        }","    }","}","","struct LanguageScript {","    static func script(for code: String) -> String? {","        switch code {","        case \"en\", \"es\", \"fr\", \"de\": return \"latin\"","        case \"zh\": return \"chinese\"","        case \"ja\": return \"japanese\"","        case \"ar\": return \"arabic\"","        case \"ru\": return \"cyrillic\"","        default: return nil","        }","    }","}","","enum AlignmentStrategy {","    case multilingual","    case pivotLanguage(Language)","    case pairwise","}","","struct CrossLingualEmbedding {","    let vector: [Float]","    let sourceLanguage: Language","    let languageFeatures: LanguageFeatures","    let alignmentMetadata: AlignmentMetadata","}","","struct LanguageFeatures {","    let morphology: MorphologyFeatures?","    let syntax: SyntaxFeatures?","    let semantics: SemanticFeatures?","}","","struct MorphologyFeatures {","    let stemmedForms: [String]","    let lemmas: [String]","    let affixes: [String]","}","","struct SyntaxFeatures {","    let posPatterns: [String]","    let dependencies: [String]","}","","struct SemanticFeatures {","    let concepts: [String]","    let domains: [String]","}","","struct AlignmentMetadata {","    let strategy: AlignmentStrategy","    let confidence: Float","}","","struct Translation {","    let text: String","    let confidence: Float","    let notes: [String]","}","","struct MultilingualQuery {","    let original: String","    let originalLanguage: Language","    let translations: [Language: Translation]","    let unifiedRepresentation: UnifiedQueryRepresentation","    let searchStrategy: MultilingualSearchStrategy","}","","enum MultilingualSearchStrategy {","    case unified","    case perLanguage","    case hybrid","}","","struct UnifiedQueryRepresentation {","    let embedding: [Float]","    let languageWeights: [Language: Float]","}","","enum CrossLingualMetric {","    case strict","    case lenient","    case adaptive","}","","struct CrossLingualSimilarityScore {","    let baseScore: Float","    let adjustedScore: Float","    let languageDistance: Float","    let featureMatchScore: Float","    let confidence: Float","}","","struct MultilingualDocument {","    let id: String","    let content: [Language: String]","    let languages: Set<Language>","    let primaryLanguage: Language","}","","enum MultilingualIndexingStrategy {","    case unified","    case perLanguage","    case hybrid","}","","struct MultilingualSearchIndex {","    var unifiedIndex: [String: UnifiedDocumentEmbedding] = [:]","    var languageIndices: [Language: [String: CrossLingualEmbedding]] = [:]","    var languageOptimizations: [Language: LanguageOptimization] = [:]","    ","    mutating func addDocument(id: String, embedding: UnifiedDocumentEmbedding, languages: Set<Language>) {","        unifiedIndex[id] = embedding","    }","    ","    mutating func addToLanguageIndex(language: Language, documentId: String, embedding: CrossLingualEmbedding) {","        if languageIndices[language] == nil {","            languageIndices[language] = [:]","        }","        languageIndices[language]?[documentId] = embedding","    }","    ","    mutating func buildLanguageOptimizations() {","        \/\/ Build language-specific optimizations","    }","}","","struct UnifiedDocumentEmbedding {","    let vector: [Float]","    let languageContributions: [Language: Float]","}","","struct LanguageOptimization {","    let stopwords: Set<String>","    let stemmer: String?","    let tokenizer: String","}","","struct MultilingualSearchResult {","    let documentId: String","    let languages: Set<Language>","    let content: [Language: String]","}","","enum MultilingualRankingStrategy {","    case weighted","    case maxScore","    case average","}","","struct RankedMultilingualResult {","    let result: MultilingualSearchResult","    let combinedScore: Float","    let languageScores: [Language: Float]","    let explanations: [Language: String]","    let primaryLanguage: Language","}","","struct ScoringResult {","    let score: Float","    let explanation: String","}","","struct MultilingualSnippet {","    let primary: String","    let primaryLanguage: Language","    let translations: [Language: String]","    let highlights: [TextHighlight]","}","","struct TextHighlight {","    let start: Int","    let end: Int","    let score: Float","}","","struct Culture {","    let name: String","    let region: String","    let languageVariants: [Language]","}","","struct CulturallyAdaptedQuery {","    let original: String","    let adapted: String","    let culturalNotes: [String]","    let modifications: [QueryModification]","    let confidence: Float","}","","struct QueryModification {","    let original: String","    let modified: String","    let reason: String","}","","struct Document {","    let id: String","    let content: String","}","","struct CrossLingualMatch {","    let document: Document","    let score: Float","    let confidence: Float","    let matchType: MatchType","}","","enum MatchType {","    case direct","    case translated","    case zeroShot","}","","struct LanguageAgnosticRepresentation {","    let conceptVector: [Float]","    let universalFeatures: [String: Float]","}","","struct AgnosticSimilarity {","    let score: Float","    let confidence: Float","}","","\/\/ Usage example","func demonstrateMultilingualSearch() async throws {","    let openAI = OpenAI(apiKey: \"your-api-key\")","    let supportedLanguages: Set<Language> = [.english, .spanish, .french, .chinese]","    ","    let multilingualSearch = MultilingualSemanticSearch(","        openAI: openAI,","        supportedLanguages: supportedLanguages","    )","    ","    \/\/ Example 1: Cross-lingual query processing","    let query = \"machine learning algorithms\"","    let multilingualQuery = try await multilingualSearch.processMultilingualQuery(","        query: query,","        targetLanguages: supportedLanguages","    )","    ","    print(\"Query translated to \\(multilingualQuery.translations.count) languages\")","    ","    \/\/ Example 2: Cross-lingual embedding","    let embedding = try await multilingualSearch.generateCrossLingualEmbedding(","        text: \"algoritmos de aprendizaje automático\",","        sourceLanguage: .spanish,","        alignmentStrategy: .multilingual","    )","    ","    print(\"Cross-lingual embedding generated with confidence: \\(embedding.alignmentMetadata.confidence)\")","    ","    \/\/ Example 3: Multilingual indexing","    let documents = [","        MultilingualDocument(","            id: \"1\",","            content: [","                .english: \"Machine learning is a subset of AI\",","                .spanish: \"El aprendizaje automático es un subconjunto de IA\"","            ],","            languages: [.english, .spanish],","            primaryLanguage: .english","        )","    ]","    ","    let index = try await multilingualSearch.createMultilingualIndex(","        documents: documents,","        indexingStrategy: .hybrid","    )","    ","    print(\"Multilingual index created with \\(index.unifiedIndex.count) documents\")","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search","type":"topic","role":"project","title":"Building Semantic Search","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"estimatedTime":"20min","url":"\/tutorials\/openaikit\/09-building-semantic-search","kind":"project"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Streaming-Research-Responses":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Streaming-Research-Responses","role":"pseudoSymbol","title":"Streaming Research Responses","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"url":"\/tutorials\/openaikit\/09-deep-research-analysis#Streaming-Research-Responses","kind":"section"},"app-01-ingest.swift":{"fileName":"KnowledgeBaseApp.swift","fileType":"swift","identifier":"app-01-ingest.swift","highlights":[],"content":["import OpenAIKit","import Foundation","","\/\/ Document ingestion pipeline for semantic search","class DocumentIngestionPipeline {","    let openAI: OpenAI","    let vectorStore: VectorStore","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.vectorStore = VectorStore()","    }","    ","    \/\/ Process and ingest a document","    func ingestDocument(_ document: Document) async throws {","        print(\"Ingesting document: \\(document.title)\")","        ","        \/\/ Split document into chunks","        let chunks = splitIntoChunks(document.content, maxTokens: 500)","        ","        \/\/ Generate embeddings for each chunk","        for (index, chunk) in chunks.enumerated() {","            let embedding = try await generateEmbedding(for: chunk)","            ","            \/\/ Store chunk with metadata","            let chunkDocument = ChunkDocument(","                id: \"\\(document.id)_\\(index)\",","                documentId: document.id,","                content: chunk,","                embedding: embedding,","                metadata: ChunkMetadata(","                    title: document.title,","                    author: document.author,","                    category: document.category,","                    tags: document.tags,","                    chunkIndex: index,","                    totalChunks: chunks.count","                )","            )","            ","            try await vectorStore.store(chunkDocument)","        }","        ","        print(\"Successfully ingested \\(chunks.count) chunks\")","    }","    ","    \/\/ Generate embedding for text","    private func generateEmbedding(for text: String) async throws -> [Double] {","        let request = CreateEmbeddingRequest(","            model: .textEmbeddingAda002,","            input: .text(text)","        )","        ","        let response = try await openAI.embeddings.create(request)","        return response.data.first?.embedding ?? []","    }","    ","    \/\/ Split text into chunks with overlap","    private func splitIntoChunks(_ text: String, maxTokens: Int) -> [String] {","        let sentences = text.components(separatedBy: \". \")","        var chunks: [String] = []","        var currentChunk = \"\"","        var tokenCount = 0","        ","        for sentence in sentences {","            let sentenceTokens = estimateTokens(sentence)","            ","            if tokenCount + sentenceTokens > maxTokens && !currentChunk.isEmpty {","                chunks.append(currentChunk.trimmingCharacters(in: .whitespaces))","                \/\/ Keep last sentence for overlap","                currentChunk = chunks.last?.components(separatedBy: \". \").last ?? \"\"","                tokenCount = estimateTokens(currentChunk)","            }","            ","            currentChunk += sentence + \". \"","            tokenCount += sentenceTokens","        }","        ","        if !currentChunk.isEmpty {","            chunks.append(currentChunk.trimmingCharacters(in: .whitespaces))","        }","        ","        return chunks","    }","    ","    \/\/ Simple token estimation","    private func estimateTokens(_ text: String) -> Int {","        return text.split(separator: \" \").count * 4 \/ 3","    }","}","","\/\/ Document model","struct Document {","    let id: String","    let title: String","    let content: String","    let author: String","    let category: String","    let tags: [String]","    let createdAt: Date","}","","\/\/ Chunk document with embedding","struct ChunkDocument {","    let id: String","    let documentId: String","    let content: String","    let embedding: [Double]","    let metadata: ChunkMetadata","}","","\/\/ Chunk metadata","struct ChunkMetadata {","    let title: String","    let author: String","    let category: String","    let tags: [String]","    let chunkIndex: Int","    let totalChunks: Int","}","","\/\/ Vector store protocol","protocol VectorStoreProtocol {","    func store(_ document: ChunkDocument) async throws","    func search(embedding: [Double], limit: Int) async throws -> [SearchResult]","}","","\/\/ In-memory vector store implementation","class VectorStore: VectorStoreProtocol {","    private var documents: [ChunkDocument] = []","    ","    func store(_ document: ChunkDocument) async throws {","        documents.append(document)","    }","    ","    func search(embedding: [Double], limit: Int) async throws -> [SearchResult] {","        \/\/ Calculate cosine similarity for each document","        let results = documents.map { doc in","            let similarity = cosineSimilarity(embedding, doc.embedding)","            return SearchResult(","                document: doc,","                score: similarity","            )","        }","        ","        \/\/ Sort by similarity and return top results","        return Array(results.sorted { $0.score > $1.score }.prefix(limit))","    }","    ","    private func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        guard magnitudeA > 0 && magnitudeB > 0 else { return 0 }","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","}","","struct SearchResult {","    let document: ChunkDocument","    let score: Double","}","","\/\/ Usage example","func demonstrateIngestion() async throws {","    let pipeline = DocumentIngestionPipeline(apiKey: \"your-api-key\")","    ","    let document = Document(","        id: \"doc001\",","        title: \"Introduction to Machine Learning\",","        content: \"\"\"","        Machine learning is a subset of artificial intelligence that focuses on ","        the development of algorithms and statistical models that enable computer ","        systems to improve their performance on a specific task through experience. ","        Unlike traditional programming where explicit instructions are provided, ","        machine learning systems learn patterns from data and make decisions based ","        on that learning. The field encompasses various approaches including ","        supervised learning, unsupervised learning, and reinforcement learning. ","        Applications range from image recognition and natural language processing ","        to recommendation systems and autonomous vehicles.","        \"\"\",","        author: \"Dr. Sarah Johnson\",","        category: \"Technology\",","        tags: [\"AI\", \"Machine Learning\", \"Data Science\"],","        createdAt: Date()","    )","    ","    try await pipeline.ingestDocument(document)","}"],"type":"file","syntax":"swift"},"embeddings-05-batch.swift":{"syntax":"swift","highlights":[{"line":1},{"line":7},{"line":16},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":66},{"line":67},{"line":68},{"line":69}],"fileName":"EmbeddingGenerator.swift","fileType":"swift","type":"file","identifier":"embeddings-05-batch.swift","content":["\/\/ EmbeddingGenerator.swift - Batch processing","import Foundation","import OpenAIKit","","class EmbeddingGenerator {","    let openAI = OpenAIManager.shared.client","    private let maxBatchSize = 100","    ","    func generateEmbedding(for text: String) async throws -> [Float] {","        guard let openAI = openAI else {","            throw OpenAIError.missingAPIKey","        }","        ","        let request = EmbeddingRequest(","            input: text,","            model: \"text-embedding-3-small\",","            dimensions: nil,","            encodingFormat: .float,","            user: nil","        )","        ","        let response = try await openAI.embeddings.create(request)","        ","        guard let embedding = response.data.first?.embedding,","              let floatValues = embedding.floatValues else {","            throw EmbeddingError.noEmbeddingGenerated","        }","        ","        return floatValues","    }","    ","    func generateEmbeddings(for texts: [String]) async throws -> [[Float]] {","        guard let openAI = openAI else {","            throw OpenAIError.missingAPIKey","        }","        ","        var allEmbeddings: [[Float]] = []","        ","        \/\/ Process in batches","        for chunk in texts.chunked(into: maxBatchSize) {","            let request = EmbeddingRequest(","                input: chunk,","                model: \"text-embedding-3-small\",","                dimensions: nil,","                encodingFormat: .float,","                user: nil","            )","            ","            let response = try await openAI.embeddings.create(request)","            ","            let embeddings = response.data.compactMap { data -> [Float]? in","                guard let embedding = data.embedding,","                      let floatValues = embedding.floatValues else {","                    return nil","                }","                return floatValues","            }","            ","            allEmbeddings.append(contentsOf: embeddings)","        }","        ","        return allEmbeddings","    }","}","","extension Array {","    func chunked(into size: Int) -> [[Element]] {","        return stride(from: 0, to: count, by: size).map {","            Array(self[$0..<Swift.min($0 + size, count)])","        }","    }","}"]},"app-03-preview.swift":{"fileName":"KnowledgeBaseApp.swift","fileType":"swift","identifier":"app-03-preview.swift","highlights":[{"line":4},{"line":5},{"line":7},{"line":11},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":29},{"line":30},{"line":31},{"line":32},{"line":35},{"line":36},{"line":37},{"line":38},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":77},{"line":78},{"line":82},{"line":84},{"line":85},{"line":86},{"line":89},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":124},{"line":125},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":139},{"line":143},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":234},{"line":235},{"line":236},{"line":239},{"line":240},{"line":241},{"line":242},{"line":245},{"line":246},{"line":247},{"line":250},{"line":251},{"line":252},{"line":253},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":284},{"line":285},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":309},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":317},{"line":318},{"line":319},{"line":320},{"line":321},{"line":322},{"line":324},{"line":325},{"line":326},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":332},{"line":333},{"line":334},{"line":335},{"line":336},{"line":337},{"line":338},{"line":339},{"line":340},{"line":341},{"line":342},{"line":343},{"line":344},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363}],"content":["import OpenAIKit","import Foundation","","\/\/ Document preview functionality","class DocumentPreviewGenerator {","    let openAI: OpenAI","    let highlighter: TextHighlighter","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.highlighter = TextHighlighter()","    }","    ","    \/\/ Generate preview for search result","    func generatePreview(","        for result: RankedSearchResult,","        query: String,","        maxLength: Int = 300","    ) async throws -> DocumentPreview {","        let document = result.searchResult.document","        ","        \/\/ Extract relevant snippet","        let snippet = try await extractRelevantSnippet(","            content: document.content,","            query: query,","            maxLength: maxLength","        )","        ","        \/\/ Highlight query terms","        let highlightedSnippet = highlighter.highlight(","            text: snippet,","            terms: extractTerms(from: query)","        )","        ","        \/\/ Generate summary if needed","        let summary = try await generateSummary(","            content: document.content,","            focusOn: query","        )","        ","        return DocumentPreview(","            documentId: document.documentId,","            title: document.metadata.title,","            author: document.metadata.author,","            snippet: highlightedSnippet,","            summary: summary,","            relevanceScore: result.relevanceScore,","            matchedTerms: findMatchedTerms(content: document.content, query: query),","            previewMetadata: PreviewMetadata(","                wordCount: document.content.split(separator: \" \").count,","                readingTime: estimateReadingTime(document.content),","                lastModified: Date(),","                documentType: detectDocumentType(document.metadata)","            )","        )","    }","    ","    \/\/ Extract most relevant snippet","    private func extractRelevantSnippet(","        content: String,","        query: String,","        maxLength: Int","    ) async throws -> String {","        \/\/ Use LLM to find most relevant section","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Extract the most relevant snippet from the content that best answers the query.\"),","                .user(\"\"\"","                Query: \\(query)","                ","                Content: \\(content)","                ","                Extract a \\(maxLength) character snippet that best addresses the query.","                \"\"\")","            ],","            temperature: 0.1,","            maxTokens: maxLength \/ 4","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let snippet = response.choices.first?.message.content ?? \"\"","        ","        \/\/ Fallback to simple extraction if LLM fails","        if snippet.isEmpty {","            return simpleSnippetExtraction(content: content, query: query, maxLength: maxLength)","        }","        ","        return snippet","    }","    ","    \/\/ Simple snippet extraction fallback","    private func simpleSnippetExtraction(","        content: String,","        query: String,","        maxLength: Int","    ) -> String {","        let queryTerms = query.lowercased().components(separatedBy: .whitespacesAndNewlines)","        let sentences = content.components(separatedBy: \". \")","        ","        \/\/ Find sentences containing query terms","        let relevantSentences = sentences.filter { sentence in","            let lowerSentence = sentence.lowercased()","            return queryTerms.contains { lowerSentence.contains($0) }","        }","        ","        \/\/ Build snippet from relevant sentences","        var snippet = \"\"","        for sentence in relevantSentences {","            if snippet.count + sentence.count > maxLength {","                break","            }","            snippet += sentence + \". \"","        }","        ","        \/\/ If no relevant sentences, use beginning of content","        if snippet.isEmpty {","            snippet = String(content.prefix(maxLength))","        }","        ","        return snippet.trimmingCharacters(in: .whitespacesAndNewlines)","    }","    ","    \/\/ Generate focused summary","    private func generateSummary(content: String, focusOn query: String) async throws -> String {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Create a concise summary focusing on aspects related to the query.\"),","                .user(\"\"\"","                Query: \\(query)","                ","                Content: \\(content)","                ","                Provide a 2-3 sentence summary focusing on information relevant to the query.","                \"\"\")","            ],","            temperature: 0.3,","            maxTokens: 150","        )","        ","        let response = try await openAI.chat.completions.create(request)","        return response.choices.first?.message.content ?? \"Summary unavailable\"","    }","    ","    \/\/ Extract search terms","    private func extractTerms(from query: String) -> [String] {","        return query.lowercased()","            .components(separatedBy: .whitespacesAndNewlines)","            .filter { $0.count > 2 }","    }","    ","    \/\/ Find matched terms in content","    private func findMatchedTerms(content: String, query: String) -> [MatchedTerm] {","        let queryTerms = extractTerms(from: query)","        let contentLower = content.lowercased()","        ","        return queryTerms.compactMap { term in","            let count = contentLower.components(separatedBy: term).count - 1","            if count > 0 {","                return MatchedTerm(term: term, frequency: count)","            }","            return nil","        }","    }","    ","    \/\/ Estimate reading time","    private func estimateReadingTime(_ content: String) -> TimeInterval {","        let wordsPerMinute = 200.0","        let wordCount = Double(content.split(separator: \" \").count)","        return (wordCount \/ wordsPerMinute) * 60 \/\/ Return in seconds","    }","    ","    \/\/ Detect document type","    private func detectDocumentType(_ metadata: ChunkMetadata) -> DocumentType {","        switch metadata.category.lowercased() {","        case \"technology\", \"science\":","            return .technical","        case \"tutorial\", \"guide\":","            return .educational","        case \"news\", \"article\":","            return .article","        default:","            return .general","        }","    }","}","","\/\/ Text highlighter","class TextHighlighter {","    func highlight(text: String, terms: [String]) -> HighlightedText {","        var highlights: [TextHighlight] = []","        let lowerText = text.lowercased()","        ","        for term in terms {","            var searchRange = lowerText.startIndex..<lowerText.endIndex","            ","            while let range = lowerText.range(of: term, options: .caseInsensitive, range: searchRange) {","                let startOffset = lowerText.distance(from: lowerText.startIndex, to: range.lowerBound)","                let endOffset = lowerText.distance(from: lowerText.startIndex, to: range.upperBound)","                ","                highlights.append(TextHighlight(","                    range: startOffset..<endOffset,","                    term: term,","                    style: .primary","                ))","                ","                searchRange = range.upperBound..<lowerText.endIndex","            }","        }","        ","        \/\/ Sort highlights by position","        highlights.sort { $0.range.lowerBound < $1.range.lowerBound }","        ","        return HighlightedText(","            text: text,","            highlights: highlights","        )","    }","}","","\/\/ Preview models","struct DocumentPreview {","    let documentId: String","    let title: String","    let author: String","    let snippet: HighlightedText","    let summary: String","    let relevanceScore: Double","    let matchedTerms: [MatchedTerm]","    let previewMetadata: PreviewMetadata","}","","struct HighlightedText {","    let text: String","    let highlights: [TextHighlight]","}","","struct TextHighlight {","    let range: Range<Int>","    let term: String","    let style: HighlightStyle","}","","enum HighlightStyle {","    case primary","    case secondary","}","","struct MatchedTerm {","    let term: String","    let frequency: Int","}","","struct PreviewMetadata {","    let wordCount: Int","    let readingTime: TimeInterval","    let lastModified: Date","    let documentType: DocumentType","}","","enum DocumentType {","    case technical","    case educational","    case article","    case general","}","","\/\/ Preview renderer","class PreviewRenderer {","    func render(_ preview: DocumentPreview) -> String {","        var output = \"\"","        ","        \/\/ Title and metadata","        output += \"\\(preview.title)\\n\"","        output += \"By \\(preview.author) • \\(formatReadingTime(preview.previewMetadata.readingTime))\\n\"","        output += \"Relevance: \\(String(format: \"%.1f%%\", preview.relevanceScore * 100))\\n\\n\"","        ","        \/\/ Highlighted snippet","        output += \"Preview:\\n\"","        output += renderHighlightedText(preview.snippet) + \"\\n\\n\"","        ","        \/\/ Summary","        output += \"Summary: \\(preview.summary)\\n\\n\"","        ","        \/\/ Matched terms","        if !preview.matchedTerms.isEmpty {","            output += \"Matched terms: \"","            output += preview.matchedTerms.map { \"\\($0.term) (\\($0.frequency))\" }.joined(separator: \", \")","        }","        ","        return output","    }","    ","    private func renderHighlightedText(_ highlightedText: HighlightedText) -> String {","        var result = highlightedText.text","        ","        \/\/ Apply highlights (in reverse order to maintain positions)","        for highlight in highlightedText.highlights.reversed() {","            let startIndex = result.index(result.startIndex, offsetBy: highlight.range.lowerBound)","            let endIndex = result.index(result.startIndex, offsetBy: highlight.range.upperBound)","            let highlightedTerm = \"**\\(result[startIndex..<endIndex])**\"","            result.replaceSubrange(startIndex..<endIndex, with: highlightedTerm)","        }","        ","        return result","    }","    ","    private func formatReadingTime(_ seconds: TimeInterval) -> String {","        let minutes = Int(seconds \/ 60)","        if minutes < 1 {","            return \"< 1 min read\"","        } else {","            return \"\\(minutes) min read\"","        }","    }","}","","\/\/ Usage example","func demonstratePreview() async throws {","    let previewGenerator = DocumentPreviewGenerator(apiKey: \"your-api-key\")","    let renderer = PreviewRenderer()","    ","    \/\/ Create mock search result","    let mockResult = RankedSearchResult(","        searchResult: SearchResult(","            document: ChunkDocument(","                id: \"chunk001\",","                documentId: \"doc001\",","                content: \"\"\"","                Machine learning algorithms are computational methods that enable ","                computers to learn from data without being explicitly programmed. ","                These algorithms build mathematical models based on training data ","                to make predictions or decisions. Common types include supervised ","                learning, unsupervised learning, and reinforcement learning.","                \"\"\",","                embedding: [],","                metadata: ChunkMetadata(","                    title: \"Introduction to Machine Learning\",","                    author: \"Dr. Sarah Johnson\",","                    category: \"Technology\",","                    tags: [\"AI\", \"Machine Learning\"],","                    chunkIndex: 0,","                    totalChunks: 5","                )","            ),","            score: 0.85","        ),","        rank: 1,","        relevanceScore: 0.85,","        explanation: \"Highly relevant content\"","    )","    ","    \/\/ Generate preview","    let preview = try await previewGenerator.generatePreview(","        for: mockResult,","        query: \"machine learning algorithms\",","        maxLength: 200","    )","    ","    \/\/ Render preview","    let renderedPreview = renderer.render(preview)","    print(renderedPreview)","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Creating-Dynamic-Personas":{"title":"Creating Dynamic Personas","abstract":[{"type":"text","text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Creating-Dynamic-Personas","url":"\/tutorials\/openaikit\/05-building-conversations#Creating-Dynamic-Personas"},"database-02-index.swift":{"syntax":"swift","highlights":[{"line":4},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":164},{"line":165},{"line":166},{"line":167},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":179},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":187},{"line":188},{"line":189},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":210},{"line":211},{"line":212},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":242},{"line":243},{"line":246},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":308},{"line":309},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":319},{"line":320},{"line":321},{"line":326},{"line":327},{"line":328},{"line":329},{"line":365},{"line":366},{"line":367}],"fileName":"VectorDatabase.swift","fileType":"swift","type":"file","identifier":"database-02-index.swift","content":["import Foundation","import CoreData","","\/\/ MARK: - Vector Index Management","","\/\/\/ Index structure for efficient vector similarity search","class VectorIndex {","    private var indexMap: [String: IndexNode] = [:]","    private let dimension: Int","    private let maxPointsPerNode: Int","    private let queue = DispatchQueue(label: \"vectordb.index\", attributes: .concurrent)","    ","    struct IndexNode {","        let centroid: [Float]","        var documentIds: Set<String>","        var children: [IndexNode]?","        let depth: Int","        ","        var isLeaf: Bool {","            children == nil","        }","    }","    ","    init(dimension: Int, maxPointsPerNode: Int = 100) {","        self.dimension = dimension","        self.maxPointsPerNode = maxPointsPerNode","    }","    ","    \/\/ MARK: - Index Building","    ","    func buildIndex(from documents: [(id: String, embedding: [Float])]) async {","        await withCheckedContinuation { continuation in","            queue.async(flags: .barrier) {","                \/\/ Clear existing index","                self.indexMap.removeAll()","                ","                \/\/ Group documents by similarity for hierarchical indexing","                let rootNode = self.buildHierarchicalIndex(","                    documents: documents,","                    depth: 0","                )","                ","                \/\/ Store nodes in flat map for fast access","                self.traverseAndStore(node: rootNode, prefix: \"root\")","                ","                continuation.resume()","            }","        }","    }","    ","    private func buildHierarchicalIndex(","        documents: [(id: String, embedding: [Float])],","        depth: Int","    ) -> IndexNode {","        \/\/ Calculate centroid of all documents","        let centroid = calculateCentroid(embeddings: documents.map { $0.embedding })","        ","        \/\/ If few enough documents, create leaf node","        if documents.count <= maxPointsPerNode {","            return IndexNode(","                centroid: centroid,","                documentIds: Set(documents.map { $0.id }),","                children: nil,","                depth: depth","            )","        }","        ","        \/\/ Otherwise, partition documents using k-means clustering","        let clusters = kMeansClustering(","            documents: documents,","            k: min(4, documents.count \/ maxPointsPerNode + 1)","        )","        ","        \/\/ Recursively build child nodes","        let children = clusters.map { cluster in","            buildHierarchicalIndex(documents: cluster, depth: depth + 1)","        }","        ","        return IndexNode(","            centroid: centroid,","            documentIds: Set(documents.map { $0.id }),","            children: children,","            depth: depth","        )","    }","    ","    \/\/ MARK: - Search","    ","    func search(","        queryVector: [Float],","        k: Int,","        pruningFactor: Float = 2.0","    ) async -> [String] {","        await withCheckedContinuation { continuation in","            queue.async {","                var candidates: [(id: String, distance: Float)] = []","                ","                \/\/ Start from root and traverse index","                if let rootNode = self.indexMap[\"root\"] {","                    self.searchNode(","                        node: rootNode,","                        queryVector: queryVector,","                        k: k,","                        pruningFactor: pruningFactor,","                        candidates: &candidates","                    )","                }","                ","                \/\/ Sort by distance and return top k","                candidates.sort { $0.distance < $1.distance }","                let results = Array(candidates.prefix(k).map { $0.id })","                ","                continuation.resume(returning: results)","            }","        }","    }","    ","    private func searchNode(","        node: IndexNode,","        queryVector: [Float],","        k: Int,","        pruningFactor: Float,","        candidates: inout [(id: String, distance: Float)]","    ) {","        \/\/ Calculate distance to node centroid","        let centroidDistance = euclideanDistance(queryVector, node.centroid)","        ","        if let children = node.children {","            \/\/ Internal node: search relevant children","            let childDistances = children.map { child in","                (child: child, distance: euclideanDistance(queryVector, child.centroid))","            }","            ","            \/\/ Sort children by distance","            let sortedChildren = childDistances.sorted { $0.distance < $1.distance }","            ","            \/\/ Search closest children first","            let searchLimit = Int(ceil(Double(children.count) \/ Double(pruningFactor)))","            for i in 0..<min(searchLimit, sortedChildren.count) {","                searchNode(","                    node: sortedChildren[i].child,","                    queryVector: queryVector,","                    k: k,","                    pruningFactor: pruningFactor,","                    candidates: &candidates","                )","            }","        } else {","            \/\/ Leaf node: add all documents as candidates","            for docId in node.documentIds {","                candidates.append((id: docId, distance: centroidDistance))","            }","        }","    }","    ","    \/\/ MARK: - Index Persistence","    ","    func saveIndex(to url: URL) throws {","        let encoder = JSONEncoder()","        let data = try encoder.encode(IndexData(indexMap: indexMap))","        try data.write(to: url)","    }","    ","    func loadIndex(from url: URL) throws {","        let data = try Data(contentsOf: url)","        let decoder = JSONDecoder()","        let indexData = try decoder.decode(IndexData.self, from: data)","        ","        queue.async(flags: .barrier) {","            self.indexMap = indexData.indexMap","        }","    }","    ","    \/\/ MARK: - Helper Methods","    ","    private func calculateCentroid(embeddings: [[Float]]) -> [Float] {","        guard !embeddings.isEmpty else { return Array(repeating: 0, count: dimension) }","        ","        var centroid = Array(repeating: Float(0), count: dimension)","        ","        for embedding in embeddings {","            for i in 0..<dimension {","                centroid[i] += embedding[i]","            }","        }","        ","        let count = Float(embeddings.count)","        for i in 0..<dimension {","            centroid[i] \/= count","        }","        ","        return centroid","    }","    ","    private func euclideanDistance(_ a: [Float], _ b: [Float]) -> Float {","        var sum: Float = 0","        for i in 0..<min(a.count, b.count) {","            let diff = a[i] - b[i]","            sum += diff * diff","        }","        return sqrt(sum)","    }","    ","    private func kMeansClustering(","        documents: [(id: String, embedding: [Float])],","        k: Int","    ) -> [[(id: String, embedding: [Float])]] {","        guard documents.count >= k else { return [documents] }","        ","        \/\/ Initialize centroids randomly","        var centroids = Array(documents.shuffled().prefix(k).map { $0.embedding })","        var clusters: [[(id: String, embedding: [Float])]] = Array(repeating: [], count: k)","        ","        \/\/ Run k-means iterations","        for _ in 0..<10 {","            \/\/ Clear clusters","            clusters = Array(repeating: [], count: k)","            ","            \/\/ Assign documents to nearest centroid","            for doc in documents {","                var minDistance = Float.infinity","                var nearestCluster = 0","                ","                for (i, centroid) in centroids.enumerated() {","                    let distance = euclideanDistance(doc.embedding, centroid)","                    if distance < minDistance {","                        minDistance = distance","                        nearestCluster = i","                    }","                }","                ","                clusters[nearestCluster].append(doc)","            }","            ","            \/\/ Update centroids","            for i in 0..<k {","                if !clusters[i].isEmpty {","                    centroids[i] = calculateCentroid(embeddings: clusters[i].map { $0.embedding })","                }","            }","        }","        ","        return clusters.filter { !$0.isEmpty }","    }","    ","    private func traverseAndStore(node: IndexNode, prefix: String) {","        indexMap[prefix] = node","        ","        if let children = node.children {","            for (i, child) in children.enumerated() {","                traverseAndStore(node: child, prefix: \"\\(prefix).\\(i)\")","            }","        }","    }","}","","\/\/ MARK: - Codable Support","","extension VectorIndex.IndexNode: Codable {","    enum CodingKeys: String, CodingKey {","        case centroid, documentIds, children, depth","    }","}","","struct IndexData: Codable {","    let indexMap: [String: VectorIndex.IndexNode]","}","","\/\/ MARK: - Indexed Vector Database","","class IndexedVectorDatabase: CoreDataVectorDatabase {","    private var index: VectorIndex?","    private let indexQueue = DispatchQueue(label: \"vectordb.indexing\")","    ","    override init(modelName: String = \"VectorDB\") {","        super.init(modelName: modelName)","        setupIndexing()","    }","    ","    private func setupIndexing() {","        \/\/ Initialize index based on first document's dimension","        indexQueue.async {","            self.rebuildIndexIfNeeded()","        }","    }","    ","    override func insertBatch(documents: [VectorDocumentInput]) async throws -> [String] {","        let ids = try await super.insertBatch(documents: documents)","        ","        \/\/ Rebuild index asynchronously","        indexQueue.async {","            self.rebuildIndexIfNeeded()","        }","        ","        return ids","    }","    ","    override func search(query: VectorQuery) async throws -> [VectorSearchResult] {","        \/\/ Use index for initial candidate selection if available","        if let index = index, let limit = query.limit {","            let candidateIds = await index.search(","                queryVector: query.vector,","                k: limit * 3,  \/\/ Get more candidates for final filtering","                pruningFactor: 2.0","            )","            ","            \/\/ Fetch and score only candidate documents","            return try await fetchAndScore(","                candidateIds: candidateIds,","                query: query","            )","        }","        ","        \/\/ Fall back to linear search","        return try await super.search(query: query)","    }","    ","    private func fetchAndScore(","        candidateIds: [String],","        query: VectorQuery","    ) async throws -> [VectorSearchResult] {","        return try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let request = VectorDocument.fetchRequest()","                    request.predicate = NSPredicate(","                        format: \"id IN %@\",","                        candidateIds","                    )","                    ","                    let documents = try context.fetch(request)","                    ","                    var results: [VectorSearchResult] = []","                    ","                    for doc in documents {","                        let similarity = SimilarityCalculator.cosineSimilarity(","                            query.vector,","                            doc.embedding","                        )","                        ","                        if similarity >= query.threshold {","                            results.append(VectorSearchResult(","                                id: doc.id,","                                content: doc.content,","                                similarity: similarity,","                                metadata: doc.metadataDict,","                                embedding: doc.embedding","                            ))","                        }","                    }","                    ","                    results.sort { $0.similarity > $1.similarity }","                    if let limit = query.limit {","                        results = Array(results.prefix(limit))","                    }","                    ","                    continuation.resume(returning: results)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    private func rebuildIndexIfNeeded() {","        \/\/ This method would be called periodically or after significant changes","        \/\/ Implementation would fetch all documents and rebuild the index","    }","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Check-Your-Understanding":{"titleInlineContent":[{"type":"text","text":"Check Your Understanding"}],"url":"\/tutorials\/openaikit\/08-transcribing-audio#Check-Your-Understanding","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Check-Your-Understanding","type":"link","title":"Check Your Understanding"},"embeddings-02-function.swift":{"fileName":"EmbeddingGenerator.swift","fileType":"swift","identifier":"embeddings-02-function.swift","highlights":[{"line":2},{"line":3},{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12}],"content":["\/\/ EmbeddingGenerator.swift","import Foundation","import OpenAIKit","","class EmbeddingGenerator {","    let openAI = OpenAIManager.shared.client","    ","    func generateEmbedding(for text: String) async throws -> [Float] {","        \/\/ Implementation here","        return []","    }","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit#Configure-OpenAIKit":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Configure-OpenAIKit","role":"pseudoSymbol","title":"Configure OpenAIKit","abstract":[{"type":"text","text":"Configure OpenAIKit in your Swift project and authenticate with the OpenAI API."}],"url":"\/tutorials\/openaikit\/01-setting-up-openaikit#Configure-OpenAIKit","kind":"section"},"advanced-05-realtime.swift":{"syntax":"swift","highlights":[{"line":3},{"line":5},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":104},{"line":105},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":145},{"line":146},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":195},{"line":196},{"line":197},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":220},{"line":221},{"line":224},{"line":225},{"line":226},{"line":227},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":245},{"line":246},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":252},{"line":253},{"line":254},{"line":256},{"line":257},{"line":258},{"line":259},{"line":262},{"line":263},{"line":264},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":284},{"line":285},{"line":286},{"line":287},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":306},{"line":307},{"line":308},{"line":311},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":322},{"line":323},{"line":326},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":332},{"line":333},{"line":334},{"line":335},{"line":338},{"line":339},{"line":340},{"line":341},{"line":344},{"line":345},{"line":346},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":366},{"line":367},{"line":368},{"line":369},{"line":370},{"line":371},{"line":372},{"line":373},{"line":374},{"line":379},{"line":380},{"line":381},{"line":382},{"line":383},{"line":384},{"line":385},{"line":386},{"line":387},{"line":389},{"line":390},{"line":391},{"line":394},{"line":395},{"line":396},{"line":397},{"line":398},{"line":399},{"line":401},{"line":402},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":412},{"line":413},{"line":414},{"line":415},{"line":416},{"line":417},{"line":418},{"line":419},{"line":420},{"line":421},{"line":422},{"line":423},{"line":424},{"line":425},{"line":426},{"line":427},{"line":428},{"line":429},{"line":430},{"line":431},{"line":432},{"line":434},{"line":437},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":444},{"line":445},{"line":446},{"line":447},{"line":448},{"line":449},{"line":450},{"line":451},{"line":452},{"line":453},{"line":454},{"line":455},{"line":456},{"line":457},{"line":461},{"line":462},{"line":463},{"line":466},{"line":467},{"line":471},{"line":472},{"line":473},{"line":474},{"line":475},{"line":476},{"line":479},{"line":480},{"line":481},{"line":484},{"line":485},{"line":486},{"line":487},{"line":490},{"line":491},{"line":492},{"line":493},{"line":494},{"line":497},{"line":498},{"line":499},{"line":500},{"line":501},{"line":504},{"line":505},{"line":506},{"line":507},{"line":510},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":517},{"line":518},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":524},{"line":525},{"line":526},{"line":527},{"line":528},{"line":531},{"line":532},{"line":533},{"line":534},{"line":535},{"line":538},{"line":539},{"line":540},{"line":541},{"line":542},{"line":545},{"line":546},{"line":547},{"line":548},{"line":549},{"line":550},{"line":553},{"line":554},{"line":555},{"line":556},{"line":557},{"line":560},{"line":562},{"line":563},{"line":564},{"line":565},{"line":568},{"line":569},{"line":570},{"line":571},{"line":574},{"line":575},{"line":576},{"line":577},{"line":578},{"line":581},{"line":582},{"line":583},{"line":584},{"line":587},{"line":588},{"line":589},{"line":590},{"line":591},{"line":594},{"line":595},{"line":596},{"line":597},{"line":600},{"line":601},{"line":602},{"line":603},{"line":604},{"line":607},{"line":608},{"line":609},{"line":610},{"line":612},{"line":613},{"line":616},{"line":617},{"line":618},{"line":619},{"line":620},{"line":621},{"line":622},{"line":623},{"line":625},{"line":626},{"line":627},{"line":630},{"line":631},{"line":635},{"line":636},{"line":637},{"line":638},{"line":641},{"line":642},{"line":643},{"line":646},{"line":647},{"line":648},{"line":649},{"line":652},{"line":653},{"line":654},{"line":657},{"line":658},{"line":659},{"line":660},{"line":661},{"line":664},{"line":665},{"line":666},{"line":667},{"line":670},{"line":671},{"line":672},{"line":675},{"line":676},{"line":677},{"line":678},{"line":681},{"line":682},{"line":683},{"line":686},{"line":687},{"line":688},{"line":689},{"line":692},{"line":693},{"line":694},{"line":695},{"line":696},{"line":699},{"line":700},{"line":701},{"line":702},{"line":703},{"line":704},{"line":705},{"line":706},{"line":707},{"line":708},{"line":709},{"line":710},{"line":714},{"line":716},{"line":718},{"line":721},{"line":722},{"line":723},{"line":724},{"line":725},{"line":726},{"line":727},{"line":728},{"line":729},{"line":730},{"line":731},{"line":732},{"line":733},{"line":734},{"line":735},{"line":736},{"line":737},{"line":739},{"line":740},{"line":741},{"line":743},{"line":744},{"line":745},{"line":746},{"line":749},{"line":750},{"line":751},{"line":752},{"line":753},{"line":754},{"line":755},{"line":756},{"line":757},{"line":758},{"line":759},{"line":760},{"line":761},{"line":762},{"line":764},{"line":765},{"line":766},{"line":767},{"line":768},{"line":769},{"line":770},{"line":773},{"line":774},{"line":775}],"fileName":"AdvancedEmbeddings.swift","fileType":"swift","type":"file","identifier":"advanced-05-realtime.swift","content":["import OpenAIKit","import Foundation","import Combine","","\/\/ Real-time semantic search with streaming updates and incremental indexing","","actor RealTimeSemanticSearch {","    private let openAI: OpenAI","    private var searchIndex: IncrementalSearchIndex","    private var updateQueue: AsyncStream<IndexUpdate>","    private var subscribers: [UUID: SearchSubscriber] = [:]","    ","    \/\/ Real-time document ingestion pipeline","    func startRealTimeIngestion(","        documentStream: AsyncStream<IncomingDocument>","    ) async {","        \/\/ Process documents as they arrive","        for await document in documentStream {","            do {","                \/\/ Generate embedding immediately","                let embedding = try await generateStreamingEmbedding(document)","                ","                \/\/ Update index incrementally","                await updateIndexIncremental(","                    document: document,","                    embedding: embedding","                )","                ","                \/\/ Notify subscribers of new content","                await notifySubscribers(","                    update: .newDocument(document, embedding)","                )","                ","                \/\/ Update relevance models if needed","                if shouldUpdateModels(document) {","                    Task {","                        try await updateRelevanceModels(with: document)","                    }","                }","                ","            } catch {","                await handleIngestionError(document: document, error: error)","            }","        }","    }","    ","    \/\/ Streaming search with live updates","    func streamingSearch(","        query: String,","        options: StreamingSearchOptions = .default","    ) -> AsyncStream<StreamingSearchResult> {","        AsyncStream { continuation in","            Task {","                \/\/ Generate initial results","                let initialResults = try await performInitialSearch(","                    query: query,","                    options: options","                )","                ","                continuation.yield(.initial(initialResults))","                ","                \/\/ Subscribe to updates","                let subscriberId = UUID()","                let subscriber = SearchSubscriber(","                    query: query,","                    options: options,","                    continuation: continuation","                )","                ","                subscribers[subscriberId] = subscriber","                ","                \/\/ Set up periodic re-ranking","                if options.enablePeriodicReranking {","                    Task {","                        await performPeriodicReranking(","                            subscriberId: subscriberId,","                            interval: options.rerankingInterval","                        )","                    }","                }","                ","                \/\/ Handle continuation termination","                continuation.onTermination = { @Sendable _ in","                    Task {","                        await self.removeSubscriber(subscriberId)","                    }","                }","            }","        }","    }","    ","    \/\/ Incremental index updates","    private func updateIndexIncremental(","        document: IncomingDocument,","        embedding: DocumentEmbedding","    ) async {","        \/\/ Add to main index","        searchIndex.addDocument(","            id: document.id,","            embedding: embedding,","            timestamp: Date()","        )","        ","        \/\/ Update auxiliary structures","        await updateAuxiliaryStructures(document: document, embedding: embedding)","        ","        \/\/ Rebalance index if needed","        if searchIndex.needsRebalancing() {","            Task {","                await rebalanceIndex()","            }","        }","    }","    ","    \/\/ Live relevance feedback processing","    func processRelevanceFeedback(","        feedback: RelevanceFeedback","    ) async {","        \/\/ Update document scores immediately","        searchIndex.updateRelevanceScore(","            documentId: feedback.documentId,","            query: feedback.query,","            score: feedback.score","        )","        ","        \/\/ Propagate to active searches","        for (_, subscriber) in subscribers {","            if subscriber.query.similarityScore(feedback.query) > 0.7 {","                \/\/ Re-rank results for similar queries","                let updatedResults = await rerankWithFeedback(","                    subscriber: subscriber,","                    feedback: feedback","                )","                ","                subscriber.continuation.yield(.update(updatedResults))","            }","        }","        ","        \/\/ Update learning models","        Task {","            try await updateLearningModels(feedback: feedback)","        }","    }","    ","    \/\/ Real-time query expansion","    func adaptiveQueryExpansion(","        query: String,","        context: SearchContext","    ) -> AsyncStream<ExpandedQuery> {","        AsyncStream { continuation in","            Task {","                \/\/ Initial expansion","                let initialExpansion = try await expandQuery(","                    query: query,","                    context: context","                )","                continuation.yield(initialExpansion)","                ","                \/\/ Monitor search behavior","                let behaviorStream = monitorSearchBehavior(","                    query: query,","                    context: context","                )","                ","                for await behavior in behaviorStream {","                    \/\/ Adapt expansion based on user behavior","                    let adaptedExpansion = try await adaptQueryExpansion(","                        current: initialExpansion,","                        behavior: behavior","                    )","                    ","                    if adaptedExpansion.hasSignificantChanges {","                        continuation.yield(adaptedExpansion)","                    }","                }","            }","        }","    }","    ","    \/\/ Distributed search coordination","    func coordinateDistributedSearch(","        query: String,","        shards: [SearchShard]","    ) async throws -> DistributedSearchResult {","        \/\/ Create search tasks for each shard","        let searchTasks = shards.map { shard in","            Task {","                try await searchShard(","                    query: query,","                    shard: shard","                )","            }","        }","        ","        \/\/ Collect results as they complete","        var partialResults: [ShardResult] = []","        var completedShards = 0","        ","        for task in searchTasks {","            do {","                let result = try await task.value","                partialResults.append(result)","                completedShards += 1","                ","                \/\/ Stream partial results if enough shards have responded","                if shouldStreamPartialResults(","                    completed: completedShards,","                    total: shards.count","                ) {","                    let merged = mergePartialResults(partialResults)","                    \/\/ Stream merged results","                }","                ","            } catch {","                \/\/ Handle shard failure gracefully","                await handleShardFailure(error: error)","            }","        }","        ","        \/\/ Final result merging","        return mergeDistributedResults(partialResults)","    }","    ","    \/\/ Predictive caching for common queries","    func setupPredictiveCaching() async {","        \/\/ Analyze query patterns","        let patterns = await analyzeQueryPatterns()","        ","        \/\/ Pre-compute embeddings for predicted queries","        for pattern in patterns.topPatterns {","            let predictedQueries = generatePredictedQueries(from: pattern)","            ","            for query in predictedQueries {","                Task {","                    let embedding = try await generateQueryEmbedding(query)","                    searchIndex.cacheQueryEmbedding(","                        query: query,","                        embedding: embedding,","                        ttl: pattern.cacheDuration","                    )","                }","            }","        }","        ","        \/\/ Set up cache warming","        Task {","            await warmCache(patterns: patterns)","        }","    }","    ","    \/\/ Real-time index optimization","    func optimizeIndexInRealTime() async {","        \/\/ Monitor search performance","        let performanceStream = monitorSearchPerformance()","        ","        for await metrics in performanceStream {","            if metrics.averageLatency > searchIndex.targetLatency {","                \/\/ Optimize hot paths","                await optimizeHotPaths(metrics: metrics)","            }","            ","            if metrics.cacheHitRate < searchIndex.targetCacheHitRate {","                \/\/ Adjust caching strategy","                await adjustCachingStrategy(metrics: metrics)","            }","            ","            if metrics.indexFragmentation > 0.3 {","                \/\/ Schedule index compaction","                Task {","                    await compactIndex()","                }","            }","        }","    }","    ","    \/\/ Streaming embedding generation","    private func generateStreamingEmbedding(","        _ document: IncomingDocument","    ) async throws -> DocumentEmbedding {","        \/\/ Chunk document for streaming","        let chunks = chunkDocument(document)","        var chunkEmbeddings: [ChunkEmbedding] = []","        ","        \/\/ Process chunks in parallel with backpressure","        await withTaskGroup(of: ChunkEmbedding?.self) { group in","            var activeChunks = 0","            let maxConcurrent = 5","            ","            for (index, chunk) in chunks.enumerated() {","                \/\/ Wait if too many concurrent operations","                while activeChunks >= maxConcurrent {","                    if let embedding = await group.next() {","                        if let embedding = embedding {","                            chunkEmbeddings.append(embedding)","                        }","                        activeChunks -= 1","                    }","                }","                ","                group.addTask {","                    do {","                        let embedding = try await self.generateChunkEmbedding(","                            chunk: chunk,","                            index: index","                        )","                        return embedding","                    } catch {","                        return nil","                    }","                }","                activeChunks += 1","            }","            ","            \/\/ Collect remaining embeddings","            for await embedding in group {","                if let embedding = embedding {","                    chunkEmbeddings.append(embedding)","                }","            }","        }","        ","        \/\/ Combine chunk embeddings","        return combineChunkEmbeddings(chunkEmbeddings)","    }","    ","    \/\/ WebSocket-based search updates","    func websocketSearchSession(","        initialQuery: String,","        wsConnection: WebSocketConnection","    ) async {","        \/\/ Set up bidirectional communication","        let searchSession = SearchSession(","            id: UUID(),","            query: initialQuery,","            connection: wsConnection","        )","        ","        \/\/ Send initial results","        let initialResults = try? await performInitialSearch(","            query: initialQuery,","            options: .realtime","        )","        ","        if let results = initialResults {","            await wsConnection.send(.results(results))","        }","        ","        \/\/ Handle incoming messages","        for await message in wsConnection.incoming {","            switch message {","            case .refineQuery(let refinement):","                let refined = try? await refineSearch(","                    session: searchSession,","                    refinement: refinement","                )","                if let refined = refined {","                    await wsConnection.send(.results(refined))","                }","                ","            case .feedback(let feedback):","                await processRelevanceFeedback(feedback)","                ","            case .expandQuery(let expansion):","                let expanded = try? await expandSearchQuery(","                    session: searchSession,","                    expansion: expansion","                )","                if let expanded = expanded {","                    await wsConnection.send(.results(expanded))","                }","                ","            case .close:","                await closeSearchSession(searchSession)","                break","            }","        }","    }","    ","    \/\/ Helper functions","    private func notifySubscribers(update: IndexUpdate) async {","        for (_, subscriber) in subscribers {","            \/\/ Check if update is relevant to subscriber","            if isUpdateRelevant(update: update, subscriber: subscriber) {","                let updatedResults = await updateSearchResults(","                    subscriber: subscriber,","                    update: update","                )","                ","                subscriber.continuation.yield(.update(updatedResults))","            }","        }","    }","    ","    private func performPeriodicReranking(","        subscriberId: UUID,","        interval: TimeInterval","    ) async {","        while let subscriber = subscribers[subscriberId] {","            try? await Task.sleep(nanoseconds: UInt64(interval * 1_000_000_000))","            ","            if let subscriber = subscribers[subscriberId] {","                let rerankedResults = await rerankResults(","                    subscriber: subscriber,","                    includeNewDocuments: true","                )","                ","                subscriber.continuation.yield(.reranked(rerankedResults))","            }","        }","    }","    ","    private func removeSubscriber(_ id: UUID) {","        subscribers.removeValue(forKey: id)","    }","}","","\/\/ Data structures","struct IncrementalSearchIndex {","    private var documents: [String: IndexedDocument] = [:]","    private var embeddings: [String: [Float]] = [:]","    private var metadata: [String: DocumentMetadata] = [:]","    private var queryCache: LRUCache<String, CachedQuery> = LRUCache(capacity: 1000)","    ","    let targetLatency: TimeInterval = 0.1","    let targetCacheHitRate: Float = 0.8","    ","    mutating func addDocument(id: String, embedding: DocumentEmbedding, timestamp: Date) {","        documents[id] = IndexedDocument(","            id: id,","            embedding: embedding,","            timestamp: timestamp,","            version: generateVersion()","        )","        embeddings[id] = embedding.vector","    }","    ","    mutating func updateRelevanceScore(documentId: String, query: String, score: Float) {","        if var doc = documents[documentId] {","            doc.relevanceScores[query] = score","            documents[documentId] = doc","        }","    }","    ","    func needsRebalancing() -> Bool {","        \/\/ Check if index needs rebalancing","        let fragmentationRatio = calculateFragmentation()","        return fragmentationRatio > 0.3","    }","    ","    mutating func cacheQueryEmbedding(query: String, embedding: QueryEmbedding, ttl: TimeInterval) {","        queryCache.set(","            key: query,","            value: CachedQuery(","                embedding: embedding,","                timestamp: Date(),","                ttl: ttl","            )","        )","    }","    ","    private func calculateFragmentation() -> Float {","        \/\/ Calculate index fragmentation","        0.0","    }","    ","    private func generateVersion() -> Int {","        Int(Date().timeIntervalSince1970 * 1000)","    }","}","","struct IndexedDocument {","    let id: String","    let embedding: DocumentEmbedding","    let timestamp: Date","    let version: Int","    var relevanceScores: [String: Float] = [:]","}","","struct DocumentEmbedding {","    let vector: [Float]","    let chunks: [ChunkEmbedding]","}","","struct ChunkEmbedding {","    let index: Int","    let vector: [Float]","    let tokens: Int","}","","struct IncomingDocument {","    let id: String","    let content: String","    let metadata: [String: Any]","    let timestamp: Date","}","","enum IndexUpdate {","    case newDocument(IncomingDocument, DocumentEmbedding)","    case documentUpdate(String, DocumentEmbedding)","    case documentDeletion(String)","    case indexRebalance","}","","struct SearchSubscriber {","    let query: String","    let options: StreamingSearchOptions","    let continuation: AsyncStream<StreamingSearchResult>.Continuation","}","","struct StreamingSearchOptions {","    let enablePeriodicReranking: Bool","    let rerankingInterval: TimeInterval","    let includePartialResults: Bool","    let maxLatency: TimeInterval","    ","    static let `default` = StreamingSearchOptions(","        enablePeriodicReranking: true,","        rerankingInterval: 5.0,","        includePartialResults: true,","        maxLatency: 0.5","    )","    ","    static let realtime = StreamingSearchOptions(","        enablePeriodicReranking: true,","        rerankingInterval: 1.0,","        includePartialResults: true,","        maxLatency: 0.1","    )","}","","enum StreamingSearchResult {","    case initial([SearchResult])","    case update([SearchResult])","    case reranked([SearchResult])","    case partial([SearchResult], progress: Float)","}","","struct SearchResult {","    let documentId: String","    let score: Float","    let snippet: String","    let timestamp: Date","}","","struct RelevanceFeedback {","    let documentId: String","    let query: String","    let score: Float","    let userId: String","    let timestamp: Date","}","","struct SearchContext {","    let userId: String","    let sessionId: String","    let previousQueries: [String]","    let preferences: UserPreferences","}","","struct ExpandedQuery {","    let original: String","    let expansions: [String]","    let weights: [Float]","    let timestamp: Date","    var hasSignificantChanges: Bool","}","","struct UserBehavior {","    let clickedResults: [String]","    let dwellTime: [String: TimeInterval]","    let refinements: [String]","}","","struct SearchShard {","    let id: String","    let endpoint: URL","    let capacity: Int","    let latency: TimeInterval","}","","struct ShardResult {","    let shardId: String","    let results: [SearchResult]","    let latency: TimeInterval","}","","struct DistributedSearchResult {","    let results: [SearchResult]","    let totalShards: Int","    let respondedShards: Int","    let averageLatency: TimeInterval","}","","struct QueryPattern {","    let pattern: String","    let frequency: Int","    let cacheDuration: TimeInterval","}","","struct SearchPerformanceMetrics {","    let averageLatency: TimeInterval","    let cacheHitRate: Float","    let indexFragmentation: Float","    let queryThroughput: Float","}","","struct LRUCache<Key: Hashable, Value> {","    private var capacity: Int","    private var cache: [Key: Value] = [:]","    private var order: [Key] = []","    ","    init(capacity: Int) {","        self.capacity = capacity","    }","    ","    mutating func set(key: Key, value: Value) {","        if cache[key] != nil {","            order.removeAll { $0 == key }","        } else if cache.count >= capacity {","            if let oldest = order.first {","                cache.removeValue(forKey: oldest)","                order.removeFirst()","            }","        }","        ","        cache[key] = value","        order.append(key)","    }","    ","    func get(_ key: Key) -> Value? {","        cache[key]","    }","}","","struct CachedQuery {","    let embedding: QueryEmbedding","    let timestamp: Date","    let ttl: TimeInterval","}","","struct QueryEmbedding {","    let vector: [Float]","    let tokens: [String]","}","","struct SearchSession {","    let id: UUID","    var query: String","    let connection: WebSocketConnection","}","","struct WebSocketConnection {","    let incoming: AsyncStream<WebSocketMessage>","    let send: (WebSocketResponse) async -> Void","}","","enum WebSocketMessage {","    case refineQuery(QueryRefinement)","    case feedback(RelevanceFeedback)","    case expandQuery(QueryExpansion)","    case close","}","","enum WebSocketResponse {","    case results([SearchResult])","    case error(String)","    case status(String)","}","","struct QueryRefinement {","    let type: RefinementType","    let value: String","}","","enum RefinementType {","    case filter","    case boost","    case exclude","}","","struct QueryExpansion {","    let terms: [String]","    let weights: [Float]","}","","struct UserPreferences {","    let preferredLanguage: String","    let resultCount: Int","    let includeSnippets: Bool","}","","struct DocumentMetadata {","    let createdAt: Date","    let updatedAt: Date","    let source: String","    let tags: [String]","}","","\/\/ String similarity extension","extension String {","    func similarityScore(_ other: String) -> Float {","        \/\/ Simple Jaccard similarity for demonstration","        let set1 = Set(self.lowercased().split(separator: \" \"))","        let set2 = Set(other.lowercased().split(separator: \" \"))","        ","        let intersection = set1.intersection(set2).count","        let union = set1.union(set2).count","        ","        return union > 0 ? Float(intersection) \/ Float(union) : 0.0","    }","}","","\/\/ Usage example","func demonstrateRealTimeSearch() async throws {","    let openAI = OpenAI(apiKey: \"your-api-key\")","    let searchSystem = await RealTimeSemanticSearch(","        openAI: openAI,","        searchIndex: IncrementalSearchIndex()","    )","    ","    \/\/ Example 1: Start real-time document ingestion","    let documentStream = AsyncStream<IncomingDocument> { continuation in","        \/\/ Simulate incoming documents","        Task {","            for i in 0..<10 {","                let doc = IncomingDocument(","                    id: \"doc\\(i)\",","                    content: \"Sample document \\(i) about machine learning\",","                    metadata: [:],","                    timestamp: Date()","                )","                continuation.yield(doc)","                try? await Task.sleep(nanoseconds: 1_000_000_000) \/\/ 1 second","            }","            continuation.finish()","        }","    }","    ","    Task {","        await searchSystem.startRealTimeIngestion(documentStream: documentStream)","    }","    ","    \/\/ Example 2: Streaming search with live updates","    let searchStream = await searchSystem.streamingSearch(","        query: \"machine learning algorithms\",","        options: .realtime","    )","    ","    Task {","        for await result in searchStream {","            switch result {","            case .initial(let results):","                print(\"Initial results: \\(results.count)\")","            case .update(let results):","                print(\"Updated results: \\(results.count)\")","            case .reranked(let results):","                print(\"Reranked results: \\(results.count)\")","            case .partial(let results, let progress):","                print(\"Partial results: \\(results.count) (\\(progress * 100)% complete)\")","            }","        }","    }","    ","    \/\/ Example 3: Process relevance feedback","    let feedback = RelevanceFeedback(","        documentId: \"doc1\",","        query: \"machine learning\",","        score: 0.9,","        userId: \"user123\",","        timestamp: Date()","    )","    ","    await searchSystem.processRelevanceFeedback(feedback: feedback)","    ","    print(\"Real-time semantic search system initialized\")","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion#Building-a-Chat-Interface":{"title":"Building a Chat Interface","abstract":[{"type":"text","text":"Make your first API call to generate text using OpenAI’s chat completion models."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Building-a-Chat-Interface","url":"\/tutorials\/openaikit\/02-your-first-chat-completion#Building-a-Chat-Interface"},"advanced-02-expansion.swift":{"fileName":"AdvancedEmbeddings.swift","fileType":"swift","identifier":"advanced-02-expansion.swift","highlights":[{"line":4},{"line":6},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":155},{"line":156},{"line":157},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":246},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":332},{"line":333},{"line":334},{"line":335},{"line":336},{"line":337},{"line":338},{"line":339},{"line":340},{"line":341},{"line":342},{"line":343},{"line":344},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":368},{"line":369},{"line":370},{"line":371},{"line":372},{"line":373},{"line":374},{"line":375},{"line":376},{"line":379},{"line":380},{"line":381},{"line":382},{"line":383},{"line":384},{"line":385},{"line":386},{"line":387},{"line":390},{"line":391},{"line":392},{"line":393},{"line":396},{"line":397},{"line":400},{"line":401},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":412},{"line":413},{"line":414},{"line":415},{"line":416},{"line":417},{"line":420},{"line":421},{"line":422},{"line":423},{"line":424},{"line":425},{"line":428},{"line":429},{"line":430},{"line":431},{"line":432},{"line":433},{"line":434},{"line":435},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":446},{"line":447},{"line":448},{"line":449},{"line":450},{"line":453},{"line":454},{"line":455},{"line":458},{"line":459},{"line":460},{"line":461},{"line":464},{"line":465},{"line":466},{"line":467},{"line":470},{"line":471},{"line":472},{"line":473},{"line":474},{"line":475},{"line":476},{"line":479},{"line":480},{"line":481},{"line":482},{"line":485},{"line":486},{"line":487},{"line":488},{"line":491},{"line":492},{"line":493},{"line":494},{"line":497},{"line":498},{"line":499},{"line":500},{"line":501},{"line":504},{"line":505},{"line":506},{"line":507},{"line":508},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":526},{"line":527},{"line":528},{"line":529},{"line":532},{"line":533},{"line":534},{"line":535},{"line":536},{"line":539},{"line":540},{"line":541},{"line":542},{"line":543},{"line":544},{"line":545},{"line":546},{"line":547},{"line":548},{"line":549},{"line":550},{"line":553},{"line":554},{"line":555},{"line":556},{"line":559},{"line":560},{"line":562},{"line":563},{"line":566},{"line":567},{"line":568},{"line":569},{"line":570},{"line":571},{"line":572},{"line":574},{"line":576},{"line":578},{"line":579},{"line":580},{"line":581},{"line":582},{"line":584},{"line":585},{"line":586},{"line":587},{"line":589},{"line":591},{"line":592},{"line":593},{"line":594},{"line":595},{"line":598},{"line":599},{"line":600},{"line":601},{"line":603},{"line":605},{"line":606},{"line":607},{"line":608},{"line":609},{"line":610},{"line":611},{"line":612},{"line":613},{"line":614},{"line":615}],"content":["import OpenAIKit","import Foundation","","\/\/ Query expansion techniques for comprehensive semantic search","","struct QueryExpander {","    let openAI: OpenAI","    ","    \/\/ Synonym expansion using embeddings","    func synonymExpansion(query: String) async throws -> ExpandedQuery {","        \/\/ Generate variations using GPT","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"\"\"","                Generate synonyms and related terms for the search query.","                Return a JSON object with:","                - synonyms: array of synonym phrases","                - related: array of related concepts","                - broader: array of broader terms","                - narrower: array of more specific terms","                \"\"\"),","                .user(query)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let expansions = try parseExpansions(response.choices.first?.message.content ?? \"\")","        ","        \/\/ Generate embeddings for all variations","        var expandedTerms: [ExpandedTerm] = []","        ","        \/\/ Original query","        expandedTerms.append(ExpandedTerm(","            text: query,","            type: .original,","            weight: 1.0","        ))","        ","        \/\/ Synonyms","        for synonym in expansions.synonyms {","            expandedTerms.append(ExpandedTerm(","                text: synonym,","                type: .synonym,","                weight: 0.8","            ))","        }","        ","        \/\/ Related terms","        for related in expansions.related {","            expandedTerms.append(ExpandedTerm(","                text: related,","                type: .related,","                weight: 0.6","            ))","        }","        ","        \/\/ Broader\/narrower terms","        for broader in expansions.broader {","            expandedTerms.append(ExpandedTerm(","                text: broader,","                type: .broader,","                weight: 0.5","            ))","        }","        ","        for narrower in expansions.narrower {","            expandedTerms.append(ExpandedTerm(","                text: narrower,","                type: .narrower,","                weight: 0.7","            ))","        }","        ","        return ExpandedQuery(","            original: query,","            expandedTerms: expandedTerms,","            strategy: .synonym","        )","    }","    ","    \/\/ Conceptual expansion using knowledge graphs","    func conceptualExpansion(query: String, domain: String? = nil) async throws -> ExpandedQuery {","        let systemPrompt = \"\"\"","        You are a knowledge graph expert. For the given query, identify:","        1. Core concepts and their relationships","        2. Domain-specific terminology (if domain is specified)","        3. Hierarchical relationships (parent\/child concepts)","        4. Associated attributes and properties","        ","        Return a structured JSON response.","        \"\"\"","        ","        let userPrompt = domain != nil ","            ? \"Query: \\(query)\\nDomain: \\(domain!)\"","            : \"Query: \\(query)\"","        ","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(systemPrompt),","                .user(userPrompt)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let concepts = try parseConceptualExpansion(response.choices.first?.message.content ?? \"\")","        ","        \/\/ Build expanded query with concept relationships","        var expandedTerms: [ExpandedTerm] = [","            ExpandedTerm(text: query, type: .original, weight: 1.0)","        ]","        ","        \/\/ Add core concepts","        for concept in concepts.coreConcepts {","            expandedTerms.append(ExpandedTerm(","                text: concept.name,","                type: .concept,","                weight: concept.relevance","            ))","        }","        ","        \/\/ Add related concepts with relationship weights","        for relation in concepts.relationships {","            let weight = calculateRelationshipWeight(relation.type)","            expandedTerms.append(ExpandedTerm(","                text: relation.targetConcept,","                type: .related,","                weight: weight,","                relationship: relation.type","            ))","        }","        ","        return ExpandedQuery(","            original: query,","            expandedTerms: expandedTerms,","            strategy: .conceptual,","            conceptGraph: concepts","        )","    }","    ","    \/\/ Query reformulation using user context","    func contextualReformulation(","        query: String,","        userContext: UserContext,","        searchHistory: [SearchHistoryItem]","    ) async throws -> ExpandedQuery {","        \/\/ Analyze recent search patterns","        let recentQueries = searchHistory","            .prefix(10)","            .map { $0.query }","        ","        let recentClicks = searchHistory","            .flatMap { $0.clickedResults }","            .prefix(20)","        ","        \/\/ Generate contextual expansion","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"\"\"","                Based on the user's search history and context, reformulate and expand the query.","                Consider:","                - User's expertise level: \\(userContext.expertiseLevel)","                - Previous searches: \\(recentQueries.joined(separator: \", \"))","                - Domain preferences: \\(userContext.domainPreferences.joined(separator: \", \"))","                ","                Provide expansions that match the user's intent and knowledge level.","                \"\"\"),","                .user(\"Current query: \\(query)\")","            ]","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let reformulations = try parseReformulations(response.choices.first?.message.content ?? \"\")","        ","        \/\/ Weight expansions based on user behavior","        var expandedTerms: [ExpandedTerm] = []","        ","        for reformulation in reformulations {","            let weight = calculateUserContextWeight(","                reformulation: reformulation,","                userContext: userContext,","                clickHistory: recentClicks","            )","            ","            expandedTerms.append(ExpandedTerm(","                text: reformulation.text,","                type: reformulation.type,","                weight: weight,","                userContextMatch: reformulation.contextMatch","            ))","        }","        ","        return ExpandedQuery(","            original: query,","            expandedTerms: expandedTerms,","            strategy: .contextual,","            userContext: userContext","        )","    }","    ","    \/\/ Multi-lingual query expansion","    func multilingualExpansion(","        query: String,","        targetLanguages: [String],","        preserveIntent: Bool = true","    ) async throws -> MultilingualExpandedQuery {","        var translations: [LanguageTranslation] = []","        ","        for language in targetLanguages {","            let request = ChatCompletionRequest(","                model: .gpt4turbo,","                messages: [","                    .system(\"\"\"","                    Translate the search query to \\(language) while preserving search intent.","                    Also provide:","                    - Cultural adaptations if needed","                    - Domain-specific terminology in target language","                    - Common variations in that language","                    \"\"\"),","                    .user(query)","                ],","                responseFormat: .jsonObject","            )","            ","            let response = try await openAI.chat.completions.create(request)","            let translation = try parseTranslation(response.choices.first?.message.content ?? \"\")","            ","            translations.append(LanguageTranslation(","                language: language,","                query: translation.main,","                variations: translation.variations,","                culturalAdaptations: translation.culturalAdaptations","            ))","        }","        ","        \/\/ Generate unified embeddings across languages","        let crossLingualEmbeddings = try await generateCrossLingualEmbeddings(","            original: query,","            translations: translations","        )","        ","        return MultilingualExpandedQuery(","            original: query,","            originalLanguage: \"en\",","            translations: translations,","            crossLingualEmbeddings: crossLingualEmbeddings","        )","    }","    ","    \/\/ Hybrid expansion combining multiple techniques","    func hybridExpansion(","        query: String,","        config: ExpansionConfig = .default","    ) async throws -> HybridExpandedQuery {","        \/\/ Run multiple expansion strategies in parallel","        async let synonyms = synonymExpansion(query: query)","        async let concepts = conceptualExpansion(query: query, domain: config.domain)","        ","        \/\/ Combine results intelligently","        let (synonymResult, conceptResult) = try await (synonyms, concepts)","        ","        \/\/ Deduplicate and merge expansions","        var mergedTerms: [String: ExpandedTerm] = [:]","        var termRelationships: [TermRelationship] = []","        ","        \/\/ Process synonym expansions","        for term in synonymResult.expandedTerms {","            mergedTerms[term.text.lowercased()] = term","        }","        ","        \/\/ Process conceptual expansions","        for term in conceptResult.expandedTerms {","            let key = term.text.lowercased()","            if let existing = mergedTerms[key] {","                \/\/ Merge weights using configured strategy","                mergedTerms[key] = mergeExpandedTerms(existing, term, strategy: config.mergeStrategy)","            } else {","                mergedTerms[key] = term","            }","        }","        ","        \/\/ Identify term relationships","        if let conceptGraph = conceptResult.conceptGraph {","            termRelationships = extractTermRelationships(from: conceptGraph)","        }","        ","        \/\/ Apply query intent analysis","        let intent = try await analyzeQueryIntent(query: query)","        ","        \/\/ Adjust weights based on intent","        let adjustedTerms = adjustTermWeights(","            terms: Array(mergedTerms.values),","            intent: intent,","            config: config","        )","        ","        return HybridExpandedQuery(","            original: query,","            expandedTerms: adjustedTerms,","            termRelationships: termRelationships,","            queryIntent: intent,","            expansionStrategies: [.synonym, .conceptual]","        )","    }","    ","    \/\/ Advanced reranking with expanded queries","    func expandAndRerank(","        query: String,","        candidates: [SearchResult],","        expansionStrategy: ExpansionStrategy","    ) async throws -> [RankedResult] {","        \/\/ Expand query","        let expandedQuery = try await hybridExpansion(query: query)","        ","        \/\/ Generate embeddings for all expanded terms","        var termEmbeddings: [String: [Float]] = [:]","        ","        for term in expandedQuery.expandedTerms {","            let embedding = try await generateEmbedding(for: term.text)","            termEmbeddings[term.text] = embedding","        }","        ","        \/\/ Score each candidate against expanded query","        var rankedResults: [RankedResult] = []","        ","        for candidate in candidates {","            var totalScore: Float = 0.0","            var termScores: [String: Float] = [:]","            ","            \/\/ Score against each expanded term","            for term in expandedQuery.expandedTerms {","                if let termEmbedding = termEmbeddings[term.text] {","                    let similarity = cosineSimilarity(","                        termEmbedding,","                        candidate.embedding","                    )","                    ","                    let weightedScore = similarity * term.weight","                    termScores[term.text] = weightedScore","                    totalScore += weightedScore","                }","            }","            ","            \/\/ Apply relationship bonus","            let relationshipBonus = calculateRelationshipBonus(","                candidate: candidate,","                relationships: expandedQuery.termRelationships","            )","            ","            totalScore += relationshipBonus","            ","            rankedResults.append(RankedResult(","                result: candidate,","                score: totalScore,","                termScores: termScores,","                expansionContribution: totalScore - candidate.baseScore","            ))","        }","        ","        \/\/ Sort by score","        return rankedResults.sorted { $0.score > $1.score }","    }","    ","    \/\/ Helper functions","    private func parseExpansions(_ json: String) throws -> QueryExpansions {","        \/\/ Parse JSON response","        QueryExpansions(","            synonyms: [],","            related: [],","            broader: [],","            narrower: []","        )","    }","    ","    private func calculateRelationshipWeight(_ type: RelationType) -> Float {","        switch type {","        case .synonym: return 0.9","        case .hyponym: return 0.7","        case .hypernym: return 0.6","        case .meronym: return 0.5","        case .holonym: return 0.5","        case .related: return 0.4","        }","    }","    ","    private func generateEmbedding(for text: String) async throws -> [Float] {","        let request = EmbeddingRequest(","            model: .textEmbedding3Large,","            input: .string(text)","        )","        ","        let response = try await openAI.embeddings.create(request)","        return response.data.first?.embedding ?? []","    }","    ","    private func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","}","","\/\/ Data structures","struct ExpandedQuery {","    let original: String","    let expandedTerms: [ExpandedTerm]","    let strategy: ExpansionStrategy","    var conceptGraph: ConceptGraph?","    var userContext: UserContext?","}","","struct ExpandedTerm {","    let text: String","    let type: TermType","    let weight: Float","    var relationship: RelationType?","    var userContextMatch: Float?","}","","enum TermType {","    case original","    case synonym","    case related","    case broader","    case narrower","    case concept","    case contextual","}","","enum ExpansionStrategy {","    case synonym","    case conceptual","    case contextual","    case multilingual","    case hybrid","}","","struct QueryExpansions {","    let synonyms: [String]","    let related: [String]","    let broader: [String]","    let narrower: [String]","}","","struct ConceptGraph {","    let coreConcepts: [Concept]","    let relationships: [ConceptRelationship]","}","","struct Concept {","    let name: String","    let relevance: Float","    let attributes: [String]","}","","struct ConceptRelationship {","    let sourceConcept: String","    let targetConcept: String","    let type: RelationType","}","","enum RelationType {","    case synonym","    case hyponym","    case hypernym","    case meronym","    case holonym","    case related","}","","struct UserContext {","    let expertiseLevel: ExpertiseLevel","    let domainPreferences: [String]","    let searchHistory: [String]","}","","enum ExpertiseLevel {","    case beginner","    case intermediate","    case expert","}","","struct SearchHistoryItem {","    let query: String","    let timestamp: Date","    let clickedResults: [String]","}","","struct MultilingualExpandedQuery {","    let original: String","    let originalLanguage: String","    let translations: [LanguageTranslation]","    let crossLingualEmbeddings: [String: [Float]]","}","","struct LanguageTranslation {","    let language: String","    let query: String","    let variations: [String]","    let culturalAdaptations: [String]","}","","struct HybridExpandedQuery {","    let original: String","    let expandedTerms: [ExpandedTerm]","    let termRelationships: [TermRelationship]","    let queryIntent: QueryIntent","    let expansionStrategies: [ExpansionStrategy]","}","","struct TermRelationship {","    let term1: String","    let term2: String","    let relationship: RelationType","    let strength: Float","}","","struct QueryIntent {","    let type: IntentType","    let confidence: Float","    let entities: [String]","}","","enum IntentType {","    case informational","    case navigational","    case transactional","    case research","}","","struct ExpansionConfig {","    let domain: String?","    let mergeStrategy: MergeStrategy","    let maxTerms: Int","    let minWeight: Float","    ","    static let `default` = ExpansionConfig(","        domain: nil,","        mergeStrategy: .weighted,","        maxTerms: 20,","        minWeight: 0.3","    )","}","","enum MergeStrategy {","    case weighted","    case maximum","    case average","}","","struct SearchResult {","    let id: String","    let content: String","    let embedding: [Float]","    let baseScore: Float","}","","struct RankedResult {","    let result: SearchResult","    let score: Float","    let termScores: [String: Float]","    let expansionContribution: Float","}","","\/\/ Usage example","func demonstrateQueryExpansion() async throws {","    let openAI = OpenAI(apiKey: \"your-api-key\")","    let expander = QueryExpander(openAI: openAI)","    ","    \/\/ Example 1: Synonym expansion","    let synonymExpanded = try await expander.synonymExpansion(","        query: \"machine learning algorithms\"","    )","    print(\"Synonym expansion: \\(synonymExpanded.expandedTerms.count) terms\")","    ","    \/\/ Example 2: Conceptual expansion with domain","    let conceptExpanded = try await expander.conceptualExpansion(","        query: \"neural networks\",","        domain: \"deep learning\"","    )","    print(\"Conceptual expansion: \\(conceptExpanded.expandedTerms.count) terms\")","    ","    \/\/ Example 3: Contextual reformulation","    let userContext = UserContext(","        expertiseLevel: .intermediate,","        domainPreferences: [\"AI\", \"data science\"],","        searchHistory: [\"pytorch tutorials\", \"transformer models\"]","    )","    ","    let contextualExpanded = try await expander.contextualReformulation(","        query: \"attention mechanism\",","        userContext: userContext,","        searchHistory: []","    )","    print(\"Contextual expansion: \\(contextualExpanded.expandedTerms.count) terms\")","    ","    \/\/ Example 4: Hybrid expansion","    let hybridExpanded = try await expander.hybridExpansion(","        query: \"natural language processing\",","        config: ExpansionConfig(","            domain: \"AI\",","            mergeStrategy: .weighted,","            maxTerms: 30,","            minWeight: 0.4","        )","    )","    print(\"Hybrid expansion: \\(hybridExpanded.expandedTerms.count) terms\")","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit#Install-OpenAIKit":{"title":"Install OpenAIKit","abstract":[{"text":"Configure OpenAIKit in your Swift project and authenticate with the OpenAI API.","type":"text"}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Install-OpenAIKit","url":"\/tutorials\/openaikit\/01-setting-up-openaikit#Install-OpenAIKit"},"doc://OpenAIKit/tutorials/OpenAIKit-Tutorials":{"title":"Welcome to OpenAIKit","abstract":[{"type":"text","text":"Learn how to integrate OpenAI’s powerful AI models into your Swift applications with OpenAIKit."}],"role":"overview","kind":"overview","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials","url":"\/tutorials\/openaikit-tutorials"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Implementing-Conversation-Memory":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Implementing-Conversation-Memory","type":"section","role":"pseudoSymbol","title":"Implementing Conversation Memory","abstract":[{"type":"text","text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions."}],"url":"\/tutorials\/openaikit\/05-building-conversations#Implementing-Conversation-Memory","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Security-and-Privacy-Considerations":{"title":"Security and Privacy Considerations","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Security-and-Privacy-Considerations","url":"\/tutorials\/openaikit\/09-deep-research-analysis#Security-and-Privacy-Considerations"},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion#Create-a-Simple-Chat-Request":{"title":"Create a Simple Chat Request","abstract":[{"type":"text","text":"Make your first API call to generate text using OpenAI’s chat completion models."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Create-a-Simple-Chat-Request","url":"\/tutorials\/openaikit\/02-your-first-chat-completion#Create-a-Simple-Chat-Request"},"doc://OpenAIKit/tutorials/OpenAIKit-Tutorials/Getting-Started":{"type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Getting-Started","role":"article","title":"Getting Started","abstract":[],"url":"\/tutorials\/openaikit-tutorials\/getting-started","kind":"article"},"app-02-interface.swift":{"syntax":"swift","highlights":[{"line":4},{"line":5},{"line":8},{"line":13},{"line":16},{"line":17},{"line":18},{"line":19},{"line":21},{"line":22},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":62},{"line":63},{"line":64},{"line":65},{"line":67},{"line":68},{"line":69},{"line":70},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":138},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":154},{"line":155},{"line":156},{"line":158},{"line":159},{"line":162},{"line":163},{"line":164},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":188},{"line":189},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":246},{"line":247},{"line":248},{"line":250},{"line":251},{"line":253},{"line":254},{"line":255},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280}],"fileName":"KnowledgeBaseApp.swift","fileType":"swift","type":"file","identifier":"app-02-interface.swift","content":["import OpenAIKit","import Foundation","","\/\/ Search interface implementation","class SemanticSearchInterface {","    let openAI: OpenAI","    let vectorStore: VectorStore","    let queryProcessor: QueryProcessor","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.vectorStore = VectorStore()","        self.queryProcessor = QueryProcessor(openAI: openAI)","    }","    ","    \/\/ Main search function","    func search(query: String, filters: SearchFilters? = nil) async throws -> SearchResponse {","        \/\/ Process and enhance query","        let processedQuery = try await queryProcessor.process(query)","        ","        \/\/ Generate embedding for search query","        let queryEmbedding = try await generateEmbedding(for: processedQuery.enhancedQuery)","        ","        \/\/ Search vector store","        var results = try await vectorStore.search(","            embedding: queryEmbedding,","            limit: filters?.limit ?? 10","        )","        ","        \/\/ Apply filters","        if let filters = filters {","            results = applyFilters(results, filters: filters)","        }","        ","        \/\/ Re-rank results using LLM","        let rerankedResults = try await rerankResults(","            query: processedQuery.enhancedQuery,","            results: results","        )","        ","        \/\/ Generate search response","        return SearchResponse(","            query: query,","            processedQuery: processedQuery,","            results: rerankedResults,","            totalResults: rerankedResults.count,","            searchTime: Date()","        )","    }","    ","    \/\/ Generate embedding for text","    private func generateEmbedding(for text: String) async throws -> [Double] {","        let request = CreateEmbeddingRequest(","            model: .textEmbeddingAda002,","            input: .text(text)","        )","        ","        let response = try await openAI.embeddings.create(request)","        return response.data.first?.embedding ?? []","    }","    ","    \/\/ Apply search filters","    private func applyFilters(_ results: [SearchResult], filters: SearchFilters) -> [SearchResult] {","        return results.filter { result in","            let metadata = result.document.metadata","            ","            \/\/ Category filter","            if let category = filters.category,","               metadata.category != category {","                return false","            }","            ","            \/\/ Author filter","            if let author = filters.author,","               !metadata.author.lowercased().contains(author.lowercased()) {","                return false","            }","            ","            \/\/ Tags filter","            if let tags = filters.tags,","               Set(metadata.tags).intersection(tags).isEmpty {","                return false","            }","            ","            \/\/ Score threshold","            if let minScore = filters.minScore,","               result.score < minScore {","                return false","            }","            ","            return true","        }","    }","    ","    \/\/ Re-rank results using LLM","    private func rerankResults(query: String, results: [SearchResult]) async throws -> [RankedSearchResult] {","        guard !results.isEmpty else { return [] }","        ","        \/\/ Create re-ranking prompt","        let prompt = \"\"\"","        Query: \"\\(query)\"","        ","        Please rank the following search results from most to least relevant.","        Consider both semantic similarity and practical usefulness.","        ","        Results:","        \\(results.enumerated().map { index, result in","            \"\\(index + 1). \\(result.document.metadata.title)\\n   \\(result.document.content.prefix(200))...\"","        }.joined(separator: \"\\n\\n\"))","        ","        Return a JSON array of indices in order of relevance.","        \"\"\"","        ","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"You are a search result ranking expert.\"),","                .user(prompt)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse ranking and create ranked results","        var rankedResults: [RankedSearchResult] = []","        ","        \/\/ For simplicity, use original order with enhanced scoring","        for (index, result) in results.enumerated() {","            rankedResults.append(RankedSearchResult(","                searchResult: result,","                rank: index + 1,","                relevanceScore: result.score * (1.0 - Double(index) * 0.05),","                explanation: generateExplanation(query: query, result: result)","            ))","        }","        ","        return rankedResults","    }","    ","    \/\/ Generate relevance explanation","    private func generateExplanation(query: String, result: SearchResult) -> String {","        \/\/ Simple explanation based on score","        if result.score > 0.9 {","            return \"Highly relevant - strong semantic match\"","        } else if result.score > 0.7 {","            return \"Good match - relevant content\"","        } else {","            return \"Partial match - some relevant information\"","        }","    }","}","","\/\/ Query processor for enhancing search queries","class QueryProcessor {","    let openAI: OpenAI","    ","    init(openAI: OpenAI) {","        self.openAI = openAI","    }","    ","    func process(_ query: String) async throws -> ProcessedQuery {","        \/\/ Expand query with synonyms and related terms","        let expandedQuery = try await expandQuery(query)","        ","        \/\/ Extract intent and entities","        let intent = try await extractIntent(query)","        ","        return ProcessedQuery(","            originalQuery: query,","            enhancedQuery: expandedQuery,","            intent: intent,","            keywords: extractKeywords(query)","        )","    }","    ","    private func expandQuery(_ query: String) async throws -> String {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Expand the search query with relevant synonyms and related terms.\"),","                .user(\"Query: \\(query)\\nExpanded query:\")","            ],","            temperature: 0.3,","            maxTokens: 100","        )","        ","        let response = try await openAI.chat.completions.create(request)","        return response.choices.first?.message.content ?? query","    }","    ","    private func extractIntent(_ query: String) async throws -> SearchIntent {","        \/\/ Simple intent classification","        if query.lowercased().contains(\"how\") || query.lowercased().contains(\"what\") {","            return .informational","        } else if query.lowercased().contains(\"find\") || query.lowercased().contains(\"locate\") {","            return .navigational","        } else {","            return .exploratory","        }","    }","    ","    private func extractKeywords(_ query: String) -> [String] {","        \/\/ Simple keyword extraction","        let stopWords = Set([\"the\", \"is\", \"at\", \"which\", \"on\", \"a\", \"an\", \"and\", \"or\", \"but\"])","        return query.lowercased()","            .components(separatedBy: .whitespacesAndNewlines)","            .filter { !stopWords.contains($0) && $0.count > 2 }","    }","}","","\/\/ Search models","struct SearchFilters {","    let category: String?","    let author: String?","    let tags: Set<String>?","    let minScore: Double?","    let limit: Int","}","","struct ProcessedQuery {","    let originalQuery: String","    let enhancedQuery: String","    let intent: SearchIntent","    let keywords: [String]","}","","enum SearchIntent {","    case informational","    case navigational","    case exploratory","}","","struct SearchResponse {","    let query: String","    let processedQuery: ProcessedQuery","    let results: [RankedSearchResult]","    let totalResults: Int","    let searchTime: Date","}","","struct RankedSearchResult {","    let searchResult: SearchResult","    let rank: Int","    let relevanceScore: Double","    let explanation: String","}","","\/\/ Usage example","func demonstrateSearch() async throws {","    let searchInterface = SemanticSearchInterface(apiKey: \"your-api-key\")","    ","    \/\/ Simple search","    let response = try await searchInterface.search(","        query: \"machine learning algorithms\"","    )","    ","    print(\"Search Results for: \\(response.query)\")","    print(\"Enhanced Query: \\(response.processedQuery.enhancedQuery)\")","    print(\"\\nResults:\")","    ","    for result in response.results {","        print(\"\\n\\(result.rank). \\(result.searchResult.document.metadata.title)\")","        print(\"   Score: \\(result.relevanceScore)\")","        print(\"   \\(result.explanation)\")","    }","    ","    \/\/ Search with filters","    let filteredResponse = try await searchInterface.search(","        query: \"neural networks\",","        filters: SearchFilters(","            category: \"Technology\",","            author: nil,","            tags: Set([\"AI\", \"Deep Learning\"]),","            minScore: 0.7,","            limit: 5","        )","    )","    ","    print(\"\\n\\nFiltered Search Results: \\(filteredResponse.totalResults) results\")","}"]},"advanced-03-finetune.swift":{"fileName":"AdvancedEmbeddings.swift","fileType":"swift","identifier":"advanced-03-finetune.swift","highlights":[{"line":4},{"line":6},{"line":8},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":18},{"line":19},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":27},{"line":28},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":89},{"line":90},{"line":91},{"line":92},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":108},{"line":109},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":131},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":159},{"line":160},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":217},{"line":219},{"line":220},{"line":221},{"line":225},{"line":227},{"line":228},{"line":229},{"line":230},{"line":232},{"line":233},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":246},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":253},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":280},{"line":281},{"line":282},{"line":283},{"line":285},{"line":286},{"line":287},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":306},{"line":307},{"line":308},{"line":309},{"line":310},{"line":311},{"line":314},{"line":317},{"line":318},{"line":319},{"line":321},{"line":322},{"line":323},{"line":324},{"line":325},{"line":327},{"line":328},{"line":329},{"line":331},{"line":332},{"line":333},{"line":335},{"line":336},{"line":339},{"line":342},{"line":343},{"line":344},{"line":345},{"line":346},{"line":348},{"line":349},{"line":350},{"line":351},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":364},{"line":379},{"line":380},{"line":381},{"line":382},{"line":383},{"line":386},{"line":387},{"line":388},{"line":389},{"line":390},{"line":391},{"line":392},{"line":395},{"line":396},{"line":397},{"line":398},{"line":401},{"line":402},{"line":403},{"line":404},{"line":407},{"line":408},{"line":409},{"line":410},{"line":413},{"line":414},{"line":415},{"line":416},{"line":417},{"line":420},{"line":421},{"line":422},{"line":423},{"line":424},{"line":425},{"line":426},{"line":427},{"line":428},{"line":429},{"line":430},{"line":431},{"line":432},{"line":433},{"line":434},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":444},{"line":445},{"line":446},{"line":447},{"line":448},{"line":449},{"line":452},{"line":453},{"line":454},{"line":455},{"line":458},{"line":459},{"line":460},{"line":461},{"line":464},{"line":465},{"line":466},{"line":467},{"line":470},{"line":471},{"line":472},{"line":473},{"line":474},{"line":475},{"line":476},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":482},{"line":483},{"line":485},{"line":486},{"line":487},{"line":491},{"line":492},{"line":493},{"line":494},{"line":497},{"line":498},{"line":499},{"line":500},{"line":501},{"line":504},{"line":505},{"line":506},{"line":509},{"line":510},{"line":511},{"line":512},{"line":515},{"line":516},{"line":517},{"line":518},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":524},{"line":525},{"line":526},{"line":527},{"line":528},{"line":529},{"line":530},{"line":531},{"line":532},{"line":536},{"line":537},{"line":540},{"line":541},{"line":542},{"line":543},{"line":545},{"line":546},{"line":547},{"line":548},{"line":551},{"line":552},{"line":553},{"line":554},{"line":555},{"line":556},{"line":557},{"line":558},{"line":559},{"line":562},{"line":563},{"line":564},{"line":565},{"line":566},{"line":567},{"line":568},{"line":569},{"line":570},{"line":573},{"line":574},{"line":575},{"line":576},{"line":577},{"line":578},{"line":579},{"line":580},{"line":581},{"line":584},{"line":585},{"line":586},{"line":587},{"line":588},{"line":589},{"line":590},{"line":591},{"line":592},{"line":593},{"line":594},{"line":595},{"line":596},{"line":597},{"line":598},{"line":599},{"line":600},{"line":601},{"line":602},{"line":603},{"line":604},{"line":605},{"line":606},{"line":607},{"line":608},{"line":609},{"line":610},{"line":611},{"line":612},{"line":613},{"line":614},{"line":615},{"line":617},{"line":620},{"line":621},{"line":622},{"line":623},{"line":624},{"line":625},{"line":628},{"line":629},{"line":630},{"line":633},{"line":634},{"line":635},{"line":636},{"line":637},{"line":638},{"line":639},{"line":640},{"line":641},{"line":644},{"line":646},{"line":647},{"line":648},{"line":649},{"line":650},{"line":651},{"line":653},{"line":654},{"line":655},{"line":656},{"line":657},{"line":658},{"line":659},{"line":660},{"line":661},{"line":662},{"line":663},{"line":664},{"line":665},{"line":667},{"line":668}],"content":["import OpenAIKit","import Foundation","","\/\/ Fine-tuning embeddings for domain-specific semantic search","","struct DomainSpecificSearch {","    let openAI: OpenAI","    let domain: SearchDomain","    ","    \/\/ Generate domain-specific embeddings with fine-tuning","    func generateDomainEmbedding(","        text: String,","        context: DomainContext? = nil","    ) async throws -> DomainEmbedding {","        \/\/ Preprocess text with domain knowledge","        let processedText = preprocessForDomain(text: text, domain: domain)","        ","        \/\/ Add domain-specific prompt engineering","        let domainPrompt = createDomainPrompt(text: processedText, context: context)","        ","        \/\/ Generate base embedding","        let embeddingRequest = EmbeddingRequest(","            model: .textEmbedding3Large,","            input: .string(domainPrompt)","        )","        ","        let response = try await openAI.embeddings.create(embeddingRequest)","        let baseEmbedding = response.data.first?.embedding ?? []","        ","        \/\/ Apply domain-specific transformations","        let transformedEmbedding = try await applyDomainTransformation(","            embedding: baseEmbedding,","            domain: domain,","            context: context","        )","        ","        return DomainEmbedding(","            vector: transformedEmbedding,","            domain: domain,","            metadata: DomainMetadata(","                originalText: text,","                processedText: processedText,","                domainFeatures: extractDomainFeatures(text, domain)","            )","        )","    }","    ","    \/\/ Create domain-specific fine-tuning dataset","    func createFineTuningDataset(","        documents: [DomainDocument],","        relevanceLabels: [RelevanceLabel]","    ) async throws -> FineTuningDataset {","        var trainingExamples: [FineTuningExample] = []","        ","        for document in documents {","            \/\/ Extract domain-specific features","            let features = extractDomainFeatures(document.content, domain)","            ","            \/\/ Generate positive examples from relevance labels","            let positiveExamples = relevanceLabels","                .filter { $0.documentId == document.id && $0.relevance > 0.7 }","                .map { label in","                    FineTuningExample(","                        query: label.query,","                        document: document.content,","                        relevance: label.relevance,","                        domainFeatures: features,","                        type: .positive","                    )","                }","            ","            \/\/ Generate negative examples","            let negativeExamples = try await generateNegativeExamples(","                document: document,","                positiveQueries: positiveExamples.map { $0.query },","                count: positiveExamples.count","            )","            ","            trainingExamples.append(contentsOf: positiveExamples)","            trainingExamples.append(contentsOf: negativeExamples)","        }","        ","        \/\/ Add domain-specific augmentations","        let augmentedExamples = try await augmentTrainingData(","            examples: trainingExamples,","            domain: domain","        )","        ","        return FineTuningDataset(","            examples: augmentedExamples,","            domain: domain,","            validationSplit: 0.2","        )","    }","    ","    \/\/ Domain-specific similarity scoring","    func domainSimilarity(","        queryEmbedding: DomainEmbedding,","        documentEmbedding: DomainEmbedding,","        boostFactors: DomainBoostFactors? = nil","    ) -> DomainSimilarityScore {","        \/\/ Base cosine similarity","        let baseSimilarity = cosineSimilarity(","            queryEmbedding.vector,","            documentEmbedding.vector","        )","        ","        \/\/ Domain-specific adjustments","        var adjustedScore = baseSimilarity","        ","        \/\/ Apply terminology matching boost","        if let queryTerms = queryEmbedding.metadata.domainFeatures.terminology,","           let docTerms = documentEmbedding.metadata.domainFeatures.terminology {","            let termOverlap = calculateTermOverlap(queryTerms, docTerms)","            adjustedScore += termOverlap * (boostFactors?.terminologyBoost ?? 0.1)","        }","        ","        \/\/ Apply entity matching boost","        if let queryEntities = queryEmbedding.metadata.domainFeatures.entities,","           let docEntities = documentEmbedding.metadata.domainFeatures.entities {","            let entityMatch = calculateEntityMatch(queryEntities, docEntities)","            adjustedScore += entityMatch * (boostFactors?.entityBoost ?? 0.15)","        }","        ","        \/\/ Apply domain-specific rules","        let ruleAdjustment = applyDomainRules(","            query: queryEmbedding,","            document: documentEmbedding,","            domain: domain","        )","        adjustedScore += ruleAdjustment","        ","        return DomainSimilarityScore(","            baseScore: baseSimilarity,","            adjustedScore: min(adjustedScore, 1.0),","            components: SimilarityComponents(","                semantic: baseSimilarity,","                terminology: termOverlap ?? 0,","                entity: entityMatch ?? 0,","                domainRules: ruleAdjustment","            )","        )","    }","    ","    \/\/ Adaptive learning from user feedback","    func adaptFromFeedback(","        feedback: [UserFeedback],","        currentModel: DomainSearchModel","    ) async throws -> DomainSearchModel {","        \/\/ Analyze feedback patterns","        let feedbackAnalysis = analyzeFeedbackPatterns(feedback)","        ","        \/\/ Identify areas for improvement","        let improvements = identifyImprovements(","            analysis: feedbackAnalysis,","            currentPerformance: currentModel.performance","        )","        ","        \/\/ Generate additional training data from feedback","        var additionalExamples: [FineTuningExample] = []","        ","        for item in feedback {","            if item.type == .relevant {","                \/\/ Create positive example","                additionalExamples.append(FineTuningExample(","                    query: item.query,","                    document: item.document,","                    relevance: item.rating,","                    domainFeatures: extractDomainFeatures(item.document, domain),","                    type: .positive","                ))","            } else if item.type == .irrelevant {","                \/\/ Create negative example","                additionalExamples.append(FineTuningExample(","                    query: item.query,","                    document: item.document,","                    relevance: 1.0 - item.rating,","                    domainFeatures: extractDomainFeatures(item.document, domain),","                    type: .negative","                ))","            }","        }","        ","        \/\/ Update model weights","        let updatedWeights = try await updateModelWeights(","            currentWeights: currentModel.weights,","            newExamples: additionalExamples,","            learningRate: calculateAdaptiveLearningRate(feedbackAnalysis)","        )","        ","        \/\/ Update domain rules based on feedback","        let updatedRules = updateDomainRules(","            currentRules: currentModel.domainRules,","            feedbackPatterns: feedbackAnalysis.patterns","        )","        ","        return DomainSearchModel(","            weights: updatedWeights,","            domainRules: updatedRules,","            performance: evaluateModelPerformance(updatedWeights, feedback),","            version: currentModel.version + 1","        )","    }","    ","    \/\/ Domain-specific query understanding","    func understandDomainQuery(query: String) async throws -> DomainQueryUnderstanding {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"\"\"","                You are a \\(domain.name) domain expert. Analyze the search query and identify:","                1. Domain-specific intent","                2. Technical terminology","                3. Implicit requirements","                4. Related concepts in the domain","                ","                Return a structured JSON response.","                \"\"\"),","                .user(query)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let understanding = try parseDomainUnderstanding(response.choices.first?.message.content ?? \"\")","        ","        \/\/ Enhance with domain knowledge base","        let enhancedUnderstanding = enhanceWithKnowledgeBase(","            understanding: understanding,","            domain: domain","        )","        ","        return enhancedUnderstanding","    }","    ","    \/\/ Custom scoring functions for different domains","    func createDomainScorer() -> DomainScorer {","        switch domain.type {","        case .medical:","            return MedicalDomainScorer(","                prioritizeEvidence: true,","                boostClinicalTerms: true,","                requireSourceCredibility: true","            )","            ","        case .legal:","            return LegalDomainScorer(","                prioritizePrecedent: true,","                boostJurisdiction: true,","                requireCitation: true","            )","            ","        case .technical:","            return TechnicalDomainScorer(","                prioritizeRecency: true,","                boostCodeExamples: true,","                requireAccuracy: true","            )","            ","        case .academic:","            return AcademicDomainScorer(","                prioritizePeerReview: true,","                boostCitations: true,","                requireMethodology: true","            )","            ","        default:","            return DefaultDomainScorer()","        }","    }","    ","    \/\/ Evaluate domain-specific search quality","    func evaluateSearchQuality(","        results: [SearchResult],","        groundTruth: [GroundTruthItem],","        metrics: Set<QualityMetric> = .default","    ) -> DomainSearchEvaluation {","        var evaluation = DomainSearchEvaluation()","        ","        \/\/ Precision and recall","        if metrics.contains(.precision) {","            evaluation.precision = calculatePrecision(results, groundTruth)","        }","        ","        if metrics.contains(.recall) {","            evaluation.recall = calculateRecall(results, groundTruth)","        }","        ","        \/\/ Domain-specific metrics","        if metrics.contains(.domainAccuracy) {","            evaluation.domainAccuracy = calculateDomainAccuracy(","                results: results,","                groundTruth: groundTruth,","                domain: domain","            )","        }","        ","        \/\/ Terminology coverage","        if metrics.contains(.terminologyCoverage) {","            evaluation.terminologyCoverage = calculateTerminologyCoverage(","                results: results,","                expectedTerms: domain.coreTerminology","            )","        }","        ","        \/\/ Expert rating simulation","        if metrics.contains(.expertRating) {","            evaluation.expertRating = simulateExpertRating(","                results: results,","                domain: domain","            )","        }","        ","        return evaluation","    }","    ","    \/\/ Helper functions","    private func preprocessForDomain(text: String, domain: SearchDomain) -> String {","        var processed = text","        ","        \/\/ Domain-specific preprocessing","        switch domain.type {","        case .medical:","            processed = expandMedicalAbbreviations(processed)","            processed = normalizeMedicalTerms(processed)","            ","        case .legal:","            processed = expandLegalCitations(processed)","            processed = normalizeLegalTerms(processed)","            ","        case .technical:","            processed = expandTechnicalAcronyms(processed)","            processed = normalizeCodeReferences(processed)","            ","        default:","            break","        }","        ","        return processed","    }","    ","    private func createDomainPrompt(text: String, context: DomainContext?) -> String {","        var prompt = \"Domain: \\(domain.name)\\n\"","        ","        if let context = context {","            prompt += \"Context: \\(context.description)\\n\"","        }","        ","        prompt += \"Text: \\(text)\"","        ","        return prompt","    }","    ","    private func applyDomainTransformation(","        embedding: [Float],","        domain: SearchDomain,","        context: DomainContext?","    ) async throws -> [Float] {","        \/\/ Apply learned transformation matrix","        if let transform = domain.embeddingTransform {","            return matrixMultiply(embedding, transform)","        }","        ","        return embedding","    }","    ","    private func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","}","","\/\/ Data structures","struct SearchDomain {","    let name: String","    let type: DomainType","    let coreTerminology: Set<String>","    let embeddingTransform: [[Float]]?","}","","enum DomainType {","    case medical","    case legal","    case technical","    case academic","    case financial","    case general","}","","struct DomainContext {","    let description: String","    let entities: [String]","    let constraints: [String]","}","","struct DomainEmbedding {","    let vector: [Float]","    let domain: SearchDomain","    let metadata: DomainMetadata","}","","struct DomainMetadata {","    let originalText: String","    let processedText: String","    let domainFeatures: DomainFeatures","}","","struct DomainFeatures {","    let terminology: Set<String>?","    let entities: [DomainEntity]?","    let concepts: [String]?","    let relationships: [FeatureRelationship]?","}","","struct DomainEntity {","    let text: String","    let type: String","    let confidence: Float","}","","struct FeatureRelationship {","    let source: String","    let target: String","    let type: String","}","","struct DomainDocument {","    let id: String","    let content: String","    let metadata: [String: Any]","}","","struct RelevanceLabel {","    let documentId: String","    let query: String","    let relevance: Float","}","","struct FineTuningExample {","    let query: String","    let document: String","    let relevance: Float","    let domainFeatures: DomainFeatures","    let type: ExampleType","}","","enum ExampleType {","    case positive","    case negative","    case augmented","}","","struct FineTuningDataset {","    let examples: [FineTuningExample]","    let domain: SearchDomain","    let validationSplit: Float","}","","struct DomainBoostFactors {","    let terminologyBoost: Float","    let entityBoost: Float","    let conceptBoost: Float","}","","struct DomainSimilarityScore {","    let baseScore: Float","    let adjustedScore: Float","    let components: SimilarityComponents","}","","struct SimilarityComponents {","    let semantic: Float","    let terminology: Float","    let entity: Float","    let domainRules: Float","}","","struct UserFeedback {","    let query: String","    let document: String","    let type: FeedbackType","    let rating: Float","    let timestamp: Date","}","","enum FeedbackType {","    case relevant","    case irrelevant","    case partial","}","","struct DomainSearchModel {","    let weights: ModelWeights","    let domainRules: [DomainRule]","    let performance: ModelPerformance","    let version: Int","}","","struct ModelWeights {","    let embeddingWeights: [[Float]]","    let scoringWeights: [String: Float]","}","","struct DomainRule {","    let condition: String","    let action: String","    let weight: Float","}","","struct ModelPerformance {","    let accuracy: Float","    let precision: Float","    let recall: Float","    let domainSpecificScore: Float","}","","struct DomainQueryUnderstanding {","    let intent: DomainIntent","    let entities: [DomainEntity]","    let terminology: [String]","    let implicitRequirements: [String]","    let relatedConcepts: [String]","}","","struct DomainIntent {","    let primary: String","    let secondary: [String]","    let confidence: Float","}","","protocol DomainScorer {","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float","}","","struct MedicalDomainScorer: DomainScorer {","    let prioritizeEvidence: Bool","    let boostClinicalTerms: Bool","    let requireSourceCredibility: Bool","    ","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float {","        \/\/ Medical-specific scoring logic","        0.0","    }","}","","struct LegalDomainScorer: DomainScorer {","    let prioritizePrecedent: Bool","    let boostJurisdiction: Bool","    let requireCitation: Bool","    ","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float {","        \/\/ Legal-specific scoring logic","        0.0","    }","}","","struct TechnicalDomainScorer: DomainScorer {","    let prioritizeRecency: Bool","    let boostCodeExamples: Bool","    let requireAccuracy: Bool","    ","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float {","        \/\/ Technical-specific scoring logic","        0.0","    }","}","","struct AcademicDomainScorer: DomainScorer {","    let prioritizePeerReview: Bool","    let boostCitations: Bool","    let requireMethodology: Bool","    ","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float {","        \/\/ Academic-specific scoring logic","        0.0","    }","}","","struct DefaultDomainScorer: DomainScorer {","    func score(query: DomainEmbedding, document: DomainEmbedding) -> Float {","        \/\/ Default scoring logic","        0.0","    }","}","","struct GroundTruthItem {","    let query: String","    let relevantDocuments: Set<String>","}","","enum QualityMetric {","    case precision","    case recall","    case domainAccuracy","    case terminologyCoverage","    case expertRating","    ","    static let `default`: Set<QualityMetric> = [","        .precision, .recall, .domainAccuracy","    ]","}","","struct DomainSearchEvaluation {","    var precision: Float?","    var recall: Float?","    var domainAccuracy: Float?","    var terminologyCoverage: Float?","    var expertRating: Float?","}","","\/\/ Usage example","func demonstrateDomainSpecificSearch() async throws {","    let openAI = OpenAI(apiKey: \"your-api-key\")","    ","    \/\/ Create medical domain search","    let medicalDomain = SearchDomain(","        name: \"Medical\",","        type: .medical,","        coreTerminology: [\"diagnosis\", \"symptom\", \"treatment\", \"medication\"],","        embeddingTransform: nil","    )","    ","    let medicalSearch = DomainSpecificSearch(","        openAI: openAI,","        domain: medicalDomain","    )","    ","    \/\/ Generate domain-specific embedding","    let query = \"patient presenting with acute chest pain and shortness of breath\"","    let embedding = try await medicalSearch.generateDomainEmbedding(","        text: query,","        context: DomainContext(","            description: \"Emergency medicine\",","            entities: [\"chest pain\", \"dyspnea\"],","            constraints: [\"urgent care required\"]","        )","    )","    ","    print(\"Domain embedding generated with \\(embedding.vector.count) dimensions\")","    ","    \/\/ Create fine-tuning dataset","    let documents = [","        DomainDocument(","            id: \"1\",","            content: \"Acute coronary syndrome presents with chest pain...\",","            metadata: [\"category\": \"cardiology\"]","        )","    ]","    ","    let labels = [","        RelevanceLabel(","            documentId: \"1\",","            query: \"chest pain differential diagnosis\",","            relevance: 0.9","        )","    ]","    ","    let dataset = try await medicalSearch.createFineTuningDataset(","        documents: documents,","        relevanceLabels: labels","    )","    ","    print(\"Fine-tuning dataset created with \\(dataset.examples.count) examples\")","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion#Check-Your-Understanding":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Check-Your-Understanding","titleInlineContent":[{"type":"text","text":"Check Your Understanding"}],"url":"\/tutorials\/openaikit\/02-your-first-chat-completion#Check-Your-Understanding","title":"Check Your Understanding","type":"link"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Understanding-Embeddings":{"title":"Understanding Embeddings","abstract":[{"text":"Create intelligent search systems using embeddings to find semantically similar content.","type":"text"}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Understanding-Embeddings","url":"\/tutorials\/openaikit\/09-building-semantic-search#Understanding-Embeddings"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio":{"title":"Transcribing Audio","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"role":"project","kind":"project","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio","url":"\/tutorials\/openaikit\/08-transcribing-audio","estimatedTime":"12min"},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Understanding-Streaming":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Understanding-Streaming","type":"section","role":"pseudoSymbol","title":"Understanding Streaming","abstract":[{"type":"text","text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated."}],"url":"\/tutorials\/openaikit\/06-streaming-responses#Understanding-Streaming","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Advanced-Function-Patterns":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Advanced-Function-Patterns","role":"pseudoSymbol","title":"Advanced Function Patterns","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"url":"\/tutorials\/openaikit\/03-working-with-functions#Advanced-Function-Patterns","kind":"section"},"database-03-storage.swift":{"syntax":"swift","highlights":[{"line":2},{"line":4},{"line":6},{"line":7},{"line":9},{"line":10},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":18},{"line":19},{"line":22},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":51},{"line":52},{"line":53},{"line":56},{"line":57},{"line":58},{"line":61},{"line":64},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":82},{"line":83},{"line":84},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":97},{"line":98},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":133},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":247},{"line":248},{"line":249},{"line":250},{"line":251},{"line":252},{"line":254},{"line":255},{"line":256},{"line":258},{"line":259},{"line":260},{"line":261},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":284},{"line":285},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":318},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":325},{"line":326},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":334},{"line":336},{"line":337},{"line":338},{"line":339},{"line":340},{"line":341},{"line":342},{"line":343},{"line":344},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":366},{"line":367},{"line":370},{"line":372},{"line":373},{"line":374},{"line":375},{"line":376},{"line":377},{"line":378},{"line":379},{"line":381},{"line":382},{"line":385},{"line":386},{"line":387},{"line":388},{"line":389},{"line":390},{"line":391},{"line":392},{"line":393},{"line":394},{"line":395},{"line":396},{"line":397},{"line":398},{"line":401},{"line":402},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":408},{"line":409},{"line":410},{"line":411},{"line":412},{"line":416},{"line":417},{"line":418},{"line":419},{"line":420},{"line":421},{"line":422},{"line":424},{"line":425},{"line":426},{"line":429},{"line":430},{"line":431},{"line":432},{"line":433},{"line":434},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":444},{"line":445},{"line":447},{"line":448},{"line":450},{"line":451},{"line":452},{"line":453},{"line":454},{"line":455},{"line":456},{"line":458},{"line":459},{"line":460},{"line":461},{"line":462},{"line":463},{"line":464},{"line":465},{"line":466},{"line":467},{"line":471},{"line":472},{"line":473},{"line":474},{"line":475},{"line":476},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":482},{"line":483},{"line":484},{"line":485},{"line":486},{"line":487}],"fileName":"VectorDatabase.swift","fileType":"swift","type":"file","identifier":"database-03-storage.swift","content":["import Foundation","import Compression","","\/\/ MARK: - Efficient Vector Storage","","\/\/\/ Optimized storage for vector embeddings with compression","class VectorStorage {","    private let dimension: Int","    private let compressionAlgorithm: NSData.CompressionAlgorithm","    private let quantizationBits: Int?","    ","    init(","        dimension: Int,","        compressionAlgorithm: NSData.CompressionAlgorithm = .lzfse,","        quantizationBits: Int? = nil","    ) {","        self.dimension = dimension","        self.compressionAlgorithm = compressionAlgorithm","        self.quantizationBits = quantizationBits","    }","    ","    \/\/ MARK: - Vector Compression","    ","    func compress(embedding: [Float]) throws -> Data {","        var processedEmbedding = embedding","        ","        \/\/ Apply quantization if specified","        if let bits = quantizationBits {","            processedEmbedding = quantize(embedding: embedding, bits: bits)","        }","        ","        \/\/ Convert to data","        let data = processedEmbedding.withUnsafeBytes { bytes in","            Data(bytes)","        }","        ","        \/\/ Apply compression","        guard let compressed = (data as NSData).compressed(using: compressionAlgorithm) else {","            throw StorageError.compressionFailed","        }","        ","        return compressed as Data","    }","    ","    func decompress(data: Data) throws -> [Float] {","        \/\/ Decompress data","        guard let decompressed = (data as NSData).decompressed(using: compressionAlgorithm) else {","            throw StorageError.decompressionFailed","        }","        ","        \/\/ Convert back to float array","        let floatArray = decompressed.withUnsafeBytes { bytes in","            Array(bytes.bindMemory(to: Float.self))","        }","        ","        \/\/ Apply dequantization if needed","        if let bits = quantizationBits {","            return dequantize(embedding: floatArray, bits: bits)","        }","        ","        return floatArray","    }","    ","    \/\/ MARK: - Quantization","    ","    private func quantize(embedding: [Float], bits: Int) -> [Float] {","        let levels = Float(1 << bits)","        ","        \/\/ Find min and max values","        let minVal = embedding.min() ?? 0","        let maxVal = embedding.max() ?? 1","        let range = maxVal - minVal","        ","        \/\/ Quantize each value","        return embedding.map { value in","            let normalized = (value - minVal) \/ range","            let quantized = round(normalized * (levels - 1))","            return quantized \/ (levels - 1) * range + minVal","        }","    }","    ","    private func dequantize(embedding: [Float], bits: Int) -> [Float] {","        \/\/ In this simplified version, dequantization is already done during decompression","        return embedding","    }","}","","\/\/ MARK: - Storage Manager","","\/\/\/ Manages efficient storage of vector documents","class VectorStorageManager {","    private let storage: VectorStorage","    private let fileManager = FileManager.default","    private let baseURL: URL","    private let queue = DispatchQueue(label: \"vectordb.storage\", attributes: .concurrent)","    ","    \/\/ Metadata cache for fast lookups","    private var metadataCache: [String: DocumentMetadata] = [:]","    ","    struct DocumentMetadata: Codable {","        let id: String","        let dimension: Int","        let compressed: Bool","        let compressionRatio: Float?","        let createdAt: Date","        let fileOffset: Int64","        let fileSize: Int64","        let checksum: String","    }","    ","    init(","        baseURL: URL,","        dimension: Int,","        enableCompression: Bool = true","    ) throws {","        self.baseURL = baseURL","        self.storage = VectorStorage(","            dimension: dimension,","            compressionAlgorithm: enableCompression ? .lzfse : .none,","            quantizationBits: enableCompression ? 8 : nil","        )","        ","        \/\/ Create storage directory if needed","        try fileManager.createDirectory(","            at: baseURL,","            withIntermediateDirectories: true","        )","        ","        \/\/ Load metadata cache","        loadMetadataCache()","    }","    ","    \/\/ MARK: - Storage Operations","    ","    func store(document: VectorDocument) async throws -> DocumentMetadata {","        try await withCheckedThrowingContinuation { continuation in","            queue.async(flags: .barrier) {","                do {","                    \/\/ Compress embedding","                    let originalSize = document.embedding.count * MemoryLayout<Float>.size","                    let compressedData = try self.storage.compress(embedding: document.embedding)","                    let compressionRatio = Float(originalSize) \/ Float(compressedData.count)","                    ","                    \/\/ Create document package","                    let package = DocumentPackage(","                        id: document.id,","                        content: document.content,","                        embedding: compressedData,","                        metadata: document.metadataDict,","                        source: document.source,","                        collection: document.collectionName","                    )","                    ","                    \/\/ Write to file","                    let fileURL = self.documentURL(for: document.id)","                    let packageData = try JSONEncoder().encode(package)","                    try packageData.write(to: fileURL)","                    ","                    \/\/ Create metadata","                    let metadata = DocumentMetadata(","                        id: document.id,","                        dimension: Int(document.dimension),","                        compressed: true,","                        compressionRatio: compressionRatio,","                        createdAt: document.createdAt,","                        fileOffset: 0,","                        fileSize: Int64(packageData.count),","                        checksum: self.calculateChecksum(for: packageData)","                    )","                    ","                    \/\/ Update cache","                    self.metadataCache[document.id] = metadata","                    self.saveMetadataCache()","                    ","                    continuation.resume(returning: metadata)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func retrieve(id: String) async throws -> StoredDocument? {","        try await withCheckedThrowingContinuation { continuation in","            queue.async {","                do {","                    guard let metadata = self.metadataCache[id] else {","                        continuation.resume(returning: nil)","                        return","                    }","                    ","                    \/\/ Read document package","                    let fileURL = self.documentURL(for: id)","                    let packageData = try Data(contentsOf: fileURL)","                    ","                    \/\/ Verify checksum","                    let checksum = self.calculateChecksum(for: packageData)","                    guard checksum == metadata.checksum else {","                        throw StorageError.checksumMismatch","                    }","                    ","                    \/\/ Decode package","                    let package = try JSONDecoder().decode(","                        DocumentPackage.self,","                        from: packageData","                    )","                    ","                    \/\/ Decompress embedding","                    let embedding = try self.storage.decompress(data: package.embedding)","                    ","                    let document = StoredDocument(","                        id: package.id,","                        content: package.content,","                        embedding: embedding,","                        metadata: package.metadata,","                        source: package.source,","                        collection: package.collection,","                        storageMetadata: metadata","                    )","                    ","                    continuation.resume(returning: document)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func delete(id: String) async throws {","        try await withCheckedThrowingContinuation { continuation in","            queue.async(flags: .barrier) {","                do {","                    let fileURL = self.documentURL(for: id)","                    try self.fileManager.removeItem(at: fileURL)","                    ","                    self.metadataCache.removeValue(forKey: id)","                    self.saveMetadataCache()","                    ","                    continuation.resume()","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    \/\/ MARK: - Batch Operations","    ","    func storeBatch(documents: [VectorDocument]) async throws -> [DocumentMetadata] {","        \/\/ Process in parallel batches for efficiency","        let batchSize = 10","        var allMetadata: [DocumentMetadata] = []","        ","        for batchStart in stride(from: 0, to: documents.count, by: batchSize) {","            let batchEnd = min(batchStart + batchSize, documents.count)","            let batch = Array(documents[batchStart..<batchEnd])","            ","            let batchMetadata = try await withThrowingTaskGroup(of: DocumentMetadata.self) { group in","                for document in batch {","                    group.addTask {","                        try await self.store(document: document)","                    }","                }","                ","                var metadata: [DocumentMetadata] = []","                for try await result in group {","                    metadata.append(result)","                }","                return metadata","            }","            ","            allMetadata.append(contentsOf: batchMetadata)","        }","        ","        return allMetadata","    }","    ","    \/\/ MARK: - Storage Statistics","    ","    func getStorageStatistics() async -> StorageStatistics {","        await withCheckedContinuation { continuation in","            queue.async {","                var totalSize: Int64 = 0","                var totalDocuments = 0","                var averageCompressionRatio: Float = 0","                ","                for metadata in self.metadataCache.values {","                    totalSize += metadata.fileSize","                    totalDocuments += 1","                    if let ratio = metadata.compressionRatio {","                        averageCompressionRatio += ratio","                    }","                }","                ","                if totalDocuments > 0 {","                    averageCompressionRatio \/= Float(totalDocuments)","                }","                ","                let stats = StorageStatistics(","                    totalDocuments: totalDocuments,","                    totalSizeBytes: totalSize,","                    averageCompressionRatio: averageCompressionRatio,","                    storageEfficiency: self.calculateStorageEfficiency()","                )","                ","                continuation.resume(returning: stats)","            }","        }","    }","    ","    \/\/ MARK: - Private Methods","    ","    private func documentURL(for id: String) -> URL {","        \/\/ Use subdirectories to avoid too many files in one directory","        let prefix = String(id.prefix(2))","        let directory = baseURL.appendingPathComponent(prefix)","        ","        try? fileManager.createDirectory(","            at: directory,","            withIntermediateDirectories: true","        )","        ","        return directory.appendingPathComponent(\"\\(id).vdoc\")","    }","    ","    private func calculateChecksum(for data: Data) -> String {","        \/\/ Simple checksum using CRC32","        var crc: UInt32 = 0","        data.withUnsafeBytes { bytes in","            for byte in bytes {","                crc = (crc >> 8) ^ crcTable[Int((crc ^ UInt32(byte)) & 0xFF)]","            }","        }","        return String(format: \"%08X\", crc)","    }","    ","    private func loadMetadataCache() {","        let cacheURL = baseURL.appendingPathComponent(\"metadata.cache\")","        ","        guard let data = try? Data(contentsOf: cacheURL),","              let cache = try? JSONDecoder().decode(","                [String: DocumentMetadata].self,","                from: data","              ) else {","            return","        }","        ","        metadataCache = cache","    }","    ","    private func saveMetadataCache() {","        let cacheURL = baseURL.appendingPathComponent(\"metadata.cache\")","        ","        guard let data = try? JSONEncoder().encode(metadataCache) else {","            return","        }","        ","        try? data.write(to: cacheURL)","    }","    ","    private func calculateStorageEfficiency() -> Float {","        \/\/ Calculate how efficiently we're using disk space","        let optimalSize = Float(metadataCache.count * dimension * MemoryLayout<Float>.size)","        let actualSize = metadataCache.values.reduce(0) { $0 + Float($1.fileSize) }","        ","        return actualSize > 0 ? optimalSize \/ actualSize : 0","    }","}","","\/\/ MARK: - Models","","struct DocumentPackage: Codable {","    let id: String","    let content: String","    let embedding: Data  \/\/ Compressed","    let metadata: [String: Any]?","    let source: String?","    let collection: String","    ","    enum CodingKeys: String, CodingKey {","        case id, content, embedding, source, collection","        case metadata","    }","    ","    init(","        id: String,","        content: String,","        embedding: Data,","        metadata: [String: Any]?,","        source: String?,","        collection: String","    ) {","        self.id = id","        self.content = content","        self.embedding = embedding","        self.metadata = metadata","        self.source = source","        self.collection = collection","    }","    ","    init(from decoder: Decoder) throws {","        let container = try decoder.container(keyedBy: CodingKeys.self)","        id = try container.decode(String.self, forKey: .id)","        content = try container.decode(String.self, forKey: .content)","        embedding = try container.decode(Data.self, forKey: .embedding)","        source = try container.decodeIfPresent(String.self, forKey: .source)","        collection = try container.decode(String.self, forKey: .collection)","        ","        if let metadataData = try container.decodeIfPresent(Data.self, forKey: .metadata) {","            metadata = try JSONSerialization.jsonObject(with: metadataData) as? [String: Any]","        } else {","            metadata = nil","        }","    }","    ","    func encode(to encoder: Encoder) throws {","        var container = encoder.container(keyedBy: CodingKeys.self)","        try container.encode(id, forKey: .id)","        try container.encode(content, forKey: .content)","        try container.encode(embedding, forKey: .embedding)","        try container.encodeIfPresent(source, forKey: .source)","        try container.encode(collection, forKey: .collection)","        ","        if let metadata = metadata {","            let metadataData = try JSONSerialization.data(withJSONObject: metadata)","            try container.encode(metadataData, forKey: .metadata)","        }","    }","}","","struct StoredDocument {","    let id: String","    let content: String","    let embedding: [Float]","    let metadata: [String: Any]?","    let source: String?","    let collection: String","    let storageMetadata: VectorStorageManager.DocumentMetadata","}","","struct StorageStatistics {","    let totalDocuments: Int","    let totalSizeBytes: Int64","    let averageCompressionRatio: Float","    let storageEfficiency: Float","    ","    var totalSizeMB: Double {","        Double(totalSizeBytes) \/ (1024 * 1024)","    }","}","","enum StorageError: LocalizedError {","    case compressionFailed","    case decompressionFailed","    case checksumMismatch","    case storageFull","    ","    var errorDescription: String? {","        switch self {","        case .compressionFailed:","            return \"Failed to compress vector data\"","        case .decompressionFailed:","            return \"Failed to decompress vector data\"","        case .checksumMismatch:","            return \"Data integrity check failed\"","        case .storageFull:","            return \"Storage capacity exceeded\"","        }","    }","}","","\/\/ CRC32 table for checksum calculation","private let crcTable: [UInt32] = {","    var table = [UInt32](repeating: 0, count: 256)","    for i in 0..<256 {","        var c = UInt32(i)","        for _ in 0..<8 {","            if c & 1 != 0 {","                c = 0xEDB88320 ^ (c >> 1)","            } else {","                c = c >> 1","            }","        }","        table[i] = c","    }","    return table","}()"]},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion#Understanding-Chat-Messages":{"title":"Understanding Chat Messages","abstract":[{"type":"text","text":"Make your first API call to generate text using OpenAI’s chat completion models."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Understanding-Chat-Messages","url":"\/tutorials\/openaikit\/02-your-first-chat-completion#Understanding-Chat-Messages"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Handling-Function-Calls":{"title":"Handling Function Calls","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Handling-Function-Calls","url":"\/tutorials\/openaikit\/03-working-with-functions#Handling-Function-Calls"},"app-06-categorize.swift":{"fileName":"KnowledgeBaseApp.swift","fileType":"swift","identifier":"app-06-categorize.swift","highlights":[{"line":4},{"line":5},{"line":7},{"line":8},{"line":12},{"line":13},{"line":16},{"line":17},{"line":18},{"line":19},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":27},{"line":28},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":72},{"line":73},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":88},{"line":89},{"line":90},{"line":91},{"line":93},{"line":94},{"line":96},{"line":97},{"line":99},{"line":100},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":162},{"line":163},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":183},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":239},{"line":242},{"line":243},{"line":244},{"line":245},{"line":247},{"line":249},{"line":250},{"line":251},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":262},{"line":263},{"line":264},{"line":266},{"line":267},{"line":268},{"line":269},{"line":273},{"line":274},{"line":275},{"line":277},{"line":278},{"line":279},{"line":280},{"line":283},{"line":284},{"line":285},{"line":286},{"line":287},{"line":291},{"line":293},{"line":294},{"line":296},{"line":297},{"line":298},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":308},{"line":309},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":325},{"line":326},{"line":327},{"line":333},{"line":335},{"line":336},{"line":337},{"line":338},{"line":343},{"line":344},{"line":345},{"line":346},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":358},{"line":359},{"line":361},{"line":362},{"line":364},{"line":365},{"line":366},{"line":367},{"line":368},{"line":372},{"line":373},{"line":374},{"line":376},{"line":377},{"line":378},{"line":380},{"line":381},{"line":384},{"line":385},{"line":386},{"line":389},{"line":390},{"line":391},{"line":392},{"line":395},{"line":396},{"line":397},{"line":398},{"line":399},{"line":402},{"line":403},{"line":405},{"line":406},{"line":407},{"line":408},{"line":409},{"line":410},{"line":411},{"line":412},{"line":413},{"line":414},{"line":415},{"line":416},{"line":417},{"line":420},{"line":421},{"line":422},{"line":423},{"line":424},{"line":425},{"line":427},{"line":428},{"line":429},{"line":432},{"line":433},{"line":434},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":444},{"line":445},{"line":452},{"line":453},{"line":454},{"line":455},{"line":456},{"line":461},{"line":463},{"line":464},{"line":466},{"line":467},{"line":468},{"line":471},{"line":472},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":482},{"line":483},{"line":484},{"line":485},{"line":486},{"line":487},{"line":488},{"line":489},{"line":490},{"line":491},{"line":492},{"line":493},{"line":494},{"line":495},{"line":496},{"line":499},{"line":500},{"line":501},{"line":502},{"line":503},{"line":504},{"line":505},{"line":506},{"line":507},{"line":508},{"line":509},{"line":510},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":517},{"line":518},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":524},{"line":525},{"line":526},{"line":530},{"line":532},{"line":533},{"line":534},{"line":535},{"line":538},{"line":539},{"line":540},{"line":541},{"line":542},{"line":543},{"line":544},{"line":547},{"line":548},{"line":549},{"line":550},{"line":551},{"line":552},{"line":555},{"line":556},{"line":557},{"line":560},{"line":561},{"line":562},{"line":563},{"line":564},{"line":567},{"line":568},{"line":569},{"line":570},{"line":571},{"line":572},{"line":573},{"line":576},{"line":577},{"line":578},{"line":579},{"line":582},{"line":583},{"line":584},{"line":585},{"line":588},{"line":589},{"line":590},{"line":591},{"line":594},{"line":595},{"line":596},{"line":597},{"line":600},{"line":601},{"line":602},{"line":603},{"line":606},{"line":607},{"line":608},{"line":609},{"line":612},{"line":613},{"line":614},{"line":615},{"line":616},{"line":619},{"line":620},{"line":621},{"line":622},{"line":623},{"line":624},{"line":625},{"line":626},{"line":627},{"line":628},{"line":629},{"line":630},{"line":631},{"line":632},{"line":633},{"line":634},{"line":635},{"line":636},{"line":637},{"line":638},{"line":639},{"line":640},{"line":641},{"line":642},{"line":643},{"line":644},{"line":645},{"line":646},{"line":647},{"line":648},{"line":650},{"line":651},{"line":653},{"line":654},{"line":655},{"line":656},{"line":657},{"line":658},{"line":659},{"line":660},{"line":661},{"line":662},{"line":663},{"line":664},{"line":665},{"line":666},{"line":667},{"line":670},{"line":672},{"line":673},{"line":674},{"line":675},{"line":676},{"line":677},{"line":679},{"line":680},{"line":681},{"line":682},{"line":683},{"line":686},{"line":687},{"line":688},{"line":689},{"line":690},{"line":691},{"line":692},{"line":693},{"line":694},{"line":697},{"line":698},{"line":699},{"line":700},{"line":701},{"line":702}],"content":["import OpenAIKit","import Foundation","","\/\/ Automatic categorization system","class AutomaticCategorizer {","    let openAI: OpenAI","    let categoryHierarchy: CategoryHierarchy","    let classificationEngine: ClassificationEngine","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.categoryHierarchy = CategoryHierarchy()","        self.classificationEngine = ClassificationEngine(openAI: openAI)","    }","    ","    \/\/ Categorize a document","    func categorize(_ document: Document) async throws -> CategorizedDocument {","        \/\/ Extract features from document","        let features = try await extractFeatures(from: document)","        ","        \/\/ Classify using multiple strategies","        let classifications = try await performClassifications(","            document: document,","            features: features","        )","        ","        \/\/ Determine final categories with confidence scores","        let finalCategories = mergeCategorizations(classifications)","        ","        \/\/ Generate category explanation","        let explanation = try await generateCategoryExplanation(","            document: document,","            categories: finalCategories","        )","        ","        \/\/ Suggest new categories if needed","        let suggestedCategories = try await suggestNewCategories(","            document: document,","            existingCategories: finalCategories","        )","        ","        return CategorizedDocument(","            document: document,","            primaryCategory: finalCategories.first ?? Category.uncategorized,","            categories: finalCategories,","            explanation: explanation,","            suggestedCategories: suggestedCategories,","            metadata: CategorizationMetadata(","                confidence: calculateConfidence(finalCategories),","                method: .hybrid,","                timestamp: Date()","            )","        )","    }","    ","    \/\/ Batch categorization with learning","    func categorizeBatch(_ documents: [Document]) async throws -> BatchCategorizationResult {","        var categorizedDocs: [CategorizedDocument] = []","        var categoryDistribution: [String: Int] = [:]","        ","        \/\/ Categorize each document","        for document in documents {","            let categorized = try await categorize(document)","            categorizedDocs.append(categorized)","            ","            \/\/ Update distribution","            for category in categorized.categories {","                categoryDistribution[category.name, default: 0] += 1","            }","        }","        ","        \/\/ Learn from batch patterns","        let learningInsights = try await learnFromBatch(categorizedDocs)","        ","        \/\/ Update category hierarchy if needed","        if shouldUpdateHierarchy(learningInsights) {","            try await updateCategoryHierarchy(with: learningInsights)","        }","        ","        return BatchCategorizationResult(","            categorizedDocuments: categorizedDocs,","            categoryDistribution: categoryDistribution,","            learningInsights: learningInsights,","            hierarchyUpdated: shouldUpdateHierarchy(learningInsights)","        )","    }","    ","    \/\/ Extract features from document","    private func extractFeatures(from document: Document) async throws -> DocumentFeatures {","        \/\/ Extract keywords","        let keywords = try await extractKeywords(from: document.content)","        ","        \/\/ Extract entities","        let entities = try await extractEntities(from: document.content)","        ","        \/\/ Analyze structure","        let structure = analyzeStructure(document.content)","        ","        \/\/ Generate content embedding","        let embedding = try await generateEmbedding(for: document.content)","        ","        return DocumentFeatures(","            keywords: keywords,","            entities: entities,","            structure: structure,","            embedding: embedding,","            metadata: document.metadata","        )","    }","    ","    \/\/ Perform multiple classification strategies","    private func performClassifications(","        document: Document,","        features: DocumentFeatures","    ) async throws -> [Classification] {","        var classifications: [Classification] = []","        ","        \/\/ Rule-based classification","        let ruleBasedResult = classifyByRules(features: features)","        classifications.append(Classification(","            method: .ruleBased,","            categories: ruleBasedResult,","            confidence: 0.7","        ))","        ","        \/\/ Embedding-based classification","        let embeddingResult = try await classifyByEmbedding(","            embedding: features.embedding","        )","        classifications.append(Classification(","            method: .embedding,","            categories: embeddingResult,","            confidence: 0.85","        ))","        ","        \/\/ LLM-based classification","        let llmResult = try await classificationEngine.classifyWithLLM(","            document: document,","            availableCategories: categoryHierarchy.getAllCategories()","        )","        classifications.append(Classification(","            method: .llm,","            categories: llmResult,","            confidence: 0.9","        ))","        ","        return classifications","    }","    ","    \/\/ Extract keywords using LLM","    private func extractKeywords(from content: String) async throws -> [String] {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Extract 5-10 key terms that best represent the document's content.\"),","                .user(\"Document: \\(content.prefix(1000))...\\n\\nKey terms:\")","            ],","            temperature: 0.1,","            maxTokens: 100","        )","        ","        let response = try await openAI.chat.completions.create(request)","        let keywords = response.choices.first?.message.content ?? \"\"","        ","        return keywords","            .components(separatedBy: .newlines)","            .map { $0.trimmingCharacters(in: .whitespacesAndNewlines) }","            .filter { !$0.isEmpty }","    }","    ","    \/\/ Extract entities","    private func extractEntities(from content: String) async throws -> [Entity] {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Extract named entities (people, organizations, locations, technologies) from the text.\"),","                .user(\"Text: \\(content.prefix(1000))...\\n\\nFormat as JSON with entity type and name.\")","            ],","            temperature: 0.1,","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse entities (simplified)","        return [","            Entity(type: .technology, name: \"Machine Learning\"),","            Entity(type: .organization, name: \"OpenAI\")","        ]","    }","    ","    \/\/ Analyze document structure","    private func analyzeStructure(_ content: String) -> DocumentStructure {","        let paragraphs = content.components(separatedBy: \"\\n\\n\").count","        let sentences = content.components(separatedBy: \". \").count","        let avgSentenceLength = sentences > 0 ? content.count \/ sentences : 0","        ","        return DocumentStructure(","            paragraphCount: paragraphs,","            sentenceCount: sentences,","            avgSentenceLength: avgSentenceLength,","            hasHeaders: content.contains(\"\\n#\") || content.contains(\"\\n##\"),","            hasList: content.contains(\"\\n- \") || content.contains(\"\\n* \"),","            hasCode: content.contains(\"```\") || content.contains(\"    \")","        )","    }","    ","    \/\/ Generate embedding","    private func generateEmbedding(for text: String) async throws -> [Double] {","        let request = CreateEmbeddingRequest(","            model: .textEmbeddingAda002,","            input: .text(text.prefix(8000).description) \/\/ Limit for embedding model","        )","        ","        let response = try await openAI.embeddings.create(request)","        return response.data.first?.embedding ?? []","    }","    ","    \/\/ Rule-based classification","    private func classifyByRules(features: DocumentFeatures) -> [Category] {","        var categories: [Category] = []","        ","        \/\/ Technology rules","        let techKeywords = [\"AI\", \"machine learning\", \"algorithm\", \"data\", \"software\"]","        if features.keywords.contains(where: { keyword in","            techKeywords.contains { keyword.lowercased().contains($0.lowercased()) }","        }) {","            categories.append(categoryHierarchy.getCategory(named: \"Technology\") ?? Category.uncategorized)","        }","        ","        \/\/ Science rules","        let scienceKeywords = [\"research\", \"study\", \"experiment\", \"hypothesis\"]","        if features.keywords.contains(where: { keyword in","            scienceKeywords.contains { keyword.lowercased().contains($0.lowercased()) }","        }) {","            categories.append(categoryHierarchy.getCategory(named: \"Science\") ?? Category.uncategorized)","        }","        ","        return categories","    }","    ","    \/\/ Embedding-based classification","    private func classifyByEmbedding(embedding: [Double]) async throws -> [Category] {","        \/\/ Compare with category prototype embeddings","        let categoryEmbeddings = try await categoryHierarchy.getCategoryEmbeddings()","        ","        var similarities: [(Category, Double)] = []","        ","        for (category, categoryEmbedding) in categoryEmbeddings {","            let similarity = cosineSimilarity(embedding, categoryEmbedding)","            similarities.append((category, similarity))","        }","        ","        \/\/ Return top categories above threshold","        return similarities","            .filter { $0.1 > 0.7 }","            .sorted { $0.1 > $1.1 }","            .prefix(3)","            .map { $0.0 }","    }","    ","    \/\/ Merge categorizations from different methods","    private func mergeCategorizations(_ classifications: [Classification]) -> [Category] {","        var categoryScores: [String: Double] = [:]","        ","        for classification in classifications {","            let weight = classification.confidence","            for category in classification.categories {","                categoryScores[category.name, default: 0] += weight","            }","        }","        ","        \/\/ Normalize and sort","        let totalWeight = classifications.map { $0.confidence }.reduce(0, +)","        let normalizedScores = categoryScores.mapValues { $0 \/ totalWeight }","        ","        return normalizedScores","            .sorted { $0.value > $1.value }","            .prefix(3)","            .compactMap { categoryHierarchy.getCategory(named: $0.key) }","    }","    ","    \/\/ Generate category explanation","    private func generateCategoryExplanation(","        document: Document,","        categories: [Category]","    ) async throws -> String {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Explain why the document belongs to the given categories.\"),","                .user(\"\"\"","                Document title: \\(document.title)","                Categories: \\(categories.map { $0.name }.joined(separator: \", \"))","                ","                Content preview: \\(document.content.prefix(500))...","                ","                Provide a brief explanation for the categorization.","                \"\"\")","            ],","            temperature: 0.3,","            maxTokens: 150","        )","        ","        let response = try await openAI.chat.completions.create(request)","        return response.choices.first?.message.content ?? \"Categorized based on content analysis.\"","    }","    ","    \/\/ Suggest new categories","    private func suggestNewCategories(","        document: Document,","        existingCategories: [Category]","    ) async throws -> [SuggestedCategory] {","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Suggest new categories if the document doesn't fit well into existing ones.\"),","                .user(\"\"\"","                Document: \\(document.title)","                Content: \\(document.content.prefix(500))...","                ","                Existing categories: \\(existingCategories.map { $0.name }.joined(separator: \", \"))","                ","                Suggest new categories if needed. Format as JSON.","                \"\"\")","            ],","            temperature: 0.5,","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse suggestions (simplified)","        return [","            SuggestedCategory(","                name: \"Deep Learning\",","                parent: \"Machine Learning\",","                rationale: \"Document focuses specifically on deep neural networks\"","            )","        ]","    }","    ","    \/\/ Learn from batch patterns","    private func learnFromBatch(_ documents: [CategorizedDocument]) async throws -> LearningInsights {","        \/\/ Analyze category co-occurrences","        var coOccurrences: [String: [String: Int]] = [:]","        ","        for doc in documents {","            let categoryNames = doc.categories.map { $0.name }","            for i in 0..<categoryNames.count {","                for j in (i+1)..<categoryNames.count {","                    coOccurrences[categoryNames[i], default: [:]][categoryNames[j], default: 0] += 1","                    coOccurrences[categoryNames[j], default: [:]][categoryNames[i], default: 0] += 1","                }","            }","        }","        ","        \/\/ Find category patterns","        let patterns = findCategoryPatterns(coOccurrences: coOccurrences)","        ","        \/\/ Identify potential new categories","        let newCategorySuggestions = findNewCategorySuggestions(documents: documents)","        ","        return LearningInsights(","            categoryPatterns: patterns,","            suggestedNewCategories: newCategorySuggestions,","            accuracyMetrics: calculateAccuracyMetrics(documents),","            timestamp: Date()","        )","    }","    ","    \/\/ Helper functions","    private func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        guard magnitudeA > 0 && magnitudeB > 0 else { return 0 }","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","    ","    private func calculateConfidence(_ categories: [Category]) -> Double {","        \/\/ Simple confidence based on category count","        return categories.isEmpty ? 0 : 1.0 \/ Double(categories.count)","    }","    ","    private func shouldUpdateHierarchy(_ insights: LearningInsights) -> Bool {","        \/\/ Update if significant patterns found or new categories suggested","        return !insights.suggestedNewCategories.isEmpty ||","               insights.categoryPatterns.contains { $0.strength > 0.8 }","    }","    ","    private func updateCategoryHierarchy(with insights: LearningInsights) async throws {","        \/\/ Update hierarchy based on insights","        for suggestion in insights.suggestedNewCategories {","            categoryHierarchy.addCategory(suggestion.name, parent: suggestion.parent)","        }","    }","    ","    private func findCategoryPatterns(coOccurrences: [String: [String: Int]]) -> [CategoryPattern] {","        var patterns: [CategoryPattern] = []","        ","        for (category1, related) in coOccurrences {","            for (category2, count) in related {","                if count > 5 {","                    patterns.append(CategoryPattern(","                        categories: [category1, category2],","                        frequency: count,","                        strength: Double(count) \/ 10.0 \/\/ Simplified","                    ))","                }","            }","        }","        ","        return patterns","    }","    ","    private func findNewCategorySuggestions(documents: [CategorizedDocument]) -> [SuggestedCategory] {","        \/\/ Analyze documents with low confidence or suggested categories","        var suggestions: [SuggestedCategory] = []","        ","        for doc in documents {","            suggestions.append(contentsOf: doc.suggestedCategories)","        }","        ","        \/\/ Deduplicate and return","        return Array(Set(suggestions))","    }","    ","    private func calculateAccuracyMetrics(_ documents: [CategorizedDocument]) -> AccuracyMetrics {","        let avgConfidence = documents.map { $0.metadata.confidence }.reduce(0, +) \/ Double(documents.count)","        let multiCategoryRate = Double(documents.filter { $0.categories.count > 1 }.count) \/ Double(documents.count)","        ","        return AccuracyMetrics(","            averageConfidence: avgConfidence,","            multiCategoryRate: multiCategoryRate,","            uncategorizedRate: 0 \/\/ Simplified","        )","    }","}","","\/\/ Classification engine","class ClassificationEngine {","    let openAI: OpenAI","    ","    init(openAI: OpenAI) {","        self.openAI = openAI","    }","    ","    func classifyWithLLM(","        document: Document,","        availableCategories: [Category]","    ) async throws -> [Category] {","        let categoryList = availableCategories.map { $0.name }.joined(separator: \", \")","        ","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Classify the document into appropriate categories from the given list.\"),","                .user(\"\"\"","                Document: \\(document.title)","                Content: \\(document.content.prefix(1000))...","                ","                Available categories: \\(categoryList)","                ","                Select 1-3 most appropriate categories. Return as JSON array.","                \"\"\")","            ],","            temperature: 0.2,","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse and return categories (simplified)","        return availableCategories.prefix(2).map { $0 }","    }","}","","\/\/ Category hierarchy","class CategoryHierarchy {","    private var categories: [Category] = []","    private var embeddings: [String: [Double]] = [:]","    ","    init() {","        setupDefaultCategories()","    }","    ","    private func setupDefaultCategories() {","        categories = [","            Category(id: \"tech\", name: \"Technology\", parent: nil),","            Category(id: \"sci\", name: \"Science\", parent: nil),","            Category(id: \"ml\", name: \"Machine Learning\", parent: \"tech\"),","            Category(id: \"ai\", name: \"Artificial Intelligence\", parent: \"tech\")","        ]","    }","    ","    func getAllCategories() -> [Category] {","        return categories","    }","    ","    func getCategory(named name: String) -> Category? {","        return categories.first { $0.name == name }","    }","    ","    func addCategory(_ name: String, parent: String?) {","        let parentCategory = parent.flatMap { getCategory(named: $0) }","        let newCategory = Category(","            id: UUID().uuidString,","            name: name,","            parent: parentCategory?.id","        )","        categories.append(newCategory)","    }","    ","    func getCategoryEmbeddings() async throws -> [(Category, [Double])] {","        \/\/ Return pre-computed or generate embeddings for categories","        return categories.compactMap { category in","            if let embedding = embeddings[category.id] {","                return (category, embedding)","            }","            return nil","        }","    }","}","","\/\/ Models","struct Category: Hashable {","    let id: String","    let name: String","    let parent: String?","    ","    static let uncategorized = Category(id: \"uncat\", name: \"Uncategorized\", parent: nil)","}","","struct CategorizedDocument {","    let document: Document","    let primaryCategory: Category","    let categories: [Category]","    let explanation: String","    let suggestedCategories: [SuggestedCategory]","    let metadata: CategorizationMetadata","}","","struct DocumentFeatures {","    let keywords: [String]","    let entities: [Entity]","    let structure: DocumentStructure","    let embedding: [Double]","    let metadata: DocumentMetadata","}","","struct Entity {","    let type: EntityType","    let name: String","}","","enum EntityType {","    case person","    case organization","    case location","    case technology","}","","struct DocumentStructure {","    let paragraphCount: Int","    let sentenceCount: Int","    let avgSentenceLength: Int","    let hasHeaders: Bool","    let hasList: Bool","    let hasCode: Bool","}","","struct DocumentMetadata {","    let author: String","    let createdAt: Date","    let source: String?","}","","struct Classification {","    let method: ClassificationMethod","    let categories: [Category]","    let confidence: Double","}","","enum ClassificationMethod {","    case ruleBased","    case embedding","    case llm","}","","struct CategorizationMetadata {","    let confidence: Double","    let method: CategorizationMethod","    let timestamp: Date","}","","enum CategorizationMethod {","    case manual","    case automatic","    case hybrid","}","","struct SuggestedCategory: Hashable {","    let name: String","    let parent: String?","    let rationale: String","}","","struct BatchCategorizationResult {","    let categorizedDocuments: [CategorizedDocument]","    let categoryDistribution: [String: Int]","    let learningInsights: LearningInsights","    let hierarchyUpdated: Bool","}","","struct LearningInsights {","    let categoryPatterns: [CategoryPattern]","    let suggestedNewCategories: [SuggestedCategory]","    let accuracyMetrics: AccuracyMetrics","    let timestamp: Date","}","","struct CategoryPattern {","    let categories: [String]","    let frequency: Int","    let strength: Double","}","","struct AccuracyMetrics {","    let averageConfidence: Double","    let multiCategoryRate: Double","    let uncategorizedRate: Double","}","","\/\/ Document extension with metadata","extension Document {","    var metadata: DocumentMetadata {","        return DocumentMetadata(","            author: author,","            createdAt: createdAt,","            source: nil","        )","    }","}","","\/\/ Usage example","func demonstrateCategorization() async throws {","    let categorizer = AutomaticCategorizer(apiKey: \"your-api-key\")","    ","    \/\/ Single document categorization","    let document = Document(","        id: \"doc001\",","        title: \"Deep Learning for Natural Language Processing\",","        content: \"\"\"","        This comprehensive guide explores the application of deep learning ","        techniques to natural language processing tasks. We cover transformer ","        architectures, attention mechanisms, and pre-trained language models ","        like BERT and GPT. The tutorial includes practical examples using ","        PyTorch and demonstrates how to fine-tune models for specific NLP tasks.","        \"\"\",","        author: \"Dr. Sarah Johnson\",","        category: \"Technology\",","        tags: [\"AI\", \"NLP\", \"Deep Learning\"],","        createdAt: Date()","    )","    ","    let categorized = try await categorizer.categorize(document)","    ","    print(\"Document Categorization:\")","    print(\"Title: \\(categorized.document.title)\")","    print(\"Primary Category: \\(categorized.primaryCategory.name)\")","    print(\"All Categories: \\(categorized.categories.map { $0.name }.joined(separator: \", \"))\")","    print(\"Confidence: \\(String(format: \"%.2f\", categorized.metadata.confidence))\")","    print(\"Explanation: \\(categorized.explanation)\")","    ","    if !categorized.suggestedCategories.isEmpty {","        print(\"\\nSuggested New Categories:\")","        for suggestion in categorized.suggestedCategories {","            print(\"- \\(suggestion.name): \\(suggestion.rationale)\")","        }","    }","    ","    \/\/ Batch categorization","    let documents = [document] \/\/ Add more documents in real usage","    let batchResult = try await categorizer.categorizeBatch(documents)","    ","    print(\"\\n\\nBatch Categorization Results:\")","    print(\"Total Documents: \\(batchResult.categorizedDocuments.count)\")","    print(\"\\nCategory Distribution:\")","    for (category, count) in batchResult.categoryDistribution.sorted(by: { $0.value > $1.value }) {","        print(\"- \\(category): \\(count) documents\")","    }","    ","    print(\"\\nLearning Insights:\")","    print(\"Average Confidence: \\(String(format: \"%.2f\", batchResult.learningInsights.accuracyMetrics.averageConfidence))\")","    print(\"Multi-category Rate: \\(String(format: \"%.1f%%\", batchResult.learningInsights.accuracyMetrics.multiCategoryRate * 100))\")","    ","    if batchResult.hierarchyUpdated {","        print(\"\\nCategory hierarchy has been updated based on learning insights!\")","    }","}"],"type":"file","syntax":"swift"},"embeddings-01-empty.swift":{"syntax":"swift","highlights":[],"fileName":"EmbeddingGenerator.swift","fileType":"swift","type":"file","identifier":"embeddings-01-empty.swift","content":["\/\/ EmbeddingGenerator.swift"]},"engine-05-cache.swift":{"fileName":"SemanticSearchEngine.swift","fileType":"swift","identifier":"engine-05-cache.swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":11},{"line":12},{"line":13},{"line":14},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":40},{"line":41},{"line":42},{"line":45},{"line":46},{"line":47},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":112},{"line":113},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":125},{"line":126},{"line":127},{"line":129},{"line":130},{"line":131},{"line":132},{"line":135},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":204},{"line":205},{"line":206},{"line":207},{"line":212},{"line":213},{"line":214},{"line":215},{"line":218},{"line":219},{"line":220},{"line":221},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":246},{"line":247},{"line":248},{"line":249},{"line":252},{"line":253},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":271},{"line":272},{"line":279},{"line":281},{"line":282},{"line":283},{"line":284},{"line":287},{"line":288},{"line":289},{"line":290},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299}],"content":["import Foundation","import OpenAIKit","","extension SemanticSearchEngine {","    \/\/\/ Caching system for performance optimization","    class CacheManager {","        private var embeddingCache: LRUCache<String, [Double]>","        private var queryCache: LRUCache<String, [SearchResult]>","        private var ttlCache: TTLCache<String, Any>","        ","        init(maxSize: Int = 1000) {","            self.embeddingCache = LRUCache(maxSize: maxSize)","            self.queryCache = LRUCache(maxSize: maxSize \/ 2)","            self.ttlCache = TTLCache()","        }","        ","        \/\/\/ Cache embedding with content-based key","        func cacheEmbedding(for text: String, embedding: [Double]) {","            let key = generateCacheKey(text)","            embeddingCache.set(key, value: embedding)","        }","        ","        \/\/\/ Retrieve cached embedding","        func getCachedEmbedding(for text: String) -> [Double]? {","            let key = generateCacheKey(text)","            return embeddingCache.get(key)","        }","        ","        \/\/\/ Cache search results","        func cacheSearchResults(query: String, results: [SearchResult], ttl: TimeInterval = 300) {","            let key = generateCacheKey(query)","            queryCache.set(key, value: results)","            ttlCache.set(key, value: results, ttl: ttl)","        }","        ","        \/\/\/ Get cached search results","        func getCachedSearchResults(query: String) -> [SearchResult]? {","            let key = generateCacheKey(query)","            ","            \/\/ Check if TTL is still valid","            if ttlCache.get(key) != nil {","                return queryCache.get(key)","            }","            ","            \/\/ TTL expired, remove from query cache","            queryCache.remove(key)","            return nil","        }","        ","        \/\/\/ Generate cache key from text","        private func generateCacheKey(_ text: String) -> String {","            \/\/ Simple hash function for demo - use proper hashing in production","            let normalized = text.lowercased().trimmingCharacters(in: .whitespacesAndNewlines)","            return String(normalized.hashValue)","        }","        ","        \/\/\/ Clear all caches","        func clearAll() {","            embeddingCache.clear()","            queryCache.clear()","            ttlCache.clear()","        }","        ","        \/\/\/ Get cache statistics","        func getStats() -> CacheStats {","            CacheStats(","                embeddingCacheSize: embeddingCache.count,","                queryCacheSize: queryCache.count,","                ttlCacheSize: ttlCache.count,","                embeddingHitRate: embeddingCache.hitRate,","                queryHitRate: queryCache.hitRate","            )","        }","    }","    ","    \/\/\/ LRU (Least Recently Used) Cache implementation","    class LRUCache<Key: Hashable, Value> {","        private var cache: [Key: Node] = [:]","        private var head = Node()","        private var tail = Node()","        private let maxSize: Int","        private var currentSize = 0","        ","        private var hits = 0","        private var misses = 0","        ","        var count: Int { currentSize }","        var hitRate: Double {","            let total = hits + misses","            return total > 0 ? Double(hits) \/ Double(total) : 0","        }","        ","        private class Node {","            var key: Key?","            var value: Value?","            var prev: Node?","            var next: Node?","        }","        ","        init(maxSize: Int) {","            self.maxSize = maxSize","            head.next = tail","            tail.prev = head","        }","        ","        func get(_ key: Key) -> Value? {","            if let node = cache[key] {","                hits += 1","                moveToHead(node)","                return node.value","            }","            misses += 1","            return nil","        }","        ","        func set(_ key: Key, value: Value) {","            if let node = cache[key] {","                node.value = value","                moveToHead(node)","            } else {","                let newNode = Node()","                newNode.key = key","                newNode.value = value","                ","                cache[key] = newNode","                addToHead(newNode)","                currentSize += 1","                ","                if currentSize > maxSize {","                    if let tailNode = removeTail() {","                        cache.removeValue(forKey: tailNode.key!)","                        currentSize -= 1","                    }","                }","            }","        }","        ","        func remove(_ key: Key) {","            if let node = cache[key] {","                removeNode(node)","                cache.removeValue(forKey: key)","                currentSize -= 1","            }","        }","        ","        func clear() {","            cache.removeAll()","            head.next = tail","            tail.prev = head","            currentSize = 0","            hits = 0","            misses = 0","        }","        ","        private func addToHead(_ node: Node) {","            node.prev = head","            node.next = head.next","            head.next?.prev = node","            head.next = node","        }","        ","        private func removeNode(_ node: Node) {","            node.prev?.next = node.next","            node.next?.prev = node.prev","        }","        ","        private func moveToHead(_ node: Node) {","            removeNode(node)","            addToHead(node)","        }","        ","        private func removeTail() -> Node? {","            guard let node = tail.prev, node !== head else { return nil }","            removeNode(node)","            return node","        }","    }","    ","    \/\/\/ TTL (Time To Live) Cache","    class TTLCache<Key: Hashable, Value> {","        private var cache: [Key: (value: Value, expiry: Date)] = [:]","        private let queue = DispatchQueue(label: \"ttl-cache\", attributes: .concurrent)","        ","        var count: Int {","            queue.sync { cache.count }","        }","        ","        func set(_ key: Key, value: Value, ttl: TimeInterval) {","            let expiry = Date().addingTimeInterval(ttl)","            queue.async(flags: .barrier) {","                self.cache[key] = (value, expiry)","            }","            ","            \/\/ Schedule cleanup","            DispatchQueue.global().asyncAfter(deadline: .now() + ttl) { [weak self] in","                self?.removeIfExpired(key)","            }","        }","        ","        func get(_ key: Key) -> Value? {","            queue.sync {","                guard let item = cache[key] else { return nil }","                ","                if item.expiry > Date() {","                    return item.value","                } else {","                    return nil","                }","            }","        }","        ","        func clear() {","            queue.async(flags: .barrier) {","                self.cache.removeAll()","            }","        }","        ","        private func removeIfExpired(_ key: Key) {","            queue.async(flags: .barrier) {","                if let item = self.cache[key], item.expiry <= Date() {","                    self.cache.removeValue(forKey: key)","                }","            }","        }","    }","    ","    struct CacheStats {","        let embeddingCacheSize: Int","        let queryCacheSize: Int","        let ttlCacheSize: Int","        let embeddingHitRate: Double","        let queryHitRate: Double","    }","}","","\/\/ Extension to integrate caching with search engine","extension SemanticSearchEngine {","    \/\/\/ Search with caching enabled","    func searchWithCache(","        query: String,","        limit: Int = 10,","        useCache: Bool = true","    ) async throws -> [SearchResult] {","        let cacheManager = CacheManager()","        ","        \/\/ Check query cache first","        if useCache, let cachedResults = cacheManager.getCachedSearchResults(query: query) {","            print(\"Cache hit for query: \\(query)\")","            return cachedResults","        }","        ","        \/\/ Check embedding cache for query","        let queryEmbedding: [Double]","        if useCache, let cachedEmbedding = cacheManager.getCachedEmbedding(for: query) {","            print(\"Cache hit for query embedding\")","            queryEmbedding = cachedEmbedding","        } else {","            queryEmbedding = try await generateEmbedding(for: query)","            if useCache {","                cacheManager.cacheEmbedding(for: query, embedding: queryEmbedding)","            }","        }","        ","        \/\/ Perform search","        let results = try await search(query: query, limit: limit)","        ","        \/\/ Cache results","        if useCache {","            cacheManager.cacheSearchResults(query: query, results: results)","        }","        ","        return results","    }","}","","\/\/ Example usage","Task {","    let engine = SemanticSearchEngine(apiKey: \"your-api-key\")","    let cacheManager = SemanticSearchEngine.CacheManager(maxSize: 100)","    ","    \/\/ First search - will miss cache","    let results1 = try await engine.searchWithCache(","        query: \"machine learning tutorials\",","        useCache: true","    )","    ","    \/\/ Second search with same query - will hit cache","    let results2 = try await engine.searchWithCache(","        query: \"machine learning tutorials\",","        useCache: true","    )","    ","    \/\/ Get cache statistics","    let stats = cacheManager.getStats()","    print(\"Cache Stats:\")","    print(\"  Embedding cache size: \\(stats.embeddingCacheSize)\")","    print(\"  Query cache size: \\(stats.queryCacheSize)\")","    print(\"  Embedding hit rate: \\(stats.embeddingHitRate * 100)%\")","    print(\"  Query hit rate: \\(stats.queryHitRate * 100)%\")","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Handling-Stream-Interruptions":{"title":"Handling Stream Interruptions","abstract":[{"type":"text","text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Handling-Stream-Interruptions","url":"\/tutorials\/openaikit\/06-streaming-responses#Handling-Stream-Interruptions"},"advanced-01-chunking.swift":{"syntax":"swift","highlights":[],"fileName":"AdvancedEmbeddings.swift","fileType":"swift","type":"file","identifier":"advanced-01-chunking.swift","content":["import OpenAIKit","import Foundation","","\/\/ Advanced document chunking strategies for optimal semantic search","","struct AdvancedChunker {","    let openAI: OpenAI","    let maxChunkSize: Int = 1500","    let chunkOverlap: Int = 200","    ","    \/\/ Semantic chunking using sentence boundaries","    func semanticChunk(text: String) async throws -> [DocumentChunk] {","        let sentences = extractSentences(from: text)","        var chunks: [DocumentChunk] = []","        var currentChunk = \"\"","        var currentTokens = 0","        var chunkIndex = 0","        ","        for sentence in sentences {","            let sentenceTokens = estimateTokens(sentence)","            ","            if currentTokens + sentenceTokens > maxChunkSize && !currentChunk.isEmpty {","                \/\/ Create chunk with overlap","                let overlap = extractOverlap(from: currentChunk, tokens: chunkOverlap)","                chunks.append(DocumentChunk(","                    content: currentChunk,","                    index: chunkIndex,","                    metadata: ChunkMetadata(","                        startToken: chunkIndex * (maxChunkSize - chunkOverlap),","                        endToken: chunkIndex * (maxChunkSize - chunkOverlap) + currentTokens,","                        hasOverlap: chunkIndex > 0","                    )","                ))","                ","                currentChunk = overlap + sentence","                currentTokens = estimateTokens(currentChunk)","                chunkIndex += 1","            } else {","                currentChunk += \" \" + sentence","                currentTokens += sentenceTokens","            }","        }","        ","        \/\/ Add final chunk","        if !currentChunk.isEmpty {","            chunks.append(DocumentChunk(","                content: currentChunk,","                index: chunkIndex,","                metadata: ChunkMetadata(","                    startToken: chunkIndex * (maxChunkSize - chunkOverlap),","                    endToken: chunkIndex * (maxChunkSize - chunkOverlap) + currentTokens,","                    hasOverlap: chunkIndex > 0","                )","            ))","        }","        ","        return chunks","    }","    ","    \/\/ Hierarchical chunking for structured documents","    func hierarchicalChunk(document: StructuredDocument) async throws -> HierarchicalChunks {","        var chunks = HierarchicalChunks()","        ","        \/\/ Process document hierarchy","        for section in document.sections {","            let sectionChunks = try await processSectionHierarchy(","                section: section,","                parentPath: [document.title]","            )","            chunks.sections.append(sectionChunks)","        }","        ","        \/\/ Create summary embeddings for navigation","        chunks.summaryEmbeddings = try await createSummaryEmbeddings(chunks)","        ","        return chunks","    }","    ","    \/\/ Smart chunking with context preservation","    func contextAwareChunk(text: String, context: DocumentContext) async throws -> [ContextualChunk] {","        var chunks: [ContextualChunk] = []","        ","        \/\/ Identify important entities and concepts","        let entities = try await extractEntities(from: text)","        let keyPhrases = try await extractKeyPhrases(from: text)","        ","        \/\/ Chunk with entity boundaries","        let rawChunks = try await semanticChunk(text: text)","        ","        for (index, chunk) in rawChunks.enumerated() {","            \/\/ Find entities in this chunk","            let chunkEntities = entities.filter { chunk.content.contains($0.text) }","            let chunkPhrases = keyPhrases.filter { chunk.content.contains($0) }","            ","            \/\/ Add contextual information","            let contextualChunk = ContextualChunk(","                content: chunk.content,","                index: index,","                context: ChunkContext(","                    documentTitle: context.title,","                    documentType: context.type,","                    section: context.currentSection,","                    entities: chunkEntities,","                    keyPhrases: chunkPhrases,","                    precedingContext: index > 0 ? extractSummary(from: rawChunks[index - 1]) : nil,","                    followingContext: index < rawChunks.count - 1 ? extractSummary(from: rawChunks[index + 1]) : nil","                ),","                metadata: chunk.metadata","            )","            ","            chunks.append(contextualChunk)","        }","        ","        return chunks","    }","    ","    \/\/ Sliding window chunking for dense information","    func slidingWindowChunk(text: String, windowSize: Int = 1000, stepSize: Int = 500) -> [WindowChunk] {","        var chunks: [WindowChunk] = []","        let tokens = tokenize(text)","        var position = 0","        ","        while position < tokens.count {","            let endPosition = min(position + windowSize, tokens.count)","            let windowTokens = Array(tokens[position..<endPosition])","            ","            let chunk = WindowChunk(","                content: windowTokens.joined(separator: \" \"),","                startPosition: position,","                endPosition: endPosition,","                overlapWithPrevious: position > 0 ? windowSize - stepSize : 0,","                overlapWithNext: endPosition < tokens.count ? windowSize - stepSize : 0","            )","            ","            chunks.append(chunk)","            position += stepSize","        }","        ","        return chunks","    }","    ","    \/\/ Multi-modal chunking for documents with images\/tables","    func multiModalChunk(document: MultiModalDocument) async throws -> [MultiModalChunk] {","        var chunks: [MultiModalChunk] = []","        ","        for element in document.elements {","            switch element {","            case .text(let content):","                let textChunks = try await semanticChunk(text: content)","                chunks.append(contentsOf: textChunks.map { .text($0) })","                ","            case .image(let imageData, let caption):","                \/\/ Generate image embedding","                let imageEmbedding = try await generateImageEmbedding(imageData)","                chunks.append(.image(ImageChunk(","                    embedding: imageEmbedding,","                    caption: caption,","                    surroundingText: extractSurroundingContext(document, element)","                )))","                ","            case .table(let tableData):","                \/\/ Convert table to searchable format","                let tableChunks = try await processTable(tableData)","                chunks.append(contentsOf: tableChunks)","                ","            case .code(let codeBlock):","                \/\/ Special handling for code blocks","                chunks.append(.code(CodeChunk(","                    content: codeBlock.content,","                    language: codeBlock.language,","                    documentation: try await generateCodeDocumentation(codeBlock)","                )))","            }","        }","        ","        return chunks","    }","    ","    \/\/ Helper functions","    private func extractSentences(from text: String) -> [String] {","        \/\/ Use NLP for proper sentence segmentation","        let tagger = NSLinguisticTagger(tagSchemes: [.tokenType], options: 0)","        tagger.string = text","        var sentences: [String] = []","        var currentSentence = \"\"","        ","        tagger.enumerateTags(in: NSRange(location: 0, length: text.count), ","                            unit: .sentence, ","                            scheme: .tokenType, ","                            options: [.omitWhitespace]) { _, tokenRange, _ in","            let sentence = (text as NSString).substring(with: tokenRange)","            sentences.append(sentence)","            return true","        }","        ","        return sentences","    }","    ","    private func estimateTokens(_ text: String) -> Int {","        \/\/ Rough estimation: ~4 characters per token","        return text.count \/ 4","    }","    ","    private func extractOverlap(from chunk: String, tokens: Int) -> String {","        let words = chunk.split(separator: \" \")","        let overlapWords = Int(Double(words.count) * Double(tokens) \/ Double(estimateTokens(chunk)))","        return words.suffix(overlapWords).joined(separator: \" \")","    }","    ","    private func extractEntities(from text: String) async throws -> [Entity] {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"Extract named entities (people, places, organizations, etc.) from the text.\"),","                .user(text)","            ],","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        \/\/ Parse entities from response","        return []","    }","    ","    private func extractKeyPhrases(from text: String) async throws -> [String] {","        let request = ChatCompletionRequest(","            model: .gpt4turbo,","            messages: [","                .system(\"Extract key phrases and important concepts from the text.\"),","                .user(text)","            ]","        )","        ","        let response = try await openAI.chat.completions.create(request)","        \/\/ Parse key phrases from response","        return []","    }","}","","\/\/ Data structures","struct DocumentChunk {","    let content: String","    let index: Int","    let metadata: ChunkMetadata","}","","struct ChunkMetadata {","    let startToken: Int","    let endToken: Int","    let hasOverlap: Bool","}","","struct StructuredDocument {","    let title: String","    let sections: [Section]","}","","struct Section {","    let title: String","    let content: String","    let subsections: [Section]","}","","struct HierarchicalChunks {","    var sections: [SectionChunks] = []","    var summaryEmbeddings: [String: [Float]] = [:]","}","","struct SectionChunks {","    let path: [String]","    let chunks: [DocumentChunk]","    let summary: String","}","","struct DocumentContext {","    let title: String","    let type: DocumentType","    let currentSection: String?","}","","enum DocumentType {","    case technical","    case narrative","    case reference","    case mixed","}","","struct ContextualChunk {","    let content: String","    let index: Int","    let context: ChunkContext","    let metadata: ChunkMetadata","}","","struct ChunkContext {","    let documentTitle: String","    let documentType: DocumentType","    let section: String?","    let entities: [Entity]","    let keyPhrases: [String]","    let precedingContext: String?","    let followingContext: String?","}","","struct Entity {","    let text: String","    let type: EntityType","}","","enum EntityType {","    case person","    case place","    case organization","    case concept","}","","struct WindowChunk {","    let content: String","    let startPosition: Int","    let endPosition: Int","    let overlapWithPrevious: Int","    let overlapWithNext: Int","}","","enum MultiModalElement {","    case text(String)","    case image(Data, caption: String)","    case table(TableData)","    case code(CodeBlock)","}","","struct MultiModalDocument {","    let elements: [MultiModalElement]","}","","enum MultiModalChunk {","    case text(DocumentChunk)","    case image(ImageChunk)","    case table(TableChunk)","    case code(CodeChunk)","}","","struct ImageChunk {","    let embedding: [Float]","    let caption: String","    let surroundingText: String","}","","struct TableChunk {","    let content: String","    let headers: [String]","    let summary: String","}","","struct CodeChunk {","    let content: String","    let language: String","    let documentation: String","}","","struct TableData {","    let headers: [String]","    let rows: [[String]]","}","","struct CodeBlock {","    let content: String","    let language: String","}","","\/\/ Usage example","func demonstrateAdvancedChunking() async throws {","    let openAI = OpenAI(apiKey: \"your-api-key\")","    let chunker = AdvancedChunker(openAI: openAI)","    ","    \/\/ Example 1: Semantic chunking with overlap","    let document = \"\"\"","    Introduction to Machine Learning. Machine learning is a subset of artificial intelligence.","    It focuses on the development of algorithms that can learn from data. These algorithms","    improve their performance over time without being explicitly programmed.","    ","    Types of Machine Learning. There are three main types: supervised learning, unsupervised","    learning, and reinforcement learning. Each type has its own characteristics and use cases.","    \"\"\"","    ","    let semanticChunks = try await chunker.semanticChunk(text: document)","    print(\"Semantic chunks with overlap: \\(semanticChunks.count)\")","    ","    \/\/ Example 2: Context-aware chunking","    let context = DocumentContext(","        title: \"ML Fundamentals\",","        type: .technical,","        currentSection: \"Introduction\"","    )","    ","    let contextualChunks = try await chunker.contextAwareChunk(","        text: document,","        context: context","    )","    ","    print(\"Contextual chunks with entities: \\(contextualChunks.count)\")","    ","    \/\/ Example 3: Sliding window for dense information","    let denseText = \"Deep learning neural networks transformer models attention mechanisms...\"","    let windowChunks = chunker.slidingWindowChunk(","        text: denseText,","        windowSize: 100,","        stepSize: 50","    )","    ","    print(\"Sliding window chunks: \\(windowChunks.count)\")","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Advanced-Conversation-Patterns":{"title":"Advanced Conversation Patterns","abstract":[{"text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions.","type":"text"}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Advanced-Conversation-Patterns","url":"\/tutorials\/openaikit\/05-building-conversations#Advanced-Conversation-Patterns"},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors#Check-Your-Understanding":{"type":"link","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Check-Your-Understanding","url":"\/tutorials\/openaikit\/04-handling-errors#Check-Your-Understanding","title":"Check Your Understanding","titleInlineContent":[{"text":"Check Your Understanding","type":"text"}]},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors#Implementing-Retry-Logic":{"title":"Implementing Retry Logic","abstract":[{"type":"text","text":"Learn how to gracefully handle errors and edge cases when working with the OpenAI API."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Implementing-Retry-Logic","url":"\/tutorials\/openaikit\/04-handling-errors#Implementing-Retry-Logic"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit":{"type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit","role":"project","title":"Setting Up OpenAIKit","abstract":[{"type":"text","text":"Configure OpenAIKit in your Swift project and authenticate with the OpenAI API."}],"estimatedTime":"10min","url":"\/tutorials\/openaikit\/01-setting-up-openaikit","kind":"project"},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses","type":"topic","role":"project","title":"Streaming Responses","abstract":[{"text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated.","type":"text"}],"estimatedTime":"15min","url":"\/tutorials\/openaikit\/06-streaming-responses","kind":"project"},"app-05-analytics.swift":{"fileName":"KnowledgeBaseApp.swift","fileType":"swift","identifier":"app-05-analytics.swift","highlights":[{"line":4},{"line":5},{"line":7},{"line":8},{"line":12},{"line":13},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":103},{"line":104},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":143},{"line":144},{"line":145},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":165},{"line":166},{"line":167},{"line":169},{"line":170},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":184},{"line":185},{"line":186},{"line":188},{"line":189},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":232},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":248},{"line":249},{"line":250},{"line":252},{"line":253},{"line":254},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":306},{"line":307},{"line":309},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":326},{"line":327},{"line":328},{"line":329},{"line":330},{"line":331},{"line":333},{"line":335},{"line":336},{"line":337},{"line":338},{"line":339},{"line":340},{"line":341},{"line":343},{"line":344},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":367},{"line":368},{"line":369},{"line":370},{"line":371},{"line":372},{"line":373},{"line":374},{"line":375},{"line":376},{"line":377},{"line":378},{"line":379},{"line":380},{"line":381},{"line":382},{"line":383},{"line":384},{"line":385},{"line":386},{"line":387},{"line":388},{"line":395},{"line":396},{"line":397},{"line":400},{"line":401},{"line":402},{"line":403},{"line":404},{"line":405},{"line":409},{"line":411},{"line":412},{"line":414},{"line":417},{"line":422},{"line":423},{"line":424},{"line":425},{"line":426},{"line":427},{"line":428},{"line":429},{"line":430},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":446},{"line":447},{"line":448},{"line":449},{"line":450},{"line":453},{"line":454},{"line":455},{"line":458},{"line":459},{"line":460},{"line":461},{"line":462},{"line":463},{"line":464},{"line":465},{"line":468},{"line":469},{"line":470},{"line":471},{"line":472},{"line":473},{"line":474},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":484},{"line":485},{"line":486},{"line":487},{"line":488},{"line":491},{"line":492},{"line":493},{"line":494},{"line":495},{"line":496},{"line":497},{"line":498},{"line":499},{"line":500},{"line":501},{"line":502},{"line":503},{"line":504},{"line":505},{"line":506},{"line":507},{"line":508},{"line":509},{"line":510},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":517},{"line":518},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":524},{"line":525},{"line":526},{"line":527},{"line":528},{"line":529},{"line":530},{"line":532},{"line":533},{"line":535},{"line":536},{"line":537},{"line":538},{"line":539},{"line":540},{"line":541},{"line":542},{"line":543},{"line":544},{"line":545},{"line":546},{"line":547},{"line":548},{"line":549},{"line":550},{"line":551},{"line":554},{"line":556},{"line":557},{"line":558},{"line":559},{"line":560},{"line":561},{"line":564},{"line":565},{"line":566},{"line":567},{"line":568},{"line":569},{"line":570},{"line":571},{"line":572},{"line":573},{"line":574},{"line":575},{"line":577},{"line":578},{"line":579},{"line":580},{"line":581},{"line":582},{"line":583},{"line":584},{"line":585},{"line":586},{"line":587},{"line":588}],"content":["import OpenAIKit","import Foundation","","\/\/ Search analytics and insights","class SearchAnalytics {","    let openAI: OpenAI","    let analyticsStore: AnalyticsStore","    let insightGenerator: InsightGenerator","    ","    init(apiKey: String) {","        self.openAI = OpenAI(apiKey: apiKey)","        self.analyticsStore = AnalyticsStore()","        self.insightGenerator = InsightGenerator(openAI: openAI)","    }","    ","    \/\/ Track search query","    func trackSearch(_ searchEvent: SearchEvent) async throws {","        \/\/ Store search event","        try await analyticsStore.store(searchEvent)","        ","        \/\/ Update real-time metrics","        try await updateMetrics(for: searchEvent)","        ","        \/\/ Check for insight generation triggers","        if shouldGenerateInsights() {","            try await generateAndStoreInsights()","        }","    }","    ","    \/\/ Get analytics dashboard data","    func getDashboardData(timeRange: TimeRange) async throws -> AnalyticsDashboard {","        \/\/ Fetch search events","        let events = try await analyticsStore.getEvents(in: timeRange)","        ","        \/\/ Calculate metrics","        let metrics = calculateMetrics(from: events)","        ","        \/\/ Get top queries","        let topQueries = getTopQueries(from: events, limit: 10)","        ","        \/\/ Get search patterns","        let patterns = try await analyzeSearchPatterns(events: events)","        ","        \/\/ Get user behavior insights","        let behaviorInsights = try await analyzeUserBehavior(events: events)","        ","        \/\/ Get content gaps","        let contentGaps = try await identifyContentGaps(events: events)","        ","        return AnalyticsDashboard(","            timeRange: timeRange,","            metrics: metrics,","            topQueries: topQueries,","            searchPatterns: patterns,","            userBehaviorInsights: behaviorInsights,","            contentGaps: contentGaps,","            generatedAt: Date()","        )","    }","    ","    \/\/ Calculate search metrics","    private func calculateMetrics(from events: [SearchEvent]) -> SearchMetrics {","        let totalSearches = events.count","        let uniqueUsers = Set(events.map { $0.userId }).count","        ","        \/\/ Calculate average results per search","        let avgResultsPerSearch = events.isEmpty ? 0 :","            Double(events.map { $0.resultCount }.reduce(0, +)) \/ Double(events.count)","        ","        \/\/ Calculate click-through rate","        let searchesWithClicks = events.filter { !$0.clickedResults.isEmpty }.count","        let clickThroughRate = totalSearches > 0 ?","            Double(searchesWithClicks) \/ Double(totalSearches) : 0","        ","        \/\/ Calculate zero result rate","        let zeroResultSearches = events.filter { $0.resultCount == 0 }.count","        let zeroResultRate = totalSearches > 0 ?","            Double(zeroResultSearches) \/ Double(totalSearches) : 0","        ","        \/\/ Calculate average search refinements","        let refinementCounts = Dictionary(grouping: events, by: { $0.sessionId })","            .map { $0.value.count - 1 } \/\/ -1 for initial search","            .filter { $0 > 0 }","        let avgRefinements = refinementCounts.isEmpty ? 0 :","            Double(refinementCounts.reduce(0, +)) \/ Double(refinementCounts.count)","        ","        return SearchMetrics(","            totalSearches: totalSearches,","            uniqueUsers: uniqueUsers,","            avgResultsPerSearch: avgResultsPerSearch,","            clickThroughRate: clickThroughRate,","            zeroResultRate: zeroResultRate,","            avgSearchRefinements: avgRefinements","        )","    }","    ","    \/\/ Get top queries","    private func getTopQueries(from events: [SearchEvent], limit: Int) -> [TopQuery] {","        \/\/ Count query frequencies","        let queryCounts = Dictionary(grouping: events, by: { $0.query })","            .mapValues { $0.count }","        ","        \/\/ Sort by frequency and create top queries","        return queryCounts.sorted { $0.value > $1.value }","            .prefix(limit)","            .map { query, count in","                let queryEvents = events.filter { $0.query == query }","                let avgResultCount = Double(queryEvents.map { $0.resultCount }.reduce(0, +)) \/ Double(queryEvents.count)","                let clickRate = Double(queryEvents.filter { !$0.clickedResults.isEmpty }.count) \/ Double(queryEvents.count)","                ","                return TopQuery(","                    query: query,","                    searchCount: count,","                    avgResultCount: avgResultCount,","                    clickRate: clickRate","                )","            }","    }","    ","    \/\/ Analyze search patterns","    private func analyzeSearchPatterns(events: [SearchEvent]) async throws -> [SearchPattern] {","        var patterns: [SearchPattern] = []","        ","        \/\/ Time-based patterns","        let timePatterns = analyzeTimePatterns(events: events)","        patterns.append(contentsOf: timePatterns)","        ","        \/\/ Query complexity patterns","        let complexityPatterns = analyzeQueryComplexity(events: events)","        patterns.append(contentsOf: complexityPatterns)","        ","        \/\/ Category patterns","        let categoryPatterns = analyzeCategoryPatterns(events: events)","        patterns.append(contentsOf: categoryPatterns)","        ","        \/\/ Use LLM to identify additional patterns","        let llmPatterns = try await identifyPatternsWithLLM(events: events)","        patterns.append(contentsOf: llmPatterns)","        ","        return patterns","    }","    ","    \/\/ Analyze time-based patterns","    private func analyzeTimePatterns(events: [SearchEvent]) -> [SearchPattern] {","        var patterns: [SearchPattern] = []","        ","        \/\/ Group by hour of day","        let hourlyGroups = Dictionary(grouping: events) { event in","            Calendar.current.component(.hour, from: event.timestamp)","        }","        ","        \/\/ Find peak hours","        if let peakHour = hourlyGroups.max(by: { $0.value.count < $1.value.count }) {","            patterns.append(SearchPattern(","                type: .temporal,","                description: \"Peak search activity at \\(peakHour.key):00\",","                significance: Double(peakHour.value.count) \/ Double(events.count),","                affectedQueries: Array(Set(peakHour.value.map { $0.query }))","            ))","        }","        ","        return patterns","    }","    ","    \/\/ Analyze query complexity","    private func analyzeQueryComplexity(events: [SearchEvent]) -> [SearchPattern] {","        var patterns: [SearchPattern] = []","        ","        let complexQueries = events.filter { $0.query.split(separator: \" \").count > 5 }","        let complexityRate = Double(complexQueries.count) \/ Double(events.count)","        ","        if complexityRate > 0.3 {","            patterns.append(SearchPattern(","                type: .complexity,","                description: \"High rate of complex queries (\\(Int(complexityRate * 100))%)\",","                significance: complexityRate,","                affectedQueries: Array(Set(complexQueries.map { $0.query })).prefix(5).map { String($0) }","            ))","        }","        ","        return patterns","    }","    ","    \/\/ Analyze category patterns","    private func analyzeCategoryPatterns(events: [SearchEvent]) -> [SearchPattern] {","        var patterns: [SearchPattern] = []","        ","        \/\/ Group by clicked result categories","        var categoryClicks: [String: Int] = [:]","        ","        for event in events {","            for click in event.clickedResults {","                categoryClicks[click.category, default: 0] += 1","            }","        }","        ","        \/\/ Find dominant categories","        if let topCategory = categoryClicks.max(by: { $0.value < $1.value }) {","            let dominance = Double(topCategory.value) \/ Double(categoryClicks.values.reduce(0, +))","            ","            if dominance > 0.4 {","                patterns.append(SearchPattern(","                    type: .category,","                    description: \"\\(topCategory.key) category dominates search clicks\",","                    significance: dominance,","                    affectedQueries: []","                ))","            }","        }","        ","        return patterns","    }","    ","    \/\/ Identify patterns using LLM","    private func identifyPatternsWithLLM(events: [SearchEvent]) async throws -> [SearchPattern] {","        \/\/ Prepare sample data for LLM","        let sampleQueries = Array(Set(events.map { $0.query })).prefix(50)","        ","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Analyze search queries to identify patterns and trends.\"),","                .user(\"\"\"","                Search queries:","                \\(sampleQueries.joined(separator: \"\\n\"))","                ","                Identify any notable patterns in topics, intent, or structure.","                Format as JSON array with pattern type, description, and significance.","                \"\"\")","            ],","            temperature: 0.3,","            responseFormat: .jsonObject","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse and return patterns (simplified)","        return [","            SearchPattern(","                type: .semantic,","                description: \"Growing interest in AI and machine learning topics\",","                significance: 0.7,","                affectedQueries: [\"machine learning\", \"AI algorithms\", \"neural networks\"]","            )","        ]","    }","    ","    \/\/ Analyze user behavior","    private func analyzeUserBehavior(events: [SearchEvent]) async throws -> [UserBehaviorInsight] {","        var insights: [UserBehaviorInsight] = []","        ","        \/\/ Analyze refinement behavior","        let refinementInsight = analyzeRefinementBehavior(events: events)","        insights.append(refinementInsight)","        ","        \/\/ Analyze click patterns","        let clickInsight = analyzeClickBehavior(events: events)","        insights.append(clickInsight)","        ","        \/\/ Analyze abandonment","        let abandonmentInsight = analyzeAbandonment(events: events)","        insights.append(abandonmentInsight)","        ","        return insights","    }","    ","    \/\/ Analyze refinement behavior","    private func analyzeRefinementBehavior(events: [SearchEvent]) -> UserBehaviorInsight {","        let sessionGroups = Dictionary(grouping: events, by: { $0.sessionId })","        let refinementSessions = sessionGroups.filter { $0.value.count > 1 }","        ","        let avgRefinements = refinementSessions.isEmpty ? 0 :","            Double(refinementSessions.map { $0.value.count - 1 }.reduce(0, +)) \/","            Double(refinementSessions.count)","        ","        return UserBehaviorInsight(","            type: .searchRefinement,","            metric: avgRefinements,","            description: \"Users refine searches \\(String(format: \"%.1f\", avgRefinements)) times on average\",","            recommendation: avgRefinements > 2 ?","                \"Consider improving initial search relevance\" :","                \"Search refinement behavior is normal\"","        )","    }","    ","    \/\/ Analyze click behavior","    private func analyzeClickBehavior(events: [SearchEvent]) -> UserBehaviorInsight {","        let eventsWithClicks = events.filter { !$0.clickedResults.isEmpty }","        let avgClickPosition = eventsWithClicks.isEmpty ? 0 :","            Double(eventsWithClicks.flatMap { $0.clickedResults.map { $0.position } }.reduce(0, +)) \/","            Double(eventsWithClicks.flatMap { $0.clickedResults }.count)","        ","        return UserBehaviorInsight(","            type: .clickPosition,","            metric: avgClickPosition,","            description: \"Average click position: \\(String(format: \"%.1f\", avgClickPosition))\",","            recommendation: avgClickPosition > 3 ?","                \"Consider improving result ranking algorithm\" :","                \"Click positions indicate good ranking\"","        )","    }","    ","    \/\/ Analyze abandonment","    private func analyzeAbandonment(events: [SearchEvent]) -> UserBehaviorInsight {","        let abandonedSearches = events.filter { $0.clickedResults.isEmpty && $0.resultCount > 0 }","        let abandonmentRate = events.isEmpty ? 0 :","            Double(abandonedSearches.count) \/ Double(events.count)","        ","        return UserBehaviorInsight(","            type: .abandonment,","            metric: abandonmentRate,","            description: \"\\(Int(abandonmentRate * 100))% of searches are abandoned\",","            recommendation: abandonmentRate > 0.5 ?","                \"High abandonment rate - review result quality\" :","                \"Abandonment rate is acceptable\"","        )","    }","    ","    \/\/ Identify content gaps","    private func identifyContentGaps(events: [SearchEvent]) async throws -> [ContentGap] {","        \/\/ Find queries with no results","        let zeroResultQueries = events","            .filter { $0.resultCount == 0 }","            .map { $0.query }","        ","        \/\/ Find queries with low click rates","        let lowClickQueries = Dictionary(grouping: events, by: { $0.query })","            .filter { queries in","                let clickRate = Double(queries.value.filter { !$0.clickedResults.isEmpty }.count) \/","                               Double(queries.value.count)","                return clickRate < 0.2 && queries.value.count > 3","            }","            .map { $0.key }","        ","        \/\/ Use LLM to analyze gaps","        let gaps = try await insightGenerator.analyzeContentGaps(","            zeroResultQueries: Array(Set(zeroResultQueries)),","            lowClickQueries: Array(Set(lowClickQueries))","        )","        ","        return gaps","    }","    ","    \/\/ Update real-time metrics","    private func updateMetrics(for event: SearchEvent) async throws {","        \/\/ Update counters, rates, etc.","        \/\/ This would typically update a cache or real-time database","    }","    ","    \/\/ Check if insights should be generated","    private func shouldGenerateInsights() -> Bool {","        \/\/ Check based on event count, time elapsed, etc.","        return true \/\/ Simplified","    }","    ","    \/\/ Generate and store insights","    private func generateAndStoreInsights() async throws {","        let recentEvents = try await analyticsStore.getEvents(","            in: TimeRange(start: Date().addingTimeInterval(-3600), end: Date())","        )","        ","        let insights = try await insightGenerator.generateInsights(from: recentEvents)","        try await analyticsStore.storeInsights(insights)","    }","}","","\/\/ Analytics store","class AnalyticsStore {","    private var events: [SearchEvent] = []","    private var insights: [GeneratedInsight] = []","    ","    func store(_ event: SearchEvent) async throws {","        events.append(event)","    }","    ","    func getEvents(in timeRange: TimeRange) async throws -> [SearchEvent] {","        return events.filter { event in","            event.timestamp >= timeRange.start && event.timestamp <= timeRange.end","        }","    }","    ","    func storeInsights(_ insights: [GeneratedInsight]) async throws {","        self.insights.append(contentsOf: insights)","    }","}","","\/\/ Insight generator","class InsightGenerator {","    let openAI: OpenAI","    ","    init(openAI: OpenAI) {","        self.openAI = openAI","    }","    ","    func generateInsights(from events: [SearchEvent]) async throws -> [GeneratedInsight] {","        \/\/ Use LLM to generate insights","        return []","    }","    ","    func analyzeContentGaps(","        zeroResultQueries: [String],","        lowClickQueries: [String]","    ) async throws -> [ContentGap] {","        guard !zeroResultQueries.isEmpty || !lowClickQueries.isEmpty else { return [] }","        ","        let request = CreateChatCompletionRequest(","            model: .gpt4,","            messages: [","                .system(\"Analyze search queries to identify content gaps.\"),","                .user(\"\"\"","                Zero result queries: \\(zeroResultQueries.joined(separator: \", \"))","                Low click queries: \\(lowClickQueries.joined(separator: \", \"))","                ","                Identify content topics that should be added to improve search results.","                \"\"\")","            ],","            temperature: 0.3","        )","        ","        let response = try await openAI.chat.completions.create(request)","        ","        \/\/ Parse response (simplified)","        return [","            ContentGap(","                topic: \"Advanced Machine Learning Techniques\",","                affectedQueries: [\"deep learning optimization\", \"neural architecture search\"],","                priority: .high,","                suggestedContent: \"Create comprehensive guides on advanced ML topics\"","            )","        ]","    }","}","","\/\/ Models","struct SearchEvent {","    let id: String","    let userId: String","    let sessionId: String","    let query: String","    let timestamp: Date","    let resultCount: Int","    let clickedResults: [ClickedResult]","    let searchDuration: TimeInterval","}","","struct ClickedResult {","    let documentId: String","    let position: Int","    let category: String","    let clickTime: TimeInterval","}","","struct TimeRange {","    let start: Date","    let end: Date","}","","struct AnalyticsDashboard {","    let timeRange: TimeRange","    let metrics: SearchMetrics","    let topQueries: [TopQuery]","    let searchPatterns: [SearchPattern]","    let userBehaviorInsights: [UserBehaviorInsight]","    let contentGaps: [ContentGap]","    let generatedAt: Date","}","","struct SearchMetrics {","    let totalSearches: Int","    let uniqueUsers: Int","    let avgResultsPerSearch: Double","    let clickThroughRate: Double","    let zeroResultRate: Double","    let avgSearchRefinements: Double","}","","struct TopQuery {","    let query: String","    let searchCount: Int","    let avgResultCount: Double","    let clickRate: Double","}","","struct SearchPattern {","    let type: PatternType","    let description: String","    let significance: Double","    let affectedQueries: [String]","}","","enum PatternType {","    case temporal","    case complexity","    case category","    case semantic","}","","struct UserBehaviorInsight {","    let type: BehaviorType","    let metric: Double","    let description: String","    let recommendation: String","}","","enum BehaviorType {","    case searchRefinement","    case clickPosition","    case abandonment","}","","struct ContentGap {","    let topic: String","    let affectedQueries: [String]","    let priority: Priority","    let suggestedContent: String","}","","enum Priority {","    case high","    case medium","    case low","}","","struct GeneratedInsight {","    let id: String","    let type: String","    let content: String","    let generatedAt: Date","}","","\/\/ Usage example","func demonstrateAnalytics() async throws {","    let analytics = SearchAnalytics(apiKey: \"your-api-key\")","    ","    \/\/ Track a search event","    let searchEvent = SearchEvent(","        id: UUID().uuidString,","        userId: \"user123\",","        sessionId: \"session456\",","        query: \"machine learning algorithms\",","        timestamp: Date(),","        resultCount: 10,","        clickedResults: [","            ClickedResult(","                documentId: \"doc001\",","                position: 2,","                category: \"Technology\",","                clickTime: 5.2","            )","        ],","        searchDuration: 1.3","    )","    ","    try await analytics.trackSearch(searchEvent)","    ","    \/\/ Get dashboard data","    let dashboard = try await analytics.getDashboardData(","        timeRange: TimeRange(","            start: Date().addingTimeInterval(-86400), \/\/ 24 hours ago","            end: Date()","        )","    )","    ","    \/\/ Display metrics","    print(\"Search Analytics Dashboard\")","    print(\"========================\")","    print(\"\\nMetrics:\")","    print(\"- Total Searches: \\(dashboard.metrics.totalSearches)\")","    print(\"- Unique Users: \\(dashboard.metrics.uniqueUsers)\")","    print(\"- Click-through Rate: \\(String(format: \"%.1f%%\", dashboard.metrics.clickThroughRate * 100))\")","    print(\"- Zero Result Rate: \\(String(format: \"%.1f%%\", dashboard.metrics.zeroResultRate * 100))\")","    ","    print(\"\\nTop Queries:\")","    for query in dashboard.topQueries.prefix(5) {","        print(\"- \\\"\\(query.query)\\\" (\\(query.searchCount) searches)\")","    }","    ","    print(\"\\nUser Behavior Insights:\")","    for insight in dashboard.userBehaviorInsights {","        print(\"- \\(insight.description)\")","        print(\"  Recommendation: \\(insight.recommendation)\")","    }","    ","    print(\"\\nContent Gaps:\")","    for gap in dashboard.contentGaps {","        print(\"- \\(gap.topic) (Priority: \\(gap.priority))\")","        print(\"  \\(gap.suggestedContent)\")","    }","}"],"type":"file","syntax":"swift"},"engine-01-class.swift":{"syntax":"swift","highlights":[],"fileName":"SemanticSearchEngine.swift","fileType":"swift","type":"file","identifier":"engine-01-class.swift","content":["import Foundation","import OpenAIKit","","\/\/\/ A semantic search engine using OpenAI embeddings","class SemanticSearchEngine {","    private let openAI: OpenAIKit","    private var documents: [SearchDocument] = []","    private var embeddings: [String: [Double]] = [:]","    ","    \/\/\/ Represents a searchable document","    struct SearchDocument {","        let id: String","        let title: String","        let content: String","        let metadata: [String: Any]","        let timestamp: Date","        ","        init(title: String, content: String, metadata: [String: Any] = [:]) {","            self.id = UUID().uuidString","            self.title = title","            self.content = content","            self.metadata = metadata","            self.timestamp = Date()","        }","    }","    ","    \/\/\/ Search result with relevance score","    struct SearchResult {","        let document: SearchDocument","        let score: Double","        let highlights: [String]","    }","    ","    init(apiKey: String) {","        self.openAI = OpenAIKit(apiKey: apiKey)","    }","    ","    \/\/\/ Add a document to the search engine","    func addDocument(_ document: SearchDocument) async throws {","        documents.append(document)","        ","        \/\/ Generate embedding for the document","        let text = \"\\(document.title) \\(document.content)\"","        let embedding = try await generateEmbedding(for: text)","        embeddings[document.id] = embedding","    }","    ","    \/\/\/ Generate embedding for text","    private func generateEmbedding(for text: String) async throws -> [Double] {","        let request = CreateEmbeddingRequest(","            model: .textEmbeddingAda002,","            input: .string(text)","        )","        ","        let response = try await openAI.embeddings.create(embedding: request)","        return response.data.first?.embedding ?? []","    }","    ","    \/\/\/ Calculate cosine similarity between two vectors","    private func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {","        guard a.count == b.count else { return 0 }","        ","        let dotProduct = zip(a, b).map(*).reduce(0, +)","        let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","        let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","        ","        guard magnitudeA > 0 && magnitudeB > 0 else { return 0 }","        return dotProduct \/ (magnitudeA * magnitudeB)","    }","}","","\/\/ Example usage","let engine = SemanticSearchEngine(apiKey: \"your-api-key\")","","\/\/ Add documents","let doc1 = SemanticSearchEngine.SearchDocument(","    title: \"Introduction to Machine Learning\",","    content: \"Machine learning is a subset of artificial intelligence...\",","    metadata: [\"category\": \"AI\", \"difficulty\": \"beginner\"]",")","","let doc2 = SemanticSearchEngine.SearchDocument(","    title: \"Deep Learning Fundamentals\",","    content: \"Deep learning uses neural networks with multiple layers...\",","    metadata: [\"category\": \"AI\", \"difficulty\": \"intermediate\"]",")","","Task {","    try await engine.addDocument(doc1)","    try await engine.addDocument(doc2)","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Check-Your-Understanding":{"type":"link","title":"Check Your Understanding","url":"\/tutorials\/openaikit\/06-streaming-responses#Check-Your-Understanding","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Check-Your-Understanding","titleInlineContent":[{"text":"Check Your Understanding","type":"text"}]},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Code-Interpreter-for-Data-Analysis":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Code-Interpreter-for-Data-Analysis","role":"pseudoSymbol","title":"Code Interpreter for Data Analysis","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"url":"\/tutorials\/openaikit\/09-deep-research-analysis#Code-Interpreter-for-Data-Analysis","kind":"section"},"database-01-model.swift":{"fileName":"VectorDatabase.swift","fileType":"swift","identifier":"database-01-model.swift","highlights":[],"content":["import Foundation","import CoreData","","\/\/ MARK: - Vector Database Model","","\/\/ Core Data model for vector storage","@objc(VectorDocument)","public class VectorDocument: NSManagedObject {","    @NSManaged public var id: String","    @NSManaged public var content: String","    @NSManaged public var embeddingData: Data","    @NSManaged public var metadata: Data?","    @NSManaged public var createdAt: Date","    @NSManaged public var updatedAt: Date","    @NSManaged public var dimension: Int32","    @NSManaged public var source: String?","    @NSManaged public var collectionName: String","    ","    \/\/ Computed property for embedding vector","    var embedding: [Float] {","        get {","            guard let array = try? NSKeyedUnarchiver.unarchivedObject(","                ofClass: NSArray.self,","                from: embeddingData","            ) as? [Float] else {","                return []","            }","            return array","        }","        set {","            embeddingData = try! NSKeyedArchiver.archivedData(","                withRootObject: newValue,","                requiringSecureCoding: false","            )","            dimension = Int32(newValue.count)","        }","    }","    ","    \/\/ Computed property for metadata dictionary","    var metadataDict: [String: Any]? {","        get {","            guard let data = metadata else { return nil }","            return try? JSONSerialization.jsonObject(with: data) as? [String: Any]","        }","        set {","            metadata = newValue != nil ? try? JSONSerialization.data(withJSONObject: newValue!) : nil","        }","    }","}","","\/\/ MARK: - Vector Database Protocol","","protocol VectorDatabase {","    func insert(document: VectorDocumentInput) async throws -> String","    func insertBatch(documents: [VectorDocumentInput]) async throws -> [String]","    func search(query: VectorQuery) async throws -> [VectorSearchResult]","    func update(id: String, document: VectorDocumentInput) async throws","    func delete(id: String) async throws","    func deleteCollection(name: String) async throws","    func count(in collection: String?) async throws -> Int","}","","\/\/ MARK: - Core Data Vector Database","","class CoreDataVectorDatabase: VectorDatabase {","    private let container: NSPersistentContainer","    private let queue = DispatchQueue(label: \"vectordb.coredata\", attributes: .concurrent)","    ","    init(modelName: String = \"VectorDB\") {","        container = NSPersistentContainer(name: modelName)","        setupCoreData()","    }","    ","    private func setupCoreData() {","        \/\/ Create model programmatically if needed","        let model = NSManagedObjectModel()","        ","        \/\/ VectorDocument entity","        let vectorEntity = NSEntityDescription()","        vectorEntity.name = \"VectorDocument\"","        vectorEntity.managedObjectClassName = \"VectorDocument\"","        ","        \/\/ Add attributes","        let attributes: [(String, NSAttributeType, Bool)] = [","            (\"id\", .stringAttributeType, false),","            (\"content\", .stringAttributeType, false),","            (\"embeddingData\", .binaryDataAttributeType, false),","            (\"metadata\", .binaryDataAttributeType, true),","            (\"createdAt\", .dateAttributeType, false),","            (\"updatedAt\", .dateAttributeType, false),","            (\"dimension\", .integer32AttributeType, false),","            (\"source\", .stringAttributeType, true),","            (\"collectionName\", .stringAttributeType, false)","        ]","        ","        var properties: [NSPropertyDescription] = []","        ","        for (name, type, optional) in attributes {","            let attribute = NSAttributeDescription()","            attribute.name = name","            attribute.attributeType = type","            attribute.isOptional = optional","            properties.append(attribute)","        }","        ","        vectorEntity.properties = properties","        model.entities = [vectorEntity]","        ","        container.persistentStoreDescriptions.first?.setOption(","            true as NSNumber,","            forKey: NSPersistentHistoryTrackingKey","        )","        ","        container.loadPersistentStores { _, error in","            if let error = error {","                fatalError(\"Failed to load store: \\(error)\")","            }","        }","    }","    ","    func insert(document: VectorDocumentInput) async throws -> String {","        return try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let vectorDoc = VectorDocument(context: context)","                    vectorDoc.id = document.id ?? UUID().uuidString","                    vectorDoc.content = document.content","                    vectorDoc.embedding = document.embedding","                    vectorDoc.metadataDict = document.metadata","                    vectorDoc.createdAt = Date()","                    vectorDoc.updatedAt = Date()","                    vectorDoc.source = document.source","                    vectorDoc.collectionName = document.collection ?? \"default\"","                    ","                    try context.save()","                    continuation.resume(returning: vectorDoc.id)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func insertBatch(documents: [VectorDocumentInput]) async throws -> [String] {","        return try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                context.undoManager = nil  \/\/ Disable undo for performance","                ","                var ids: [String] = []","                ","                do {","                    for document in documents {","                        let vectorDoc = VectorDocument(context: context)","                        vectorDoc.id = document.id ?? UUID().uuidString","                        vectorDoc.content = document.content","                        vectorDoc.embedding = document.embedding","                        vectorDoc.metadataDict = document.metadata","                        vectorDoc.createdAt = Date()","                        vectorDoc.updatedAt = Date()","                        vectorDoc.source = document.source","                        vectorDoc.collectionName = document.collection ?? \"default\"","                        ","                        ids.append(vectorDoc.id)","                    }","                    ","                    try context.save()","                    continuation.resume(returning: ids)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func search(query: VectorQuery) async throws -> [VectorSearchResult] {","        return try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    \/\/ Fetch all documents from collection","                    let request = VectorDocument.fetchRequest()","                    ","                    if let collection = query.collection {","                        request.predicate = NSPredicate(format: \"collectionName == %@\", collection)","                    }","                    ","                    let documents = try context.fetch(request)","                    ","                    \/\/ Calculate similarities","                    var results: [VectorSearchResult] = []","                    ","                    for doc in documents {","                        let similarity = SimilarityCalculator.cosineSimilarity(","                            query.vector,","                            doc.embedding","                        )","                        ","                        if similarity >= query.threshold {","                            results.append(VectorSearchResult(","                                id: doc.id,","                                content: doc.content,","                                similarity: similarity,","                                metadata: doc.metadataDict,","                                embedding: doc.embedding","                            ))","                        }","                    }","                    ","                    \/\/ Sort by similarity and limit","                    results.sort { $0.similarity > $1.similarity }","                    if let limit = query.limit {","                        results = Array(results.prefix(limit))","                    }","                    ","                    continuation.resume(returning: results)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func update(id: String, document: VectorDocumentInput) async throws {","        try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let request = VectorDocument.fetchRequest()","                    request.predicate = NSPredicate(format: \"id == %@\", id)","                    ","                    guard let vectorDoc = try context.fetch(request).first else {","                        throw VectorDatabaseError.documentNotFound(id: id)","                    }","                    ","                    vectorDoc.content = document.content","                    vectorDoc.embedding = document.embedding","                    vectorDoc.metadataDict = document.metadata","                    vectorDoc.updatedAt = Date()","                    ","                    if let source = document.source {","                        vectorDoc.source = source","                    }","                    ","                    try context.save()","                    continuation.resume()","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func delete(id: String) async throws {","        try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let request = VectorDocument.fetchRequest()","                    request.predicate = NSPredicate(format: \"id == %@\", id)","                    ","                    guard let vectorDoc = try context.fetch(request).first else {","                        throw VectorDatabaseError.documentNotFound(id: id)","                    }","                    ","                    context.delete(vectorDoc)","                    try context.save()","                    continuation.resume()","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func deleteCollection(name: String) async throws {","        try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let request = VectorDocument.fetchRequest()","                    request.predicate = NSPredicate(format: \"collectionName == %@\", name)","                    ","                    let documents = try context.fetch(request)","                    for doc in documents {","                        context.delete(doc)","                    }","                    ","                    try context.save()","                    continuation.resume()","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","    ","    func count(in collection: String? = nil) async throws -> Int {","        return try await withCheckedThrowingContinuation { continuation in","            container.performBackgroundTask { context in","                do {","                    let request = VectorDocument.fetchRequest()","                    ","                    if let collection = collection {","                        request.predicate = NSPredicate(format: \"collectionName == %@\", collection)","                    }","                    ","                    let count = try context.count(for: request)","                    continuation.resume(returning: count)","                } catch {","                    continuation.resume(throwing: error)","                }","            }","        }","    }","}","","\/\/ MARK: - Models","","struct VectorDocumentInput {","    let id: String?","    let content: String","    let embedding: [Float]","    let metadata: [String: Any]?","    let source: String?","    let collection: String?","}","","struct VectorQuery {","    let vector: [Float]","    let limit: Int?","    let threshold: Float","    let collection: String?","    let filter: NSPredicate?","}","","struct VectorSearchResult {","    let id: String","    let content: String","    let similarity: Float","    let metadata: [String: Any]?","    let embedding: [Float]","}","","enum VectorDatabaseError: LocalizedError {","    case documentNotFound(id: String)","    case invalidEmbedding","    case collectionNotFound(name: String)","    ","    var errorDescription: String? {","        switch self {","        case .documentNotFound(let id):","            return \"Document with ID '\\(id)' not found\"","        case .invalidEmbedding:","            return \"Invalid embedding vector\"","        case .collectionNotFound(let name):","            return \"Collection '\\(name)' not found\"","        }","    }","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions","type":"topic","role":"project","title":"Working with Functions","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"estimatedTime":"20min","url":"\/tutorials\/openaikit\/03-working-with-functions","kind":"project"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Building-a-Voice-Notes-App":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Building-a-Voice-Notes-App","role":"pseudoSymbol","title":"Building a Voice Notes App","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"url":"\/tutorials\/openaikit\/08-transcribing-audio#Building-a-Voice-Notes-App","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations":{"title":"Building Conversations","abstract":[{"type":"text","text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions."}],"role":"project","kind":"project","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations","url":"\/tutorials\/openaikit\/05-building-conversations","estimatedTime":"18min"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Implementing-the-Weather-Function":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Implementing-the-Weather-Function","role":"pseudoSymbol","title":"Implementing the Weather Function","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"url":"\/tutorials\/openaikit\/03-working-with-functions#Implementing-the-Weather-Function","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Building-a-Complete-Chatbot":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Building-a-Complete-Chatbot","role":"pseudoSymbol","title":"Building a Complete Chatbot","abstract":[{"type":"text","text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions."}],"url":"\/tutorials\/openaikit\/05-building-conversations#Building-a-Complete-Chatbot","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit#Obtain-an-API-Key":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Obtain-an-API-Key","type":"section","role":"pseudoSymbol","title":"Obtain an API Key","abstract":[{"type":"text","text":"Configure OpenAIKit in your Swift project and authenticate with the OpenAI API."}],"url":"\/tutorials\/openaikit\/01-setting-up-openaikit#Obtain-an-API-Key","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Semantic-Search-Engine":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Semantic-Search-Engine","role":"pseudoSymbol","title":"Semantic Search Engine","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"url":"\/tutorials\/openaikit\/09-building-semantic-search#Semantic-Search-Engine","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Introduction-to-DeepResearch":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Introduction-to-DeepResearch","role":"pseudoSymbol","title":"Introduction to DeepResearch","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"url":"\/tutorials\/openaikit\/09-deep-research-analysis#Introduction-to-DeepResearch","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors":{"title":"Handling Errors","abstract":[{"type":"text","text":"Learn how to gracefully handle errors and edge cases when working with the OpenAI API."}],"role":"project","kind":"project","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors","url":"\/tutorials\/openaikit\/04-handling-errors","estimatedTime":"12min"},"engine-03-query.swift":{"syntax":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":27},{"line":28},{"line":29},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":47},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":92},{"line":93},{"line":94},{"line":95},{"line":97},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":184},{"line":185},{"line":186},{"line":187},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221}],"fileName":"SemanticSearchEngine.swift","fileType":"swift","type":"file","identifier":"engine-03-query.swift","content":["import Foundation","import OpenAIKit","","extension SemanticSearchEngine {","    \/\/\/ Search for documents matching the query","    func search(","        query: String,","        limit: Int = 10,","        threshold: Double = 0.7","    ) async throws -> [SearchResult] {","        guard !documents.isEmpty else {","            throw SearchError.indexNotBuilt","        }","        ","        \/\/ Expand query for better results","        let expandedQuery = try await expandQuery(query)","        ","        \/\/ Generate embedding for the expanded query","        let queryEmbedding = try await generateEmbedding(for: expandedQuery)","        ","        \/\/ Calculate similarities","        var results: [(document: SearchDocument, score: Double)] = []","        ","        for document in documents {","            guard let docEmbedding = embeddings[document.id] else { continue }","            ","            let similarity = cosineSimilarity(queryEmbedding, docEmbedding)","            if similarity >= threshold {","                results.append((document, similarity))","            }","        }","        ","        \/\/ Sort by relevance and limit results","        results.sort { $0.score > $1.score }","        let topResults = Array(results.prefix(limit))","        ","        \/\/ Generate highlights for results","        return try await generateHighlights(for: topResults, query: query)","    }","    ","    \/\/\/ Expand query with synonyms and related terms","    private func expandQuery(_ query: String) async throws -> String {","        let prompt = \"\"\"","        Expand this search query with synonyms and related terms.","        Keep the expansion concise and relevant.","        ","        Query: \"\\(query)\"","        ","        Expanded query:","        \"\"\"","        ","        let request = CreateChatCompletionRequest(","            model: .gpt3_5Turbo,","            messages: [","                .init(role: .user, content: .text(prompt))","            ],","            temperature: 0.3,","            maxTokens: 100","        )","        ","        let response = try await openAI.chat.create(chatCompletion: request)","        let expandedQuery = response.choices.first?.message.content?.string ?? query","        ","        return \"\\(query) \\(expandedQuery)\"","    }","    ","    \/\/\/ Advanced search with filters","    func advancedSearch(","        query: String,","        filters: SearchFilters,","        limit: Int = 10","    ) async throws -> [SearchResult] {","        \/\/ Get initial results","        var results = try await search(query: query, limit: limit * 2)","        ","        \/\/ Apply filters","        results = results.filter { result in","            \/\/ Date filter","            if let afterDate = filters.afterDate {","                guard result.document.timestamp >= afterDate else { return false }","            }","            ","            \/\/ Metadata filters","            for (key, value) in filters.metadata {","                guard let docValue = result.document.metadata[key] as? String,","                      docValue == value else { return false }","            }","            ","            return true","        }","        ","        \/\/ Apply boosting","        if !filters.boostTerms.isEmpty {","            results = applyBoost(to: results, boostTerms: filters.boostTerms)","        }","        ","        return Array(results.prefix(limit))","    }","    ","    \/\/\/ Apply score boosting for specific terms","    private func applyBoost(","        to results: [SearchResult],","        boostTerms: [String]","    ) -> [SearchResult] {","        return results.map { result in","            var boostedScore = result.score","            ","            for term in boostTerms {","                let termLower = term.lowercased()","                let content = result.document.content.lowercased()","                let title = result.document.title.lowercased()","                ","                \/\/ Boost if term appears in title (higher boost)","                if title.contains(termLower) {","                    boostedScore *= 1.5","                }","                ","                \/\/ Boost if term appears in content","                if content.contains(termLower) {","                    boostedScore *= 1.2","                }","            }","            ","            return SearchResult(","                document: result.document,","                score: min(boostedScore, 1.0), \/\/ Cap at 1.0","                highlights: result.highlights","            )","        }.sorted { $0.score > $1.score }","    }","    ","    \/\/\/ Generate contextual highlights","    private func generateHighlights(","        for results: [(document: SearchDocument, score: Double)],","        query: String","    ) async throws -> [SearchResult] {","        let highlights = try await withThrowingTaskGroup(of: (Int, [String]).self) { group in","            for (index, result) in results.enumerated() {","                group.addTask {","                    let highlights = try await self.extractHighlights(","                        from: result.document.content,","                        query: query","                    )","                    return (index, highlights)","                }","            }","            ","            var highlightMap: [Int: [String]] = [:]","            for try await (index, highlights) in group {","                highlightMap[index] = highlights","            }","            return highlightMap","        }","        ","        return results.enumerated().map { index, result in","            SearchResult(","                document: result.document,","                score: result.score,","                highlights: highlights[index] ?? []","            )","        }","    }","    ","    \/\/\/ Extract relevant text snippets","    private func extractHighlights(","        from content: String,","        query: String","    ) async throws -> [String] {","        \/\/ Simple implementation - find sentences containing query terms","        let sentences = content.components(separatedBy: CharacterSet(charactersIn: \".!?\"))","        let queryTerms = query.lowercased().split(separator: \" \").map(String.init)","        ","        var highlights: [String] = []","        for sentence in sentences {","            let lowerSentence = sentence.lowercased()","            if queryTerms.contains(where: { lowerSentence.contains($0) }) {","                highlights.append(sentence.trimmingCharacters(in: .whitespaces))","            }","        }","        ","        return Array(highlights.prefix(3)) \/\/ Return top 3 highlights","    }","    ","    struct SearchFilters {","        var afterDate: Date?","        var metadata: [String: String] = [:]","        var boostTerms: [String] = []","    }","}","","\/\/ Example usage","Task {","    let engine = SemanticSearchEngine(apiKey: \"your-api-key\")","    ","    \/\/ Simple search","    let results = try await engine.search(","        query: \"Swift programming async\",","        limit: 5,","        threshold: 0.6","    )","    ","    for result in results {","        print(\"Document: \\(result.document.title)\")","        print(\"Score: \\(result.score)\")","        print(\"Highlights:\")","        result.highlights.forEach { print(\"  - \\($0)\") }","        print(\"---\")","    }","    ","    \/\/ Advanced search with filters","    let filters = SemanticSearchEngine.SearchFilters(","        afterDate: Date().addingTimeInterval(-7 * 24 * 60 * 60), \/\/ Last week","        metadata: [\"category\": \"AI\"],","        boostTerms: [\"neural networks\", \"deep learning\"]","    )","    ","    let advancedResults = try await engine.advancedSearch(","        query: \"machine learning\",","        filters: filters,","        limit: 10","    )","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis":{"type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis","role":"project","title":"Deep Research and Analysis","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"estimatedTime":"25min","url":"\/tutorials\/openaikit\/09-deep-research-analysis","kind":"project"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Advanced-Transcription-Options":{"title":"Advanced Transcription Options","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Advanced-Transcription-Options","url":"\/tutorials\/openaikit\/08-transcribing-audio#Advanced-Transcription-Options"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Managing-Conversation-Context":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Managing-Conversation-Context","role":"pseudoSymbol","title":"Managing Conversation Context","abstract":[{"type":"text","text":"Create sophisticated conversational AI experiences by managing context, memory, and multi-turn interactions."}],"url":"\/tutorials\/openaikit\/05-building-conversations#Managing-Conversation-Context","kind":"section"},"similarity-01-calculator.swift":{"fileName":"VectorSimilarity.swift","fileType":"swift","identifier":"similarity-01-calculator.swift","highlights":[],"content":["import Foundation","import Accelerate","","\/\/ MARK: - Similarity Calculator","","struct SimilarityCalculator {","    ","    \/\/ Calculate cosine similarity between two vectors","    static func cosineSimilarity(_ vectorA: [Float], _ vectorB: [Float]) -> Float {","        guard vectorA.count == vectorB.count else {","            print(\"Warning: Vector dimensions don't match\")","            return 0","        }","        ","        \/\/ Use Accelerate framework for optimized computation","        var dotProduct: Float = 0","        var magnitudeA: Float = 0","        var magnitudeB: Float = 0","        ","        vDSP_dotpr(vectorA, 1, vectorB, 1, &dotProduct, vDSP_Length(vectorA.count))","        vDSP_svesq(vectorA, 1, &magnitudeA, vDSP_Length(vectorA.count))","        vDSP_svesq(vectorB, 1, &magnitudeB, vDSP_Length(vectorB.count))","        ","        let magnitude = sqrt(magnitudeA) * sqrt(magnitudeB)","        ","        guard magnitude > 0 else { return 0 }","        ","        return dotProduct \/ magnitude","    }","    ","    \/\/ Calculate Euclidean distance","    static func euclideanDistance(_ vectorA: [Float], _ vectorB: [Float]) -> Float {","        guard vectorA.count == vectorB.count else {","            print(\"Warning: Vector dimensions don't match\")","            return Float.infinity","        }","        ","        var result: Float = 0","        var difference = [Float](repeating: 0, count: vectorA.count)","        ","        \/\/ Calculate difference","        vDSP_vsub(vectorB, 1, vectorA, 1, &difference, 1, vDSP_Length(vectorA.count))","        ","        \/\/ Calculate squared sum","        vDSP_svesq(difference, 1, &result, vDSP_Length(difference.count))","        ","        return sqrt(result)","    }","    ","    \/\/ Calculate Manhattan distance","    static func manhattanDistance(_ vectorA: [Float], _ vectorB: [Float]) -> Float {","        guard vectorA.count == vectorB.count else {","            print(\"Warning: Vector dimensions don't match\")","            return Float.infinity","        }","        ","        var result: Float = 0","        var difference = [Float](repeating: 0, count: vectorA.count)","        var absoluteDifference = [Float](repeating: 0, count: vectorA.count)","        ","        \/\/ Calculate difference","        vDSP_vsub(vectorB, 1, vectorA, 1, &difference, 1, vDSP_Length(vectorA.count))","        ","        \/\/ Take absolute values","        vDSP_vabs(difference, 1, &absoluteDifference, 1, vDSP_Length(difference.count))","        ","        \/\/ Sum all values","        vDSP_sve(absoluteDifference, 1, &result, vDSP_Length(absoluteDifference.count))","        ","        return result","    }","    ","    \/\/ Calculate dot product similarity","    static func dotProduct(_ vectorA: [Float], _ vectorB: [Float]) -> Float {","        guard vectorA.count == vectorB.count else {","            print(\"Warning: Vector dimensions don't match\")","            return 0","        }","        ","        var result: Float = 0","        vDSP_dotpr(vectorA, 1, vectorB, 1, &result, vDSP_Length(vectorA.count))","        ","        return result","    }","    ","    \/\/ Normalize similarity score to 0-1 range","    static func normalizeSimilarity(_ score: Float, metric: SimilarityMetric) -> Float {","        switch metric {","        case .cosine:","            \/\/ Cosine similarity is already in [-1, 1], normalize to [0, 1]","            return (score + 1) \/ 2","            ","        case .euclidean(let maxDistance):","            \/\/ Convert distance to similarity","            return 1 - min(score \/ maxDistance, 1)","            ","        case .manhattan(let maxDistance):","            \/\/ Convert distance to similarity","            return 1 - min(score \/ maxDistance, 1)","            ","        case .dotProduct(let maxValue):","            \/\/ Normalize based on expected maximum","            return min(max(score \/ maxValue, 0), 1)","        }","    }","}","","\/\/ MARK: - Similarity Metrics","","enum SimilarityMetric {","    case cosine","    case euclidean(maxDistance: Float)","    case manhattan(maxDistance: Float)","    case dotProduct(maxValue: Float)","    ","    func calculate(_ vectorA: [Float], _ vectorB: [Float]) -> Float {","        switch self {","        case .cosine:","            return SimilarityCalculator.cosineSimilarity(vectorA, vectorB)","        case .euclidean:","            return SimilarityCalculator.euclideanDistance(vectorA, vectorB)","        case .manhattan:","            return SimilarityCalculator.manhattanDistance(vectorA, vectorB)","        case .dotProduct:","            return SimilarityCalculator.dotProduct(vectorA, vectorB)","        }","    }","    ","    var name: String {","        switch self {","        case .cosine:","            return \"Cosine Similarity\"","        case .euclidean:","            return \"Euclidean Distance\"","        case .manhattan:","            return \"Manhattan Distance\"","        case .dotProduct:","            return \"Dot Product\"","        }","    }","}","","\/\/ MARK: - Batch Similarity Calculator","","class BatchSimilarityCalculator {","    private let metric: SimilarityMetric","    private let queue = DispatchQueue(label: \"similarity.calculation\", attributes: .concurrent)","    ","    init(metric: SimilarityMetric = .cosine) {","        self.metric = metric","    }","    ","    \/\/ Calculate similarity between one vector and multiple vectors","    func calculateSimilarities(","        queryVector: [Float],","        targetVectors: [[Float]],","        completion: @escaping ([SimilarityResult]) -> Void","    ) {","        let group = DispatchGroup()","        var results = [SimilarityResult]()","        let lock = NSLock()","        ","        for (index, targetVector) in targetVectors.enumerated() {","            group.enter()","            queue.async {","                let score = self.metric.calculate(queryVector, targetVector)","                let result = SimilarityResult(","                    index: index,","                    score: score,","                    normalizedScore: SimilarityCalculator.normalizeSimilarity(score, metric: self.metric)","                )","                ","                lock.lock()","                results.append(result)","                lock.unlock()","                ","                group.leave()","            }","        }","        ","        group.notify(queue: .main) {","            \/\/ Sort by normalized score (descending)","            let sorted = results.sorted { $0.normalizedScore > $1.normalizedScore }","            completion(sorted)","        }","    }","    ","    \/\/ Calculate similarity matrix for all pairs","    func calculateSimilarityMatrix(","        vectors: [[Float]],","        completion: @escaping ([[Float]]) -> Void","    ) {","        let count = vectors.count","        var matrix = Array(repeating: Array(repeating: Float(0), count: count), count: count)","        ","        queue.async {","            for i in 0..<count {","                for j in i..<count {","                    if i == j {","                        matrix[i][j] = 1.0  \/\/ Self-similarity","                    } else {","                        let score = self.metric.calculate(vectors[i], vectors[j])","                        let normalized = SimilarityCalculator.normalizeSimilarity(score, metric: self.metric)","                        matrix[i][j] = normalized","                        matrix[j][i] = normalized  \/\/ Symmetric","                    }","                }","            }","            ","            DispatchQueue.main.async {","                completion(matrix)","            }","        }","    }","}","","\/\/ MARK: - Models","","struct SimilarityResult {","    let index: Int","    let score: Float","    let normalizedScore: Float","    ","    var percentage: Float {","        normalizedScore * 100","    }","    ","    var isHighSimilarity: Bool {","        normalizedScore > 0.8","    }","    ","    var isMediumSimilarity: Bool {","        normalizedScore > 0.6 && normalizedScore <= 0.8","    }","    ","    var isLowSimilarity: Bool {","        normalizedScore <= 0.6","    }","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Building-the-Complete-Assistant":{"title":"Building the Complete Assistant","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Building-the-Complete-Assistant","url":"\/tutorials\/openaikit\/03-working-with-functions#Building-the-Complete-Assistant"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit#Check-Your-Understanding":{"titleInlineContent":[{"text":"Check Your Understanding","type":"text"}],"url":"\/tutorials\/openaikit\/01-setting-up-openaikit#Check-Your-Understanding","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Check-Your-Understanding","type":"link","title":"Check Your Understanding"},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Building-a-Streaming-UI":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Building-a-Streaming-UI","type":"section","role":"pseudoSymbol","title":"Building a Streaming UI","abstract":[{"text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated.","type":"text"}],"url":"\/tutorials\/openaikit\/06-streaming-responses#Building-a-Streaming-UI","kind":"section"},"database-05-hybrid.swift":{"syntax":"swift","highlights":[{"line":2},{"line":4},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":51},{"line":52},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":64},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":84},{"line":85},{"line":87},{"line":88},{"line":89},{"line":90},{"line":91},{"line":92},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":105},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":148},{"line":149},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":187},{"line":188},{"line":189},{"line":190},{"line":191},{"line":192},{"line":193},{"line":194},{"line":195},{"line":197},{"line":200},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":214},{"line":215},{"line":216},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":247},{"line":249},{"line":250},{"line":251},{"line":253},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":284},{"line":285},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":301},{"line":302},{"line":303},{"line":304},{"line":305},{"line":307},{"line":308},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":319},{"line":320},{"line":321},{"line":322},{"line":323},{"line":324},{"line":328},{"line":331},{"line":332},{"line":333},{"line":334},{"line":335},{"line":336},{"line":337},{"line":338},{"line":339},{"line":340},{"line":342},{"line":343},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":352},{"line":353},{"line":354},{"line":355},{"line":356},{"line":357},{"line":358},{"line":359},{"line":360},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":366},{"line":367},{"line":368},{"line":369},{"line":372},{"line":375},{"line":376},{"line":377},{"line":378},{"line":379},{"line":380},{"line":381},{"line":382},{"line":383},{"line":384},{"line":386},{"line":387},{"line":389},{"line":390},{"line":391},{"line":392},{"line":393},{"line":394},{"line":395},{"line":397},{"line":398},{"line":399},{"line":400},{"line":401},{"line":402},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":408},{"line":409},{"line":410},{"line":411},{"line":412},{"line":413},{"line":414},{"line":415},{"line":418},{"line":419},{"line":420},{"line":423},{"line":425},{"line":426},{"line":428},{"line":429},{"line":430},{"line":432},{"line":433},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":444},{"line":445},{"line":448},{"line":449},{"line":452},{"line":453},{"line":454},{"line":455},{"line":456},{"line":457},{"line":458},{"line":459},{"line":461},{"line":462},{"line":463},{"line":464},{"line":465},{"line":466},{"line":467},{"line":468},{"line":469},{"line":470},{"line":471},{"line":472},{"line":473},{"line":474},{"line":475},{"line":476},{"line":477},{"line":478},{"line":479},{"line":480},{"line":481},{"line":482},{"line":485},{"line":488},{"line":489},{"line":490},{"line":491},{"line":492},{"line":493},{"line":494},{"line":495},{"line":497},{"line":499},{"line":500},{"line":501},{"line":504},{"line":505},{"line":506},{"line":507},{"line":508},{"line":509},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":518},{"line":522},{"line":524},{"line":525},{"line":526},{"line":527},{"line":528},{"line":529},{"line":530},{"line":532},{"line":533},{"line":534},{"line":535},{"line":538},{"line":539},{"line":540},{"line":541},{"line":542},{"line":544},{"line":545},{"line":546},{"line":547},{"line":548},{"line":549},{"line":550},{"line":551},{"line":552},{"line":554},{"line":555},{"line":556},{"line":557},{"line":558},{"line":559},{"line":560},{"line":561},{"line":562},{"line":563},{"line":564},{"line":565},{"line":566},{"line":567},{"line":570},{"line":571},{"line":572},{"line":573},{"line":574},{"line":575},{"line":576},{"line":577},{"line":579},{"line":580},{"line":581},{"line":584},{"line":585},{"line":586},{"line":587},{"line":588},{"line":592},{"line":593},{"line":594},{"line":596},{"line":597},{"line":599},{"line":600},{"line":601},{"line":602},{"line":603},{"line":604},{"line":608},{"line":609},{"line":611},{"line":612},{"line":613},{"line":614},{"line":615},{"line":616},{"line":618},{"line":619},{"line":622},{"line":623},{"line":624},{"line":626},{"line":627},{"line":628},{"line":630},{"line":631},{"line":632},{"line":633},{"line":634},{"line":635},{"line":641},{"line":643},{"line":644},{"line":645},{"line":646},{"line":647},{"line":648},{"line":649},{"line":650},{"line":653},{"line":654},{"line":655},{"line":656},{"line":657},{"line":658},{"line":661},{"line":662},{"line":663},{"line":664},{"line":665},{"line":666},{"line":667},{"line":668},{"line":669},{"line":670},{"line":671},{"line":672},{"line":673},{"line":674},{"line":675},{"line":676},{"line":677},{"line":678},{"line":679},{"line":681},{"line":682},{"line":683},{"line":684},{"line":687},{"line":688},{"line":689},{"line":690},{"line":691},{"line":693},{"line":694},{"line":695},{"line":696},{"line":697},{"line":698},{"line":699},{"line":700},{"line":701},{"line":702},{"line":703},{"line":704},{"line":705},{"line":706},{"line":707},{"line":708},{"line":709},{"line":710},{"line":711},{"line":712},{"line":713},{"line":714},{"line":715}],"fileName":"VectorDatabase.swift","fileType":"swift","type":"file","identifier":"database-05-hybrid.swift","content":["import Foundation","import NaturalLanguage","","\/\/ MARK: - Hybrid Search Engine","","\/\/\/ Combines semantic search with text-based search for improved results","class HybridSearchEngine {","    private let vectorDatabase: VectorDatabase","    private let textSearchEngine: TextSearchEngine","    private let embeddingGenerator: EmbeddingGenerator","    private let knnEngine: KNNSearchEngine","    private let queue = DispatchQueue(label: \"hybridsearch\", attributes: .concurrent)","    ","    \/\/ Search configuration","    struct SearchConfig {","        let semanticWeight: Float  \/\/ 0.0 to 1.0","        let textWeight: Float      \/\/ 0.0 to 1.0","        let reranking: RerankingStrategy","        let minConfidence: Float","        let boostFactors: BoostFactors","        ","        struct BoostFactors {","            let recency: Float      \/\/ Boost recent documents","            let popularity: Float   \/\/ Boost frequently accessed","            let exactMatch: Float   \/\/ Boost exact phrase matches","            let fieldMatch: Float   \/\/ Boost matches in specific fields","        }","        ","        enum RerankingStrategy {","            case reciprocalRankFusion","            case linearCombination","            case learned(model: RerankingModel)","            case crossEncoder","        }","        ","        static let `default` = SearchConfig(","            semanticWeight: 0.6,","            textWeight: 0.4,","            reranking: .reciprocalRankFusion,","            minConfidence: 0.3,","            boostFactors: BoostFactors(","                recency: 1.2,","                popularity: 1.1,","                exactMatch: 2.0,","                fieldMatch: 1.5","            )","        )","    }","    ","    init(","        vectorDatabase: VectorDatabase,","        dimension: Int","    ) {","        self.vectorDatabase = vectorDatabase","        self.textSearchEngine = TextSearchEngine()","        self.embeddingGenerator = EmbeddingGenerator()","        self.knnEngine = KNNSearchEngine(","            dimension: dimension,","            metric: .cosine,","            algorithm: .approximateNearestNeighbor(numTrees: 10)","        )","    }","    ","    \/\/ MARK: - Hybrid Search","    ","    func search(","        query: String,","        limit: Int = 10,","        filters: SearchFilters? = nil,","        config: SearchConfig = .default","    ) async throws -> [HybridSearchResult] {","        \/\/ Generate query embedding for semantic search","        let queryEmbedding = try await embeddingGenerator.generateEmbedding(for: query)","        ","        \/\/ Perform parallel searches","        async let semanticResults = performSemanticSearch(","            embedding: queryEmbedding,","            limit: limit * 3,  \/\/ Get more candidates for reranking","            filters: filters","        )","        ","        async let textResults = performTextSearch(","            query: query,","            limit: limit * 3,","            filters: filters","        )","        ","        \/\/ Wait for both results","        let (semantic, text) = try await (semanticResults, textResults)","        ","        \/\/ Combine and rerank results","        let combinedResults = await combineResults(","            semantic: semantic,","            text: text,","            query: query,","            queryEmbedding: queryEmbedding,","            config: config","        )","        ","        \/\/ Apply final filtering and limit","        let filtered = combinedResults.filter { $0.confidence >= config.minConfidence }","        return Array(filtered.prefix(limit))","    }","    ","    \/\/ MARK: - Semantic Search","    ","    private func performSemanticSearch(","        embedding: [Float],","        limit: Int,","        filters: SearchFilters?","    ) async throws -> [SemanticSearchResult] {","        \/\/ Use vector database for similarity search","        let vectorQuery = VectorQuery(","            vector: embedding,","            limit: limit,","            threshold: 0.0,  \/\/ Get all results, filter later","            collection: filters?.collection,","            filter: filters?.predicate","        )","        ","        let results = try await vectorDatabase.search(query: vectorQuery)","        ","        return results.map { result in","            SemanticSearchResult(","                id: result.id,","                content: result.content,","                similarity: result.similarity,","                embedding: result.embedding,","                metadata: result.metadata","            )","        }","    }","    ","    \/\/ MARK: - Text Search","    ","    private func performTextSearch(","        query: String,","        limit: Int,","        filters: SearchFilters?","    ) async -> [TextSearchResult] {","        await textSearchEngine.search(","            query: query,","            limit: limit,","            filters: filters","        )","    }","    ","    \/\/ MARK: - Result Combination","    ","    private func combineResults(","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        query: String,","        queryEmbedding: [Float],","        config: SearchConfig","    ) async -> [HybridSearchResult] {","        var combinedScores: [String: HybridScore] = [:]","        ","        \/\/ Process semantic results","        for (rank, result) in semantic.enumerated() {","            let score = HybridScore(","                semanticScore: result.similarity,","                semanticRank: rank + 1,","                textScore: 0,","                textRank: Int.max","            )","            combinedScores[result.id] = score","        }","        ","        \/\/ Process text results","        for (rank, result) in text.enumerated() {","            if var score = combinedScores[result.id] {","                score.textScore = result.relevance","                score.textRank = rank + 1","                combinedScores[result.id] = score","            } else {","                let score = HybridScore(","                    semanticScore: 0,","                    semanticRank: Int.max,","                    textScore: result.relevance,","                    textRank: rank + 1","                )","                combinedScores[result.id] = score","            }","        }","        ","        \/\/ Apply reranking strategy","        let rerankedResults = await applyReranking(","            scores: combinedScores,","            semantic: semantic,","            text: text,","            query: query,","            queryEmbedding: queryEmbedding,","            config: config","        )","        ","        return rerankedResults","    }","    ","    \/\/ MARK: - Reranking Strategies","    ","    private func applyReranking(","        scores: [String: HybridScore],","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        query: String,","        queryEmbedding: [Float],","        config: SearchConfig","    ) async -> [HybridSearchResult] {","        switch config.reranking {","        case .reciprocalRankFusion:","            return applyRRF(scores: scores, semantic: semantic, text: text, config: config)","            ","        case .linearCombination:","            return applyLinearCombination(scores: scores, semantic: semantic, text: text, config: config)","            ","        case .learned(let model):","            return await applyLearnedReranking(","                scores: scores,","                semantic: semantic,","                text: text,","                query: query,","                model: model,","                config: config","            )","            ","        case .crossEncoder:","            return await applyCrossEncoderReranking(","                scores: scores,","                semantic: semantic,","                text: text,","                query: query,","                queryEmbedding: queryEmbedding,","                config: config","            )","        }","    }","    ","    private func applyRRF(","        scores: [String: HybridScore],","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        config: SearchConfig","    ) -> [HybridSearchResult] {","        let k = 60.0  \/\/ RRF constant","        ","        var results: [HybridSearchResult] = []","        ","        \/\/ Create result lookup maps","        let semanticMap = Dictionary(uniqueKeysWithValues: semantic.map { ($0.id, $0) })","        let textMap = Dictionary(uniqueKeysWithValues: text.map { ($0.id, $0) })","        ","        for (id, score) in scores {","            let semanticRRF = config.semanticWeight \/ (k + Double(score.semanticRank))","            let textRRF = config.textWeight \/ (k + Double(score.textRank))","            let combinedScore = Float(semanticRRF + textRRF)","            ","            \/\/ Get content and metadata from available results","            let content = semanticMap[id]?.content ?? textMap[id]?.content ?? \"\"","            let metadata = semanticMap[id]?.metadata ?? textMap[id]?.metadata","            ","            \/\/ Apply boost factors","            var boostedScore = combinedScore","            ","            if let metadata = metadata {","                \/\/ Recency boost","                if let timestamp = metadata[\"timestamp\"] as? Date {","                    let age = Date().timeIntervalSince(timestamp)","                    let recencyFactor = exp(-age \/ (30 * 24 * 3600))  \/\/ Decay over 30 days","                    boostedScore *= config.boostFactors.recency * Float(recencyFactor)","                }","                ","                \/\/ Popularity boost","                if let accessCount = metadata[\"accessCount\"] as? Int {","                    let popularityFactor = log(Double(accessCount + 1)) \/ log(10.0)","                    boostedScore *= config.boostFactors.popularity * Float(popularityFactor)","                }","            }","            ","            \/\/ Exact match boost","            if content.lowercased().contains(query.lowercased()) {","                boostedScore *= config.boostFactors.exactMatch","            }","            ","            results.append(HybridSearchResult(","                id: id,","                content: content,","                confidence: boostedScore,","                semanticScore: score.semanticScore,","                textScore: score.textScore,","                metadata: metadata,","                highlights: extractHighlights(from: content, query: query)","            ))","        }","        ","        return results.sorted { $0.confidence > $1.confidence }","    }","    ","    private func applyLinearCombination(","        scores: [String: HybridScore],","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        config: SearchConfig","    ) -> [HybridSearchResult] {","        var results: [HybridSearchResult] = []","        ","        let semanticMap = Dictionary(uniqueKeysWithValues: semantic.map { ($0.id, $0) })","        let textMap = Dictionary(uniqueKeysWithValues: text.map { ($0.id, $0) })","        ","        for (id, score) in scores {","            let combinedScore = config.semanticWeight * score.semanticScore +","                               config.textWeight * score.textScore","            ","            let content = semanticMap[id]?.content ?? textMap[id]?.content ?? \"\"","            let metadata = semanticMap[id]?.metadata ?? textMap[id]?.metadata","            ","            results.append(HybridSearchResult(","                id: id,","                content: content,","                confidence: combinedScore,","                semanticScore: score.semanticScore,","                textScore: score.textScore,","                metadata: metadata,","                highlights: extractHighlights(from: content, query: query)","            ))","        }","        ","        return results.sorted { $0.confidence > $1.confidence }","    }","    ","    private func applyLearnedReranking(","        scores: [String: HybridScore],","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        query: String,","        model: RerankingModel,","        config: SearchConfig","    ) async -> [HybridSearchResult] {","        \/\/ Use a learned model to rerank results","        var results: [HybridSearchResult] = []","        ","        let semanticMap = Dictionary(uniqueKeysWithValues: semantic.map { ($0.id, $0) })","        let textMap = Dictionary(uniqueKeysWithValues: text.map { ($0.id, $0) })","        ","        for (id, score) in scores {","            let content = semanticMap[id]?.content ?? textMap[id]?.content ?? \"\"","            let metadata = semanticMap[id]?.metadata ?? textMap[id]?.metadata","            ","            \/\/ Extract features for the model","            let features = extractFeatures(","                query: query,","                content: content,","                semanticScore: score.semanticScore,","                textScore: score.textScore,","                metadata: metadata","            )","            ","            \/\/ Get model prediction","            let modelScore = await model.predict(features: features)","            ","            results.append(HybridSearchResult(","                id: id,","                content: content,","                confidence: modelScore,","                semanticScore: score.semanticScore,","                textScore: score.textScore,","                metadata: metadata,","                highlights: extractHighlights(from: content, query: query)","            ))","        }","        ","        return results.sorted { $0.confidence > $1.confidence }","    }","    ","    private func applyCrossEncoderReranking(","        scores: [String: HybridScore],","        semantic: [SemanticSearchResult],","        text: [TextSearchResult],","        query: String,","        queryEmbedding: [Float],","        config: SearchConfig","    ) async -> [HybridSearchResult] {","        \/\/ Cross-encoder reranking for highest accuracy","        var results: [HybridSearchResult] = []","        ","        let semanticMap = Dictionary(uniqueKeysWithValues: semantic.map { ($0.id, $0) })","        let textMap = Dictionary(uniqueKeysWithValues: text.map { ($0.id, $0) })","        ","        \/\/ Process in batches for efficiency","        let batchSize = 10","        var processedResults: [(id: String, result: HybridSearchResult)] = []","        ","        for (id, score) in scores {","            let content = semanticMap[id]?.content ?? textMap[id]?.content ?? \"\"","            let metadata = semanticMap[id]?.metadata ?? textMap[id]?.metadata","            ","            \/\/ Generate cross-encoder features","            let crossScore = await computeCrossEncoderScore(","                query: query,","                queryEmbedding: queryEmbedding,","                content: content,","                contentEmbedding: semanticMap[id]?.embedding","            )","            ","            let result = HybridSearchResult(","                id: id,","                content: content,","                confidence: crossScore,","                semanticScore: score.semanticScore,","                textScore: score.textScore,","                metadata: metadata,","                highlights: extractHighlights(from: content, query: query)","            )","            ","            processedResults.append((id, result))","        }","        ","        return processedResults","            .sorted { $0.result.confidence > $1.result.confidence }","            .map { $0.result }","    }","    ","    \/\/ MARK: - Helper Methods","    ","    private func extractHighlights(from content: String, query: String) -> [TextHighlight] {","        var highlights: [TextHighlight] = []","        ","        \/\/ Tokenize query and content","        let queryTokens = query.lowercased().split(separator: \" \").map(String.init)","        let contentLower = content.lowercased()","        ","        for token in queryTokens {","            var searchRange = contentLower.startIndex..<contentLower.endIndex","            ","            while let range = contentLower.range(of: token, options: [], range: searchRange) {","                let startOffset = contentLower.distance(from: contentLower.startIndex, to: range.lowerBound)","                let endOffset = contentLower.distance(from: contentLower.startIndex, to: range.upperBound)","                ","                highlights.append(TextHighlight(","                    startOffset: startOffset,","                    endOffset: endOffset,","                    score: 1.0","                ))","                ","                searchRange = range.upperBound..<contentLower.endIndex","            }","        }","        ","        return highlights","    }","    ","    private func extractFeatures(","        query: String,","        content: String,","        semanticScore: Float,","        textScore: Float,","        metadata: [String: Any]?","    ) -> [Float] {","        var features: [Float] = []","        ","        \/\/ Basic scores","        features.append(semanticScore)","        features.append(textScore)","        ","        \/\/ Length features","        features.append(Float(query.count))","        features.append(Float(content.count))","        features.append(Float(content.count) \/ Float(query.count))","        ","        \/\/ Term overlap","        let queryTerms = Set(query.lowercased().split(separator: \" \"))","        let contentTerms = Set(content.lowercased().split(separator: \" \"))","        let overlap = Float(queryTerms.intersection(contentTerms).count) \/ Float(queryTerms.count)","        features.append(overlap)","        ","        \/\/ Metadata features","        if let metadata = metadata {","            features.append(Float(metadata[\"accessCount\"] as? Int ?? 0))","            features.append(Float(metadata[\"rating\"] as? Double ?? 0.0))","        } else {","            features.append(0)","            features.append(0)","        }","        ","        return features","    }","    ","    private func computeCrossEncoderScore(","        query: String,","        queryEmbedding: [Float],","        content: String,","        contentEmbedding: [Float]?","    ) async -> Float {","        \/\/ Simplified cross-encoder score computation","        \/\/ In practice, this would use a neural network model","        ","        var score: Float = 0.0","        ","        \/\/ Semantic similarity if embedding available","        if let contentEmbedding = contentEmbedding {","            score += SimilarityCalculator.cosineSimilarity(queryEmbedding, contentEmbedding) * 0.5","        }","        ","        \/\/ Lexical similarity","        let queryTerms = Set(query.lowercased().split(separator: \" \"))","        let contentTerms = Set(content.lowercased().split(separator: \" \"))","        let jaccard = Float(queryTerms.intersection(contentTerms).count) \/","                     Float(queryTerms.union(contentTerms).count)","        score += jaccard * 0.3","        ","        \/\/ Position bonus for early matches","        if let firstMatch = content.lowercased().range(of: query.lowercased()) {","            let position = content.distance(from: content.startIndex, to: firstMatch.lowerBound)","            let positionScore = 1.0 - Float(position) \/ Float(content.count)","            score += positionScore * 0.2","        }","        ","        return score","    }","}","","\/\/ MARK: - Text Search Engine","","class TextSearchEngine {","    private let tokenizer = NLTokenizer(unit: .word)","    private var invertedIndex: [String: Set<String>] = [:]","    private var documentFrequency: [String: Int] = [:]","    private var documents: [String: IndexedDocument] = [:]","    ","    struct IndexedDocument {","        let id: String","        let content: String","        let tokens: [String]","        let termFrequency: [String: Int]","        let metadata: [String: Any]?","    }","    ","    func indexDocument(id: String, content: String, metadata: [String: Any]? = nil) {","        \/\/ Tokenize content","        tokenizer.string = content","        var tokens: [String] = []","        var termFreq: [String: Int] = [:]","        ","        tokenizer.enumerateTokens(in: content.startIndex..<content.endIndex) { range, _ in","            let token = String(content[range]).lowercased()","            tokens.append(token)","            termFreq[token, default: 0] += 1","            ","            \/\/ Update inverted index","            invertedIndex[token, default: Set()].insert(id)","            ","            return true","        }","        ","        \/\/ Update document frequency","        for token in Set(tokens) {","            documentFrequency[token, default: 0] += 1","        }","        ","        \/\/ Store document","        documents[id] = IndexedDocument(","            id: id,","            content: content,","            tokens: tokens,","            termFrequency: termFreq,","            metadata: metadata","        )","    }","    ","    func search(","        query: String,","        limit: Int,","        filters: SearchFilters?","    ) async -> [TextSearchResult] {","        \/\/ Tokenize query","        tokenizer.string = query","        var queryTokens: [String] = []","        ","        tokenizer.enumerateTokens(in: query.startIndex..<query.endIndex) { range, _ in","            queryTokens.append(String(query[range]).lowercased())","            return true","        }","        ","        \/\/ Find candidate documents","        var candidates = Set<String>()","        for token in queryTokens {","            if let docs = invertedIndex[token] {","                candidates.formUnion(docs)","            }","        }","        ","        \/\/ Score documents using TF-IDF","        var scores: [(id: String, score: Float)] = []","        let totalDocs = documents.count","        ","        for docId in candidates {","            guard let doc = documents[docId] else { continue }","            ","            \/\/ Apply filters","            if let filters = filters {","                if let collection = filters.collection,","                   let docCollection = doc.metadata?[\"collection\"] as? String,","                   collection != docCollection {","                    continue","                }","            }","            ","            \/\/ Calculate TF-IDF score","            var score: Float = 0.0","            ","            for queryToken in queryTokens {","                let tf = Float(doc.termFrequency[queryToken] ?? 0) \/ Float(doc.tokens.count)","                let df = Float(documentFrequency[queryToken] ?? 0)","                let idf = log(Float(totalDocs) \/ (df + 1.0))","                ","                score += tf * idf","            }","            ","            scores.append((id: docId, score: score))","        }","        ","        \/\/ Sort by score and limit","        scores.sort { $0.score > $1.score }","        let topResults = Array(scores.prefix(limit))","        ","        \/\/ Convert to results","        return topResults.compactMap { result in","            guard let doc = documents[result.id] else { return nil }","            ","            return TextSearchResult(","                id: doc.id,","                content: doc.content,","                relevance: result.score,","                metadata: doc.metadata,","                matchedTerms: Set(queryTokens).intersection(Set(doc.tokens))","            )","        }","    }","}","","\/\/ MARK: - Models","","struct HybridSearchResult {","    let id: String","    let content: String","    let confidence: Float","    let semanticScore: Float","    let textScore: Float","    let metadata: [String: Any]?","    let highlights: [TextHighlight]","}","","struct SemanticSearchResult {","    let id: String","    let content: String","    let similarity: Float","    let embedding: [Float]","    let metadata: [String: Any]?","}","","struct TextSearchResult {","    let id: String","    let content: String","    let relevance: Float","    let metadata: [String: Any]?","    let matchedTerms: Set<String>","}","","struct TextHighlight {","    let startOffset: Int","    let endOffset: Int","    let score: Float","}","","struct SearchFilters {","    let collection: String?","    let predicate: NSPredicate?","    let dateRange: DateRange?","    let tags: Set<String>?","    ","    struct DateRange {","        let start: Date","        let end: Date","    }","}","","struct HybridScore {","    var semanticScore: Float","    var semanticRank: Int","    var textScore: Float","    var textRank: Int","}","","\/\/ MARK: - Placeholder Types","","class EmbeddingGenerator {","    func generateEmbedding(for text: String) async throws -> [Float] {","        \/\/ Placeholder - would call OpenAI API","        return Array(repeating: 0.0, count: 1536)","    }","}","","class RerankingModel {","    func predict(features: [Float]) async -> Float {","        \/\/ Placeholder - would use trained model","        return features.reduce(0, +) \/ Float(features.count)","    }","}","","class SimilarityCalculator {","    static func cosineSimilarity(_ a: [Float], _ b: [Float]) -> Float {","        \/\/ Placeholder - would use optimized implementation","        return 0.5","    }","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors#Understanding-OpenAIKit-Errors":{"title":"Understanding OpenAIKit Errors","abstract":[{"type":"text","text":"Learn how to gracefully handle errors and edge cases when working with the OpenAI API."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Understanding-OpenAIKit-Errors","url":"\/tutorials\/openaikit\/04-handling-errors#Understanding-OpenAIKit-Errors"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Advanced-Techniques":{"title":"Advanced Techniques","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Advanced-Techniques","url":"\/tutorials\/openaikit\/09-building-semantic-search#Advanced-Techniques"},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors#Building-a-Robust-Error-Handler":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#Building-a-Robust-Error-Handler","type":"section","role":"pseudoSymbol","title":"Building a Robust Error Handler","abstract":[{"type":"text","text":"Learn how to gracefully handle errors and edge cases when working with the OpenAI API."}],"url":"\/tutorials\/openaikit\/04-handling-errors#Building-a-Robust-Error-Handler","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/07-Generating-Images#Understanding-Image-Models":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/07-Generating-Images#Understanding-Image-Models","role":"pseudoSymbol","title":"Understanding Image Models","abstract":[{"type":"text","text":"Master image generation using DALL-E 2, DALL-E 3, and the advanced GPT Image 1 model. Learn to select the right model, handle errors professionally, and build production-ready image generation features."}],"url":"\/tutorials\/openaikit\/07-generating-images#Understanding-Image-Models","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Best-Practices-for-Research-Prompting":{"title":"Best Practices for Research Prompting","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Best-Practices-for-Research-Prompting","url":"\/tutorials\/openaikit\/09-deep-research-analysis#Best-Practices-for-Research-Prompting"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Check-Your-Understanding":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Check-Your-Understanding","titleInlineContent":[{"text":"Check Your Understanding","type":"text"}],"url":"\/tutorials\/openaikit\/03-working-with-functions#Check-Your-Understanding","title":"Check Your Understanding","type":"link"},"embeddings-04-response.swift":{"fileName":"EmbeddingGenerator.swift","fileType":"swift","identifier":"embeddings-04-response.swift","highlights":[{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41}],"content":["\/\/ EmbeddingGenerator.swift","import Foundation","import OpenAIKit","","class EmbeddingGenerator {","    let openAI = OpenAIManager.shared.client","    ","    func generateEmbedding(for text: String) async throws -> [Float] {","        guard let openAI = openAI else {","            throw OpenAIError.missingAPIKey","        }","        ","        let request = EmbeddingRequest(","            input: text,","            model: Models.Embeddings.textEmbedding3Small,","            dimensions: nil,","            encodingFormat: .float,","            user: nil","        )","        ","        let response = try await openAI.embeddings.create(request)","        ","        guard let embedding = response.data.first?.embedding,","              let floatValues = embedding.floatValues else {","            throw EmbeddingError.noEmbeddingGenerated","        }","        ","        return floatValues","    }","}","","enum EmbeddingError: LocalizedError {","    case noEmbeddingGenerated","    ","    var errorDescription: String? {","        switch self {","        case .noEmbeddingGenerated:","            return \"No embedding was generated\"","        }","    }","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/01-Setting-Up-OpenAIKit#Set-Environment-Variables":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/01-Setting-Up-OpenAIKit#Set-Environment-Variables","type":"section","role":"pseudoSymbol","title":"Set Environment Variables","abstract":[{"type":"text","text":"Configure OpenAIKit in your Swift project and authenticate with the OpenAI API."}],"url":"\/tutorials\/openaikit\/01-setting-up-openaikit#Set-Environment-Variables","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Web-Search-Research":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Web-Search-Research","role":"pseudoSymbol","title":"Web Search Research","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"url":"\/tutorials\/openaikit\/09-deep-research-analysis#Web-Search-Research","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Handling-Large-Audio-Files":{"title":"Handling Large Audio Files","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Handling-Large-Audio-Files","url":"\/tutorials\/openaikit\/08-transcribing-audio#Handling-Large-Audio-Files"},"doc://OpenAIKit/tutorials/OpenAIKit/06-Streaming-Responses#Cross-Platform-Streaming":{"title":"Cross-Platform Streaming","abstract":[{"type":"text","text":"Implement real-time streaming to create responsive chat experiences that display responses as they’re generated."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/06-Streaming-Responses#Cross-Platform-Streaming","url":"\/tutorials\/openaikit\/06-streaming-responses#Cross-Platform-Streaming"},"doc://OpenAIKit/tutorials/OpenAIKit/07-Generating-Images":{"title":"Generating Images with AI","abstract":[{"type":"text","text":"Master image generation using DALL-E 2, DALL-E 3, and the advanced GPT Image 1 model. Learn to select the right model, handle errors professionally, and build production-ready image generation features."}],"role":"project","kind":"project","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/07-Generating-Images","url":"\/tutorials\/openaikit\/07-generating-images","estimatedTime":"25min"},"doc://OpenAIKit/tutorials/OpenAIKit/04-Handling-Errors#User-Friendly-Error-Messages":{"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/04-Handling-Errors#User-Friendly-Error-Messages","type":"section","role":"pseudoSymbol","title":"User-Friendly Error Messages","abstract":[{"type":"text","text":"Learn how to gracefully handle errors and edge cases when working with the OpenAI API."}],"url":"\/tutorials\/openaikit\/04-handling-errors#User-Friendly-Error-Messages","kind":"section"},"engine-02-index.swift":{"syntax":"swift","highlights":[{"line":4},{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":11},{"line":12},{"line":13},{"line":14},{"line":16},{"line":17},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":35},{"line":36},{"line":37},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":81},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":91},{"line":92},{"line":93},{"line":94},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":113},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138}],"fileName":"SemanticSearchEngine.swift","fileType":"swift","type":"file","identifier":"engine-02-index.swift","content":["import Foundation","import OpenAIKit","","extension SemanticSearchEngine {","    \/\/\/ Build or rebuild the search index","    func buildIndex(from documents: [SearchDocument]) async throws {","        \/\/ Clear existing data","        self.documents.removeAll()","        self.embeddings.removeAll()","        ","        \/\/ Process documents in batches for efficiency","        let batchSize = 10","        for batch in documents.chunked(into: batchSize) {","            try await processBatch(batch)","        }","        ","        print(\"Index built with \\(documents.count) documents\")","    }","    ","    \/\/\/ Process a batch of documents","    private func processBatch(_ batch: [SearchDocument]) async throws {","        \/\/ Generate embeddings concurrently","        try await withThrowingTaskGroup(of: (String, [Double]).self) { group in","            for document in batch {","                group.addTask {","                    let text = self.preprocessText(document)","                    let embedding = try await self.generateEmbedding(for: text)","                    return (document.id, embedding)","                }","                self.documents.append(document)","            }","            ","            \/\/ Collect results","            for try await (docId, embedding) in group {","                self.embeddings[docId] = embedding","            }","        }","    }","    ","    \/\/\/ Preprocess text for better embedding quality","    private func preprocessText(_ document: SearchDocument) -> String {","        \/\/ Combine title and content with proper weighting","        let titleWeight = 2.0 \/\/ Title is more important","        let weightedTitle = Array(repeating: document.title, count: Int(titleWeight))","            .joined(separator: \" \")","        ","        \/\/ Clean and normalize text","        let cleanedContent = document.content","            .replacingOccurrences(of: \"\\n+\", with: \" \", options: .regularExpression)","            .trimmingCharacters(in: .whitespacesAndNewlines)","        ","        return \"\\(weightedTitle) \\(cleanedContent)\"","    }","    ","    \/\/\/ Update a single document in the index","    func updateDocument(_ documentId: String, newContent: String) async throws {","        guard let index = documents.firstIndex(where: { $0.id == documentId }) else {","            throw SearchError.documentNotFound","        }","        ","        \/\/ Update document","        var updatedDoc = documents[index]","        updatedDoc = SearchDocument(","            title: updatedDoc.title,","            content: newContent,","            metadata: updatedDoc.metadata","        )","        documents[index] = updatedDoc","        ","        \/\/ Update embedding","        let text = preprocessText(updatedDoc)","        embeddings[documentId] = try await generateEmbedding(for: text)","    }","    ","    \/\/\/ Remove a document from the index","    func removeDocument(_ documentId: String) {","        documents.removeAll { $0.id == documentId }","        embeddings.removeValue(forKey: documentId)","    }","    ","    \/\/\/ Get index statistics","    func getIndexStats() -> IndexStats {","        IndexStats(","            documentCount: documents.count,","            totalSize: embeddings.values.reduce(0) { $0 + $1.count * 8 }, \/\/ bytes","            averageDocumentLength: documents.isEmpty ? 0 :","                documents.map { $0.content.count }.reduce(0, +) \/ documents.count","        )","    }","    ","    struct IndexStats {","        let documentCount: Int","        let totalSize: Int","        let averageDocumentLength: Int","    }","    ","    enum SearchError: Error {","        case documentNotFound","        case indexNotBuilt","        case embeddingGenerationFailed","    }","}","","\/\/ Helper extension for array chunking","extension Array {","    func chunked(into size: Int) -> [[Element]] {","        return stride(from: 0, to: count, by: size).map {","            Array(self[$0..<Swift.min($0 + size, count)])","        }","    }","}","","\/\/ Example usage","Task {","    let engine = SemanticSearchEngine(apiKey: \"your-api-key\")","    ","    \/\/ Prepare documents","    let documents = [","        SemanticSearchEngine.SearchDocument(","            title: \"Swift Programming\",","            content: \"Swift is a powerful programming language for iOS development...\"","        ),","        SemanticSearchEngine.SearchDocument(","            title: \"SwiftUI Basics\",","            content: \"SwiftUI is a declarative framework for building user interfaces...\"","        ),","        SemanticSearchEngine.SearchDocument(","            title: \"Async\/Await in Swift\",","            content: \"Swift's async\/await syntax makes asynchronous programming easier...\"","        )","    ]","    ","    \/\/ Build index","    try await engine.buildIndex(from: documents)","    ","    \/\/ Get stats","    let stats = engine.getIndexStats()","    print(\"Index contains \\(stats.documentCount) documents\")","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion":{"type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion","role":"project","title":"Your First Chat Completion","abstract":[{"type":"text","text":"Make your first API call to generate text using OpenAI’s chat completion models."}],"estimatedTime":"15min","url":"\/tutorials\/openaikit\/02-your-first-chat-completion","kind":"project"},"similarity-05-threshold.swift":{"fileName":"VectorSimilarity.swift","fileType":"swift","identifier":"similarity-05-threshold.swift","highlights":[],"content":["import Foundation","","\/\/ MARK: - Similarity Threshold Manager","","class SimilarityThresholdManager {","    ","    \/\/ Dynamic threshold calculation based on data distribution","    func calculateDynamicThreshold(","        similarities: [Float],","        method: ThresholdMethod = .percentile(0.8)","    ) -> Float {","        guard !similarities.isEmpty else { return 0.5 }","        ","        let sorted = similarities.sorted(by: >)","        ","        switch method {","        case .percentile(let p):","            let index = Int(Float(sorted.count - 1) * p)","            return sorted[index]","            ","        case .mean:","            return similarities.reduce(0, +) \/ Float(similarities.count)","            ","        case .standardDeviation(let factor):","            let mean = similarities.reduce(0, +) \/ Float(similarities.count)","            let variance = similarities.map { pow($0 - mean, 2) }.reduce(0, +) \/ Float(similarities.count)","            let stdDev = sqrt(variance)","            return mean + (factor * stdDev)","            ","        case .elbow:","            return findElbowPoint(in: sorted)","            ","        case .otsu:","            return calculateOtsuThreshold(similarities)","            ","        case .adaptive(let context):","            return calculateAdaptiveThreshold(similarities: similarities, context: context)","        }","    }","    ","    \/\/ Multi-level thresholding for categorization","    func calculateMultiLevelThresholds(","        similarities: [Float],","        levels: Int = 3","    ) -> [ThresholdLevel] {","        guard levels > 0 && !similarities.isEmpty else { return [] }","        ","        let sorted = similarities.sorted(by: >)","        var thresholds: [ThresholdLevel] = []","        ","        \/\/ Calculate thresholds using quantiles","        for i in 0..<levels {","            let quantile = Float(i + 1) \/ Float(levels + 1)","            let index = Int(Float(sorted.count - 1) * (1 - quantile))","            let threshold = sorted[index]","            ","            let label: String","            let confidence: Float","            ","            switch i {","            case 0:","                label = \"High Similarity\"","                confidence = 0.9","            case 1:","                label = \"Medium Similarity\"","                confidence = 0.7","            case 2:","                label = \"Low Similarity\"","                confidence = 0.5","            default:","                label = \"Very Low Similarity\"","                confidence = 0.3","            }","            ","            thresholds.append(ThresholdLevel(","                threshold: threshold,","                label: label,","                confidence: confidence,","                color: ThresholdColor(for: confidence)","            ))","        }","        ","        return thresholds","    }","    ","    \/\/ Validate threshold effectiveness","    func validateThreshold(","        threshold: Float,","        testData: [(similarity: Float, isRelevant: Bool)]","    ) -> ThresholdValidation {","        var truePositives = 0","        var falsePositives = 0","        var trueNegatives = 0","        var falseNegatives = 0","        ","        for (similarity, isRelevant) in testData {","            let predicted = similarity >= threshold","            ","            if predicted && isRelevant {","                truePositives += 1","            } else if predicted && !isRelevant {","                falsePositives += 1","            } else if !predicted && !isRelevant {","                trueNegatives += 1","            } else {","                falseNegatives += 1","            }","        }","        ","        let precision = truePositives > 0 ?","            Float(truePositives) \/ Float(truePositives + falsePositives) : 0","        ","        let recall = truePositives + falseNegatives > 0 ?","            Float(truePositives) \/ Float(truePositives + falseNegatives) : 0","        ","        let f1Score = precision + recall > 0 ?","            2 * (precision * recall) \/ (precision + recall) : 0","        ","        let accuracy = Float(truePositives + trueNegatives) \/ Float(testData.count)","        ","        return ThresholdValidation(","            threshold: threshold,","            precision: precision,","            recall: recall,","            f1Score: f1Score,","            accuracy: accuracy,","            confusionMatrix: ConfusionMatrix(","                truePositives: truePositives,","                falsePositives: falsePositives,","                trueNegatives: trueNegatives,","                falseNegatives: falseNegatives","            )","        )","    }","    ","    \/\/ Optimize threshold for specific metric","    func optimizeThreshold(","        testData: [(similarity: Float, isRelevant: Bool)],","        optimizeFor: OptimizationMetric = .f1Score,","        searchRange: ClosedRange<Float> = 0...1,","        steps: Int = 100","    ) -> OptimalThreshold {","        var bestThreshold: Float = 0.5","        var bestScore: Float = 0","        var validations: [ThresholdValidation] = []","        ","        let stepSize = (searchRange.upperBound - searchRange.lowerBound) \/ Float(steps)","        ","        for i in 0...steps {","            let threshold = searchRange.lowerBound + Float(i) * stepSize","            let validation = validateThreshold(threshold: threshold, testData: testData)","            validations.append(validation)","            ","            let score: Float","            switch optimizeFor {","            case .precision:","                score = validation.precision","            case .recall:","                score = validation.recall","            case .f1Score:","                score = validation.f1Score","            case .accuracy:","                score = validation.accuracy","            case .custom(let scorer):","                score = scorer(validation)","            }","            ","            if score > bestScore {","                bestScore = score","                bestThreshold = threshold","            }","        }","        ","        return OptimalThreshold(","            value: bestThreshold,","            score: bestScore,","            metric: optimizeFor,","            validationCurve: validations","        )","    }","    ","    \/\/ Helper: Find elbow point in sorted similarities","    private func findElbowPoint(in sortedSimilarities: [Float]) -> Float {","        guard sortedSimilarities.count > 2 else {","            return sortedSimilarities.isEmpty ? 0.5 : sortedSimilarities[sortedSimilarities.count \/ 2]","        }","        ","        \/\/ Calculate line from first to last point","        let x1: Float = 0","        let y1 = sortedSimilarities.first!","        let x2 = Float(sortedSimilarities.count - 1)","        let y2 = sortedSimilarities.last!","        ","        \/\/ Find point with maximum distance to line","        var maxDistance: Float = 0","        var elbowIndex = 0","        ","        for (index, similarity) in sortedSimilarities.enumerated() {","            let x = Float(index)","            let y = similarity","            ","            \/\/ Distance from point to line","            let distance = abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1) \/","                          sqrt(pow(y2 - y1, 2) + pow(x2 - x1, 2))","            ","            if distance > maxDistance {","                maxDistance = distance","                elbowIndex = index","            }","        }","        ","        return sortedSimilarities[elbowIndex]","    }","    ","    \/\/ Helper: Otsu's method for threshold","    private func calculateOtsuThreshold(_ similarities: [Float]) -> Float {","        let histogram = createHistogram(similarities, bins: 100)","        var bestThreshold: Float = 0.5","        var maxVariance: Float = 0","        ","        for i in 1..<histogram.count {","            let threshold = Float(i) \/ Float(histogram.count)","            ","            \/\/ Calculate class weights and means","            var w0: Float = 0, w1: Float = 0","            var sum0: Float = 0, sum1: Float = 0","            ","            for (j, count) in histogram.enumerated() {","                let value = Float(j) \/ Float(histogram.count)","                if j < i {","                    w0 += Float(count)","                    sum0 += Float(count) * value","                } else {","                    w1 += Float(count)","                    sum1 += Float(count) * value","                }","            }","            ","            if w0 > 0 && w1 > 0 {","                let mean0 = sum0 \/ w0","                let mean1 = sum1 \/ w1","                let variance = w0 * w1 * pow(mean0 - mean1, 2)","                ","                if variance > maxVariance {","                    maxVariance = variance","                    bestThreshold = threshold","                }","            }","        }","        ","        return bestThreshold","    }","    ","    \/\/ Helper: Create histogram","    private func createHistogram(_ values: [Float], bins: Int) -> [Int] {","        var histogram = Array(repeating: 0, count: bins)","        ","        for value in values {","            let bin = Int(value * Float(bins - 1))","            histogram[min(bin, bins - 1)] += 1","        }","        ","        return histogram","    }","    ","    \/\/ Helper: Adaptive threshold based on context","    private func calculateAdaptiveThreshold(","        similarities: [Float],","        context: AdaptiveContext","    ) -> Float {","        let baseThreshold = calculateDynamicThreshold(similarities, method: .percentile(0.8))","        ","        var adjustedThreshold = baseThreshold","        ","        \/\/ Adjust based on query complexity","        adjustedThreshold *= context.queryComplexityFactor","        ","        \/\/ Adjust based on domain","        adjustedThreshold *= context.domainSpecificityFactor","        ","        \/\/ Adjust based on user feedback","        if let feedbackAdjustment = context.userFeedbackAdjustment {","            adjustedThreshold += feedbackAdjustment","        }","        ","        \/\/ Ensure within valid range","        return max(0, min(1, adjustedThreshold))","    }","}","","\/\/ MARK: - Models","","enum ThresholdMethod {","    case percentile(Float)","    case mean","    case standardDeviation(factor: Float)","    case elbow","    case otsu","    case adaptive(context: AdaptiveContext)","}","","struct ThresholdLevel {","    let threshold: Float","    let label: String","    let confidence: Float","    let color: ThresholdColor","    ","    func categorize(_ similarity: Float) -> Bool {","        similarity >= threshold","    }","}","","struct ThresholdColor {","    let red: Float","    let green: Float","    let blue: Float","    ","    static func color(for confidence: Float) -> ThresholdColor {","        if confidence > 0.8 {","            return ThresholdColor(red: 0, green: 0.8, blue: 0)","        } else if confidence > 0.6 {","            return ThresholdColor(red: 1, green: 0.8, blue: 0)","        } else {","            return ThresholdColor(red: 1, green: 0, blue: 0)","        }","    }","}","","struct ThresholdValidation {","    let threshold: Float","    let precision: Float","    let recall: Float","    let f1Score: Float","    let accuracy: Float","    let confusionMatrix: ConfusionMatrix","}","","struct ConfusionMatrix {","    let truePositives: Int","    let falsePositives: Int","    let trueNegatives: Int","    let falseNegatives: Int","    ","    var total: Int {","        truePositives + falsePositives + trueNegatives + falseNegatives","    }","}","","enum OptimizationMetric {","    case precision","    case recall","    case f1Score","    case accuracy","    case custom((ThresholdValidation) -> Float)","}","","struct OptimalThreshold {","    let value: Float","    let score: Float","    let metric: OptimizationMetric","    let validationCurve: [ThresholdValidation]","}","","struct AdaptiveContext {","    let queryComplexityFactor: Float","    let domainSpecificityFactor: Float","    let userFeedbackAdjustment: Float?","    let timeOfDay: Date?","    let userProfile: UserProfile?","}","","struct UserProfile {","    let preferredPrecision: Float","    let historicalThresholds: [Float]","}","","\/\/ MARK: - Threshold Recommender","","class ThresholdRecommender {","    private let manager = SimilarityThresholdManager()","    ","    func recommendThreshold(","        for useCase: UseCase,","        similarities: [Float],","        additionalContext: [String: Any]? = nil","    ) -> ThresholdRecommendation {","        let method: ThresholdMethod","        let rationale: String","        ","        switch useCase {","        case .duplicateDetection:","            method = .percentile(0.95)","            rationale = \"High threshold for duplicate detection to minimize false positives\"","            ","        case .similaritySearch:","            method = .percentile(0.8)","            rationale = \"Balanced threshold for general similarity search\"","            ","        case .clustering:","            method = .elbow","            rationale = \"Elbow method finds natural separation in data\"","            ","        case .recommendation:","            method = .standardDeviation(factor: 0.5)","            rationale = \"Include items within 0.5 standard deviations of mean similarity\"","            ","        case .anomalyDetection:","            method = .percentile(0.1)","            rationale = \"Low threshold to identify dissimilar\/anomalous items\"","        }","        ","        let threshold = manager.calculateDynamicThreshold(","            similarities: similarities,","            method: method","        )","        ","        return ThresholdRecommendation(","            value: threshold,","            method: method,","            useCase: useCase,","            rationale: rationale,","            confidence: calculateConfidence(for: useCase, dataSize: similarities.count)","        )","    }","    ","    private func calculateConfidence(for useCase: UseCase, dataSize: Int) -> Float {","        let baseConfidence: Float = 0.7","        let sizeBonus = min(Float(dataSize) \/ 1000, 0.2)","        ","        return min(baseConfidence + sizeBonus, 0.95)","    }","}","","enum UseCase {","    case duplicateDetection","    case similaritySearch","    case clustering","    case recommendation","    case anomalyDetection","}","","struct ThresholdRecommendation {","    let value: Float","    let method: ThresholdMethod","    let useCase: UseCase","    let rationale: String","    let confidence: Float","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Audio-Translation":{"title":"Audio Translation","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Audio-Translation","url":"\/tutorials\/openaikit\/08-transcribing-audio#Audio-Translation"},"doc://OpenAIKit/tutorials/OpenAIKit-Tutorials/Advanced-Research":{"type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Advanced-Research","role":"article","title":"Advanced Research","abstract":[],"url":"\/tutorials\/openaikit-tutorials\/advanced-research","kind":"article"},"doc://OpenAIKit/tutorials/OpenAIKit-Tutorials/Chat-Completions":{"title":"Chat Completions","abstract":[],"role":"article","kind":"article","type":"topic","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit-Tutorials\/Chat-Completions","url":"\/tutorials\/openaikit-tutorials\/chat-completions"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Building-a-Vector-Database":{"title":"Building a Vector Database","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Building-a-Vector-Database","url":"\/tutorials\/openaikit\/09-building-semantic-search#Building-a-Vector-Database"},"embeddings-03-request.swift":{"syntax":"swift","highlights":[{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21}],"fileName":"EmbeddingGenerator.swift","fileType":"swift","type":"file","identifier":"embeddings-03-request.swift","content":["\/\/ EmbeddingGenerator.swift","import Foundation","import OpenAIKit","","class EmbeddingGenerator {","    let openAI = OpenAIManager.shared.client","    ","    func generateEmbedding(for text: String) async throws -> [Float] {","        guard let openAI = openAI else {","            throw OpenAIError.missingAPIKey","        }","        ","        let request = EmbeddingRequest(","            input: text,","            model: Models.Embeddings.textEmbedding3Small,","            dimensions: nil,","            encodingFormat: .float,","            user: nil","        )","        ","        \/\/ Send request next","        return []","    }","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/09-Deep-Research-Analysis#Working-with-MCP-Servers":{"title":"Working with MCP Servers","abstract":[{"type":"text","text":"Leverage DeepResearch to perform comprehensive research with web search, code interpretation, and custom data sources."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Deep-Research-Analysis#Working-with-MCP-Servers","url":"\/tutorials\/openaikit\/09-deep-research-analysis#Working-with-MCP-Servers"},"database-04-knn.swift":{"fileName":"VectorDatabase.swift","fileType":"swift","identifier":"database-04-knn.swift","highlights":[{"line":2},{"line":4},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":11},{"line":12},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":20},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":27},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":33},{"line":34},{"line":36},{"line":37},{"line":38},{"line":42},{"line":43},{"line":46},{"line":47},{"line":50},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":68},{"line":69},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":82},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":100},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":123},{"line":125},{"line":126},{"line":127},{"line":128},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":134},{"line":135},{"line":136},{"line":137},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":145},{"line":146},{"line":147},{"line":148},{"line":149},{"line":150},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":163},{"line":164},{"line":165},{"line":166},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":190},{"line":191},{"line":193},{"line":194},{"line":195},{"line":196},{"line":197},{"line":198},{"line":199},{"line":200},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":208},{"line":209},{"line":210},{"line":211},{"line":212},{"line":213},{"line":217},{"line":218},{"line":219},{"line":220},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":231},{"line":232},{"line":233},{"line":234},{"line":235},{"line":236},{"line":237},{"line":238},{"line":239},{"line":240},{"line":241},{"line":242},{"line":243},{"line":244},{"line":245},{"line":246},{"line":247},{"line":250},{"line":251},{"line":252},{"line":253},{"line":254},{"line":255},{"line":256},{"line":257},{"line":258},{"line":259},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264},{"line":265},{"line":266},{"line":267},{"line":268},{"line":269},{"line":270},{"line":271},{"line":272},{"line":273},{"line":274},{"line":275},{"line":276},{"line":277},{"line":278},{"line":279},{"line":280},{"line":281},{"line":282},{"line":283},{"line":286},{"line":287},{"line":288},{"line":289},{"line":290},{"line":291},{"line":292},{"line":293},{"line":294},{"line":295},{"line":296},{"line":297},{"line":298},{"line":299},{"line":300},{"line":304},{"line":305},{"line":306},{"line":307},{"line":308},{"line":309},{"line":310},{"line":311},{"line":312},{"line":313},{"line":314},{"line":315},{"line":316},{"line":317},{"line":318},{"line":321},{"line":322},{"line":323},{"line":324},{"line":325},{"line":326},{"line":327},{"line":329},{"line":330},{"line":331},{"line":333},{"line":334},{"line":335},{"line":336},{"line":337},{"line":338},{"line":339},{"line":341},{"line":342},{"line":345},{"line":346},{"line":347},{"line":348},{"line":349},{"line":350},{"line":351},{"line":353},{"line":354},{"line":355},{"line":358},{"line":359},{"line":361},{"line":362},{"line":363},{"line":364},{"line":365},{"line":366},{"line":367},{"line":368},{"line":369},{"line":371},{"line":372},{"line":373},{"line":375},{"line":376},{"line":377},{"line":378},{"line":379},{"line":380},{"line":381},{"line":382},{"line":384},{"line":385},{"line":386},{"line":387},{"line":388},{"line":389},{"line":390},{"line":391},{"line":392},{"line":394},{"line":395},{"line":396},{"line":397},{"line":400},{"line":401},{"line":402},{"line":403},{"line":404},{"line":405},{"line":406},{"line":407},{"line":408},{"line":410},{"line":414},{"line":415},{"line":417},{"line":418},{"line":419},{"line":420},{"line":421},{"line":424},{"line":427},{"line":428},{"line":429},{"line":430},{"line":431},{"line":432},{"line":433},{"line":435},{"line":436},{"line":437},{"line":438},{"line":439},{"line":440},{"line":441},{"line":442},{"line":443},{"line":444},{"line":445},{"line":446},{"line":447},{"line":448},{"line":449},{"line":450},{"line":451},{"line":452},{"line":455},{"line":456},{"line":457},{"line":458},{"line":460},{"line":461},{"line":462},{"line":463},{"line":464},{"line":465},{"line":466},{"line":467},{"line":468},{"line":472},{"line":474},{"line":475},{"line":476},{"line":477},{"line":478},{"line":481},{"line":482},{"line":483},{"line":484},{"line":485},{"line":487},{"line":488},{"line":489},{"line":490},{"line":491},{"line":492},{"line":493},{"line":494},{"line":495},{"line":496},{"line":499},{"line":500},{"line":501},{"line":502},{"line":504},{"line":505},{"line":507},{"line":508},{"line":509},{"line":510},{"line":511},{"line":512},{"line":513},{"line":514},{"line":515},{"line":516},{"line":517},{"line":518},{"line":519},{"line":520},{"line":521},{"line":522},{"line":523},{"line":524},{"line":525},{"line":526},{"line":527},{"line":528},{"line":529},{"line":530},{"line":531},{"line":532},{"line":533},{"line":534},{"line":535},{"line":536},{"line":537},{"line":538},{"line":539},{"line":542},{"line":543},{"line":544},{"line":545},{"line":546},{"line":547},{"line":548},{"line":549},{"line":550},{"line":552},{"line":553},{"line":554},{"line":555},{"line":556},{"line":557},{"line":558},{"line":559},{"line":560},{"line":561},{"line":562},{"line":563},{"line":564},{"line":565},{"line":566},{"line":567},{"line":568},{"line":569},{"line":570},{"line":571},{"line":572},{"line":573},{"line":574},{"line":575},{"line":576},{"line":577},{"line":578},{"line":579},{"line":580},{"line":581},{"line":582},{"line":583},{"line":585},{"line":586},{"line":588},{"line":589},{"line":590},{"line":591},{"line":592},{"line":593},{"line":594},{"line":595},{"line":596},{"line":597},{"line":598},{"line":599},{"line":600},{"line":601},{"line":602},{"line":603},{"line":604},{"line":605},{"line":606},{"line":607},{"line":608},{"line":609},{"line":610},{"line":611},{"line":612},{"line":613},{"line":614},{"line":615},{"line":616},{"line":617},{"line":618},{"line":619},{"line":620},{"line":621},{"line":622},{"line":623},{"line":624},{"line":625},{"line":626},{"line":627},{"line":628},{"line":629},{"line":630},{"line":631},{"line":632},{"line":633},{"line":634},{"line":635},{"line":636},{"line":637},{"line":638},{"line":639},{"line":640},{"line":641},{"line":642},{"line":643},{"line":644},{"line":645},{"line":646},{"line":647},{"line":648},{"line":649},{"line":650},{"line":651},{"line":652},{"line":653},{"line":654},{"line":655},{"line":656},{"line":657},{"line":658},{"line":661},{"line":662},{"line":663},{"line":664},{"line":665},{"line":666},{"line":669},{"line":670},{"line":671},{"line":672},{"line":674},{"line":675},{"line":676},{"line":677},{"line":678},{"line":679},{"line":680},{"line":681},{"line":682},{"line":683},{"line":684},{"line":687},{"line":688},{"line":689},{"line":690},{"line":692},{"line":693},{"line":694},{"line":695},{"line":698},{"line":699},{"line":700},{"line":701},{"line":702}],"content":["import Foundation","import Accelerate","","\/\/ MARK: - K-Nearest Neighbor Search Implementation","","\/\/\/ Optimized KNN search with various distance metrics and algorithms","class KNNSearchEngine {","    enum DistanceMetric {","        case euclidean","        case cosine","        case manhattan","        case dot","        ","        func calculate(_ a: [Float], _ b: [Float]) -> Float {","            switch self {","            case .euclidean:","                return euclideanDistance(a, b)","            case .cosine:","                return cosineDistance(a, b)","            case .manhattan:","                return manhattanDistance(a, b)","            case .dot:","                return dotProduct(a, b)","            }","        }","    }","    ","    enum SearchAlgorithm {","        case bruteForce","        case approximateNearestNeighbor(numTrees: Int)","        case localitySensitiveHashing(numHashTables: Int)","        case hierarchicalNavigableSmallWorld","    }","    ","    private let dimension: Int","    private let metric: DistanceMetric","    private let algorithm: SearchAlgorithm","    private var index: SearchIndex?","    ","    init(","        dimension: Int,","        metric: DistanceMetric = .cosine,","        algorithm: SearchAlgorithm = .bruteForce","    ) {","        self.dimension = dimension","        self.metric = metric","        self.algorithm = algorithm","    }","    ","    \/\/ MARK: - Index Building","    ","    func buildIndex(from vectors: [(id: String, vector: [Float])]) async {","        switch algorithm {","        case .bruteForce:","            index = BruteForceIndex(vectors: vectors, metric: metric)","            ","        case .approximateNearestNeighbor(let numTrees):","            index = await ANNIndex(","                vectors: vectors,","                metric: metric,","                numTrees: numTrees,","                dimension: dimension","            )","            ","        case .localitySensitiveHashing(let numHashTables):","            index = LSHIndex(","                vectors: vectors,","                metric: metric,","                numHashTables: numHashTables,","                dimension: dimension","            )","            ","        case .hierarchicalNavigableSmallWorld:","            index = await HNSWIndex(","                vectors: vectors,","                metric: metric,","                dimension: dimension","            )","        }","    }","    ","    \/\/ MARK: - Search","    ","    func search(","        query: [Float],","        k: Int,","        threshold: Float? = nil","    ) async -> [SearchResult] {","        guard let index = index else {","            return []","        }","        ","        return await index.search(","            query: query,","            k: k,","            threshold: threshold","        )","    }","    ","    \/\/ MARK: - Batch Search","    ","    func batchSearch(","        queries: [[Float]],","        k: Int,","        threshold: Float? = nil","    ) async -> [[SearchResult]] {","        await withTaskGroup(of: [SearchResult].self) { group in","            for query in queries {","                group.addTask {","                    await self.search(query: query, k: k, threshold: threshold)","                }","            }","            ","            var results: [[SearchResult]] = []","            for await result in group {","                results.append(result)","            }","            return results","        }","    }","}","","\/\/ MARK: - Search Index Protocol","","protocol SearchIndex {","    func search(","        query: [Float],","        k: Int,","        threshold: Float?","    ) async -> [SearchResult]","}","","struct SearchResult {","    let id: String","    let distance: Float","    let vector: [Float]?","}","","\/\/ MARK: - Brute Force Index","","class BruteForceIndex: SearchIndex {","    private let vectors: [(id: String, vector: [Float])]","    private let metric: KNNSearchEngine.DistanceMetric","    ","    init(","        vectors: [(id: String, vector: [Float])],","        metric: KNNSearchEngine.DistanceMetric","    ) {","        self.vectors = vectors","        self.metric = metric","    }","    ","    func search(","        query: [Float],","        k: Int,","        threshold: Float?","    ) async -> [SearchResult] {","        \/\/ Calculate distances to all vectors","        let distances = vectors.map { (id, vector) in","            (id: id, distance: metric.calculate(query, vector), vector: vector)","        }","        ","        \/\/ Filter by threshold if provided","        let filtered = threshold.map { thresh in","            distances.filter { $0.distance <= thresh }","        } ?? distances","        ","        \/\/ Sort by distance and take top k","        let sorted = filtered.sorted { $0.distance < $1.distance }","        let topK = Array(sorted.prefix(k))","        ","        return topK.map { SearchResult(id: $0.id, distance: $0.distance, vector: $0.vector) }","    }","}","","\/\/ MARK: - Approximate Nearest Neighbor Index","","class ANNIndex: SearchIndex {","    private struct RandomProjectionTree {","        let hyperplane: [Float]","        let leftChild: TreeNode","        let rightChild: TreeNode","        ","        enum TreeNode {","            case leaf(vectors: [(id: String, vector: [Float])])","            case internal(tree: RandomProjectionTree)","        }","    }","    ","    private let trees: [RandomProjectionTree]","    private let metric: KNNSearchEngine.DistanceMetric","    ","    init(","        vectors: [(id: String, vector: [Float])],","        metric: KNNSearchEngine.DistanceMetric,","        numTrees: Int,","        dimension: Int","    ) async {","        self.metric = metric","        ","        \/\/ Build multiple random projection trees","        self.trees = await withTaskGroup(of: RandomProjectionTree.self) { group in","            for _ in 0..<numTrees {","                group.addTask {","                    self.buildTree(vectors: vectors, dimension: dimension)","                }","            }","            ","            var trees: [RandomProjectionTree] = []","            for await tree in group {","                trees.append(tree)","            }","            return trees","        }","    }","    ","    private func buildTree(","        vectors: [(id: String, vector: [Float])],","        dimension: Int,","        maxLeafSize: Int = 10","    ) -> RandomProjectionTree {","        \/\/ Base case: create leaf node","        if vectors.count <= maxLeafSize {","            return RandomProjectionTree(","                hyperplane: [],","                leftChild: .leaf(vectors: vectors),","                rightChild: .leaf(vectors: [])","            )","        }","        ","        \/\/ Generate random hyperplane","        let hyperplane = (0..<dimension).map { _ in Float.random(in: -1...1) }","        ","        \/\/ Normalize hyperplane","        let norm = sqrt(hyperplane.reduce(0) { $0 + $1 * $1 })","        let normalizedHyperplane = hyperplane.map { $0 \/ norm }","        ","        \/\/ Split vectors based on hyperplane","        var leftVectors: [(id: String, vector: [Float])] = []","        var rightVectors: [(id: String, vector: [Float])] = []","        ","        for (id, vector) in vectors {","            let dotProduct = zip(normalizedHyperplane, vector).reduce(0) { $0 + $1.0 * $1.1 }","            if dotProduct <= 0 {","                leftVectors.append((id, vector))","            } else {","                rightVectors.append((id, vector))","            }","        }","        ","        \/\/ Recursively build subtrees","        let leftChild: RandomProjectionTree.TreeNode","        let rightChild: RandomProjectionTree.TreeNode","        ","        if leftVectors.isEmpty {","            leftChild = .leaf(vectors: [])","        } else if leftVectors.count <= maxLeafSize {","            leftChild = .leaf(vectors: leftVectors)","        } else {","            leftChild = .internal(tree: buildTree(","                vectors: leftVectors,","                dimension: dimension,","                maxLeafSize: maxLeafSize","            ))","        }","        ","        if rightVectors.isEmpty {","            rightChild = .leaf(vectors: [])","        } else if rightVectors.count <= maxLeafSize {","            rightChild = .leaf(vectors: rightVectors)","        } else {","            rightChild = .internal(tree: buildTree(","                vectors: rightVectors,","                dimension: dimension,","                maxLeafSize: maxLeafSize","            ))","        }","        ","        return RandomProjectionTree(","            hyperplane: normalizedHyperplane,","            leftChild: leftChild,","            rightChild: rightChild","        )","    }","    ","    func search(","        query: [Float],","        k: Int,","        threshold: Float?","    ) async -> [SearchResult] {","        \/\/ Collect candidates from all trees","        var candidates: Set<String> = []","        var candidateVectors: [(id: String, vector: [Float])] = []","        ","        for tree in trees {","            let treeResults = searchTree(tree: tree, query: query, k: k * 2)","            for (id, vector) in treeResults {","                if !candidates.contains(id) {","                    candidates.insert(id)","                    candidateVectors.append((id, vector))","                }","            }","        }","        ","        \/\/ Calculate exact distances for candidates","        let distances = candidateVectors.map { (id, vector) in","            (id: id, distance: metric.calculate(query, vector), vector: vector)","        }","        ","        \/\/ Filter and sort","        let filtered = threshold.map { thresh in","            distances.filter { $0.distance <= thresh }","        } ?? distances","        ","        let sorted = filtered.sorted { $0.distance < $1.distance }","        let topK = Array(sorted.prefix(k))","        ","        return topK.map { SearchResult(id: $0.id, distance: $0.distance, vector: $0.vector) }","    }","    ","    private func searchTree(","        tree: RandomProjectionTree,","        query: [Float],","        k: Int","    ) -> [(id: String, vector: [Float])] {","        var results: [(id: String, vector: [Float])] = []","        var nodesToVisit: [RandomProjectionTree.TreeNode] = []","        ","        \/\/ Determine which side of hyperplane query falls on","        if !tree.hyperplane.isEmpty {","            let dotProduct = zip(tree.hyperplane, query).reduce(0) { $0 + $1.0 * $1.1 }","            ","            \/\/ Visit the side containing the query first","            if dotProduct <= 0 {","                nodesToVisit.append(tree.leftChild)","                nodesToVisit.append(tree.rightChild)","            } else {","                nodesToVisit.append(tree.rightChild)","                nodesToVisit.append(tree.leftChild)","            }","        } else {","            nodesToVisit.append(tree.leftChild)","        }","        ","        \/\/ Traverse tree","        while !nodesToVisit.isEmpty && results.count < k * 2 {","            let node = nodesToVisit.removeFirst()","            ","            switch node {","            case .leaf(let vectors):","                results.append(contentsOf: vectors)","                ","            case .internal(let subtree):","                let subtreeResults = searchTree(tree: subtree, query: query, k: k)","                results.append(contentsOf: subtreeResults)","            }","        }","        ","        return Array(results.prefix(k * 2))","    }","}","","\/\/ MARK: - Locality Sensitive Hashing Index","","class LSHIndex: SearchIndex {","    private struct HashTable {","        let hashFunctions: [[Float]]","        var buckets: [Int: [(id: String, vector: [Float])]] = [:]","    }","    ","    private var hashTables: [HashTable]","    private let metric: KNNSearchEngine.DistanceMetric","    private let dimension: Int","    ","    init(","        vectors: [(id: String, vector: [Float])],","        metric: KNNSearchEngine.DistanceMetric,","        numHashTables: Int,","        dimension: Int","    ) {","        self.metric = metric","        self.dimension = dimension","        ","        \/\/ Initialize hash tables","        self.hashTables = (0..<numHashTables).map { _ in","            let numHashFunctions = Int(log2(Double(dimension))) + 1","            let hashFunctions = (0..<numHashFunctions).map { _ in","                \/\/ Random projection vector","                (0..<dimension).map { _ in Float.random(in: -1...1) }","            }","            return HashTable(hashFunctions: hashFunctions)","        }","        ","        \/\/ Insert all vectors","        for (id, vector) in vectors {","            insert(id: id, vector: vector)","        }","    }","    ","    private func insert(id: String, vector: [Float]) {","        for i in 0..<hashTables.count {","            let hashValue = computeHash(","                vector: vector,","                hashFunctions: hashTables[i].hashFunctions","            )","            ","            if hashTables[i].buckets[hashValue] == nil {","                hashTables[i].buckets[hashValue] = []","            }","            hashTables[i].buckets[hashValue]?.append((id, vector))","        }","    }","    ","    private func computeHash(vector: [Float], hashFunctions: [[Float]]) -> Int {","        var hash = 0","        ","        for (i, hashFunction) in hashFunctions.enumerated() {","            let dotProduct = zip(vector, hashFunction).reduce(0) { $0 + $1.0 * $1.1 }","            if dotProduct > 0 {","                hash |= (1 << i)","            }","        }","        ","        return hash","    }","    ","    func search(","        query: [Float],","        k: Int,","        threshold: Float?","    ) async -> [SearchResult] {","        var candidates: Set<String> = []","        var candidateVectors: [(id: String, vector: [Float])] = []","        ","        \/\/ Query all hash tables","        for hashTable in hashTables {","            let hashValue = computeHash(","                vector: query,","                hashFunctions: hashTable.hashFunctions","            )","            ","            \/\/ Check bucket and neighboring buckets","            for offset in -1...1 {","                if let bucket = hashTable.buckets[hashValue + offset] {","                    for (id, vector) in bucket {","                        if !candidates.contains(id) {","                            candidates.insert(id)","                            candidateVectors.append((id, vector))","                        }","                    }","                }","            }","        }","        ","        \/\/ Calculate exact distances","        let distances = candidateVectors.map { (id, vector) in","            (id: id, distance: metric.calculate(query, vector), vector: vector)","        }","        ","        \/\/ Filter and sort","        let filtered = threshold.map { thresh in","            distances.filter { $0.distance <= thresh }","        } ?? distances","        ","        let sorted = filtered.sorted { $0.distance < $1.distance }","        let topK = Array(sorted.prefix(k))","        ","        return topK.map { SearchResult(id: $0.id, distance: $0.distance, vector: $0.vector) }","    }","}","","\/\/ MARK: - HNSW Index (Simplified)","","class HNSWIndex: SearchIndex {","    private struct Node {","        let id: String","        let vector: [Float]","        var neighbors: [Int: Set<Int>] = [:]  \/\/ level -> neighbor indices","    }","    ","    private var nodes: [Node] = []","    private let metric: KNNSearchEngine.DistanceMetric","    private let M = 16  \/\/ Max connections per layer","    private let efConstruction = 200  \/\/ Size of dynamic candidate list","    ","    init(","        vectors: [(id: String, vector: [Float])],","        metric: KNNSearchEngine.DistanceMetric,","        dimension: Int","    ) async {","        self.metric = metric","        ","        \/\/ Build HNSW graph","        for (id, vector) in vectors {","            await insert(id: id, vector: vector)","        }","    }","    ","    private func insert(id: String, vector: [Float]) async {","        let newNode = Node(id: id, vector: vector)","        let nodeIndex = nodes.count","        nodes.append(newNode)","        ","        if nodeIndex == 0 {","            return  \/\/ First node, nothing to connect","        }","        ","        \/\/ Determine layer for new node","        let level = Int(-log(Float.random(in: 0..<1)) * Double(M))","        ","        \/\/ Find nearest neighbors at each layer","        for layer in 0...level {","            let neighbors = await searchLayer(","                query: vector,","                entryPoint: 0,","                numClosest: M,","                layer: layer","            )","            ","            \/\/ Add bidirectional connections","            nodes[nodeIndex].neighbors[layer] = Set(neighbors.prefix(M).map { $0.0 })","            ","            for (neighborIndex, _) in neighbors.prefix(M) {","                if nodes[neighborIndex].neighbors[layer] == nil {","                    nodes[neighborIndex].neighbors[layer] = Set()","                }","                nodes[neighborIndex].neighbors[layer]?.insert(nodeIndex)","                ","                \/\/ Prune connections if necessary","                if let neighborConnections = nodes[neighborIndex].neighbors[layer],","                   neighborConnections.count > M {","                    await pruneConnections(","                        nodeIndex: neighborIndex,","                        layer: layer,","                        maxConnections: M","                    )","                }","            }","        }","    }","    ","    private func searchLayer(","        query: [Float],","        entryPoint: Int,","        numClosest: Int,","        layer: Int","    ) async -> [(Int, Float)] {","        var visited = Set<Int>()","        var candidates = [(index: entryPoint, distance: metric.calculate(query, nodes[entryPoint].vector))]","        var w = candidates","        ","        visited.insert(entryPoint)","        ","        while !candidates.isEmpty {","            let current = candidates.removeFirst()","            ","            if current.distance > w.last!.distance {","                break","            }","            ","            \/\/ Check neighbors","            if let neighbors = nodes[current.index].neighbors[layer] {","                for neighborIndex in neighbors {","                    if !visited.contains(neighborIndex) {","                        visited.insert(neighborIndex)","                        ","                        let distance = metric.calculate(query, nodes[neighborIndex].vector)","                        ","                        if distance < w.last!.distance || w.count < numClosest {","                            candidates.append((index: neighborIndex, distance: distance))","                            w.append((index: neighborIndex, distance: distance))","                            ","                            \/\/ Sort and keep top numClosest","                            w.sort { $0.distance < $1.distance }","                            if w.count > numClosest {","                                w.removeLast()","                            }","                        }","                    }","                }","            }","            ","            candidates.sort { $0.distance < $1.distance }","        }","        ","        return w.map { ($0.index, $0.distance) }","    }","    ","    private func pruneConnections(","        nodeIndex: Int,","        layer: Int,","        maxConnections: Int","    ) async {","        guard let connections = nodes[nodeIndex].neighbors[layer] else { return }","        ","        \/\/ Get distances to all connected nodes","        let distances = connections.map { neighborIndex in","            (index: neighborIndex, distance: metric.calculate(","                nodes[nodeIndex].vector,","                nodes[neighborIndex].vector","            ))","        }","        ","        \/\/ Keep only closest connections","        let sorted = distances.sorted { $0.distance < $1.distance }","        let keep = Set(sorted.prefix(maxConnections).map { $0.index })","        ","        nodes[nodeIndex].neighbors[layer] = keep","    }","    ","    func search(","        query: [Float],","        k: Int,","        threshold: Float?","    ) async -> [SearchResult] {","        guard !nodes.isEmpty else { return [] }","        ","        \/\/ Multi-layer search starting from top layer","        var entryPoint = 0","        let topLayer = nodes[0].neighbors.keys.max() ?? 0","        ","        \/\/ Search through layers","        for layer in stride(from: topLayer, to: 0, by: -1) {","            let layerResults = await searchLayer(","                query: query,","                entryPoint: entryPoint,","                numClosest: 1,","                layer: layer","            )","            ","            if let closest = layerResults.first {","                entryPoint = closest.0","            }","        }","        ","        \/\/ Final search at layer 0","        let results = await searchLayer(","            query: query,","            entryPoint: entryPoint,","            numClosest: k,","            layer: 0","        )","        ","        \/\/ Convert to SearchResult","        let searchResults = results.compactMap { (index, distance) -> SearchResult? in","            if let threshold = threshold, distance > threshold {","                return nil","            }","            ","            return SearchResult(","                id: nodes[index].id,","                distance: distance,","                vector: nodes[index].vector","            )","        }","        ","        return Array(searchResults.prefix(k))","    }","}","","\/\/ MARK: - Distance Functions","","private func euclideanDistance(_ a: [Float], _ b: [Float]) -> Float {","    var sum: Float = 0","    vDSP_distancesq(a, 1, b, 1, &sum, vDSP_Length(min(a.count, b.count)))","    return sqrt(sum)","}","","private func cosineDistance(_ a: [Float], _ b: [Float]) -> Float {","    var dotProduct: Float = 0","    var normA: Float = 0","    var normB: Float = 0","    ","    vDSP_dotpr(a, 1, b, 1, &dotProduct, vDSP_Length(min(a.count, b.count)))","    vDSP_svesq(a, 1, &normA, vDSP_Length(a.count))","    vDSP_svesq(b, 1, &normB, vDSP_Length(b.count))","    ","    normA = sqrt(normA)","    normB = sqrt(normB)","    ","    guard normA > 0 && normB > 0 else { return 1.0 }","    ","    let similarity = dotProduct \/ (normA * normB)","    return 1.0 - similarity","}","","private func manhattanDistance(_ a: [Float], _ b: [Float]) -> Float {","    var diff = [Float](repeating: 0, count: min(a.count, b.count))","    vDSP_vsub(b, 1, a, 1, &diff, 1, vDSP_Length(diff.count))","    vDSP_vabs(diff, 1, &diff, 1, vDSP_Length(diff.count))","    ","    var sum: Float = 0","    vDSP_sve(diff, 1, &sum, vDSP_Length(diff.count))","    ","    return sum","}","","private func dotProduct(_ a: [Float], _ b: [Float]) -> Float {","    var result: Float = 0","    vDSP_dotpr(a, 1, b, 1, &result, vDSP_Length(min(a.count, b.count)))","    return -result  \/\/ Negative because we want higher dot product = smaller distance","}"],"type":"file","syntax":"swift"},"doc://OpenAIKit/tutorials/OpenAIKit/02-Your-First-Chat-Completion#Customizing-Model-Parameters":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/02-Your-First-Chat-Completion#Customizing-Model-Parameters","role":"pseudoSymbol","title":"Customizing Model Parameters","abstract":[{"type":"text","text":"Make your first API call to generate text using OpenAI’s chat completion models."}],"url":"\/tutorials\/openaikit\/02-your-first-chat-completion#Customizing-Model-Parameters","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Vector-Similarity-Search":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Vector-Similarity-Search","role":"pseudoSymbol","title":"Vector Similarity Search","abstract":[{"type":"text","text":"Create intelligent search systems using embeddings to find semantically similar content."}],"url":"\/tutorials\/openaikit\/09-building-semantic-search#Vector-Similarity-Search","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/03-Working-With-Functions#Understanding-Function-Calling":{"title":"Understanding Function Calling","abstract":[{"type":"text","text":"Extend GPT’s capabilities by defining custom functions that the model can call to perform actions or retrieve information."}],"role":"pseudoSymbol","kind":"section","type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/03-Working-With-Functions#Understanding-Function-Calling","url":"\/tutorials\/openaikit\/03-working-with-functions#Understanding-Function-Calling"},"doc://OpenAIKit/tutorials/OpenAIKit/08-Transcribing-Audio#Basic-Audio-Transcription":{"type":"section","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/08-Transcribing-Audio#Basic-Audio-Transcription","role":"pseudoSymbol","title":"Basic Audio Transcription","abstract":[{"type":"text","text":"Use Whisper to transcribe audio files into text with high accuracy across multiple languages."}],"url":"\/tutorials\/openaikit\/08-transcribing-audio#Basic-Audio-Transcription","kind":"section"},"doc://OpenAIKit/tutorials/OpenAIKit/05-Building-Conversations#Check-Your-Understanding":{"url":"\/tutorials\/openaikit\/05-building-conversations#Check-Your-Understanding","title":"Check Your Understanding","titleInlineContent":[{"type":"text","text":"Check Your Understanding"}],"identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/05-Building-Conversations#Check-Your-Understanding","type":"link"},"engine-04-ranking.swift":{"syntax":"swift","highlights":[{"line":5},{"line":6},{"line":7},{"line":8},{"line":9},{"line":10},{"line":13},{"line":14},{"line":15},{"line":16},{"line":17},{"line":18},{"line":19},{"line":21},{"line":22},{"line":23},{"line":24},{"line":25},{"line":26},{"line":28},{"line":29},{"line":30},{"line":31},{"line":32},{"line":35},{"line":36},{"line":37},{"line":38},{"line":39},{"line":40},{"line":41},{"line":42},{"line":43},{"line":44},{"line":45},{"line":46},{"line":47},{"line":48},{"line":49},{"line":50},{"line":51},{"line":52},{"line":53},{"line":54},{"line":55},{"line":56},{"line":57},{"line":58},{"line":59},{"line":60},{"line":61},{"line":62},{"line":63},{"line":64},{"line":65},{"line":66},{"line":67},{"line":70},{"line":71},{"line":72},{"line":73},{"line":74},{"line":75},{"line":76},{"line":77},{"line":78},{"line":79},{"line":80},{"line":83},{"line":84},{"line":85},{"line":86},{"line":87},{"line":88},{"line":89},{"line":90},{"line":93},{"line":94},{"line":95},{"line":96},{"line":97},{"line":98},{"line":99},{"line":100},{"line":101},{"line":102},{"line":103},{"line":104},{"line":105},{"line":106},{"line":107},{"line":108},{"line":109},{"line":110},{"line":111},{"line":112},{"line":113},{"line":114},{"line":115},{"line":116},{"line":117},{"line":118},{"line":119},{"line":120},{"line":121},{"line":122},{"line":123},{"line":124},{"line":125},{"line":126},{"line":129},{"line":130},{"line":131},{"line":132},{"line":133},{"line":135},{"line":136},{"line":138},{"line":139},{"line":140},{"line":141},{"line":142},{"line":143},{"line":144},{"line":145},{"line":146},{"line":150},{"line":151},{"line":152},{"line":153},{"line":154},{"line":155},{"line":156},{"line":157},{"line":158},{"line":159},{"line":160},{"line":161},{"line":162},{"line":163},{"line":164},{"line":165},{"line":166},{"line":167},{"line":168},{"line":169},{"line":170},{"line":171},{"line":172},{"line":173},{"line":174},{"line":175},{"line":176},{"line":177},{"line":178},{"line":179},{"line":180},{"line":181},{"line":182},{"line":183},{"line":184},{"line":185},{"line":186},{"line":187},{"line":188},{"line":189},{"line":191},{"line":192},{"line":193},{"line":196},{"line":197},{"line":198},{"line":201},{"line":202},{"line":203},{"line":204},{"line":205},{"line":206},{"line":207},{"line":210},{"line":211},{"line":212},{"line":213},{"line":214},{"line":216},{"line":217},{"line":218},{"line":221},{"line":222},{"line":223},{"line":224},{"line":225},{"line":226},{"line":227},{"line":228},{"line":229},{"line":230},{"line":233},{"line":234},{"line":235},{"line":236},{"line":243},{"line":245},{"line":246},{"line":248},{"line":249},{"line":250},{"line":251},{"line":252},{"line":255},{"line":256},{"line":257},{"line":258},{"line":260},{"line":261},{"line":262},{"line":263},{"line":264}],"fileName":"SemanticSearchEngine.swift","fileType":"swift","type":"file","identifier":"engine-04-ranking.swift","content":["import Foundation","import OpenAIKit","","extension SemanticSearchEngine {","    \/\/\/ Advanced ranking system with multiple signals","    class RankingEngine {","        private let openAI: OpenAIKit","        ","        init(openAI: OpenAIKit) {","            self.openAI = openAI","        }","        ","        \/\/\/ Rank results using multiple signals","        func rankResults(","            _ results: [SearchResult],","            query: String,","            userContext: UserContext? = nil","        ) async throws -> [SearchResult] {","            var rankedResults = results","            ","            \/\/ Apply semantic reranking","            rankedResults = try await semanticRerank(rankedResults, query: query)","            ","            \/\/ Apply personalization if user context available","            if let context = userContext {","                rankedResults = personalizeResults(rankedResults, context: context)","            }","            ","            \/\/ Apply diversity to avoid redundant results","            rankedResults = diversifyResults(rankedResults)","            ","            return rankedResults","        }","        ","        \/\/\/ Semantic reranking using GPT","        private func semanticRerank(","            _ results: [SearchResult],","            query: String","        ) async throws -> [SearchResult] {","            guard !results.isEmpty else { return results }","            ","            \/\/ Create prompt for reranking","            let documentsDescription = results.enumerated()","                .map { index, result in","                    \"[\\(index)] \\(result.document.title): \\(String(result.document.content.prefix(200)))\"","                }","                .joined(separator: \"\\n\")","            ","            let prompt = \"\"\"","            Given this search query: \"\\(query)\"","            ","            Rank these documents by relevance (most relevant first):","            \\(documentsDescription)","            ","            Return only the indices in order, separated by commas.","            \"\"\"","            ","            let request = CreateChatCompletionRequest(","                model: .gpt3_5Turbo,","                messages: [.init(role: .user, content: .text(prompt))],","                temperature: 0.1,","                maxTokens: 50","            )","            ","            let response = try await openAI.chat.create(chatCompletion: request)","            guard let ranking = response.choices.first?.message.content?.string else {","                return results","            }","            ","            \/\/ Parse ranking","            let indices = ranking","                .split(separator: \",\")","                .compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }","            ","            \/\/ Reorder results","            var rerankedResults: [SearchResult] = []","            for index in indices {","                if index < results.count {","                    rerankedResults.append(results[index])","                }","            }","            ","            \/\/ Add any missing results at the end","            for result in results {","                if !rerankedResults.contains(where: { $0.document.id == result.document.id }) {","                    rerankedResults.append(result)","                }","            }","            ","            return rerankedResults","        }","        ","        \/\/\/ Personalize results based on user context","        private func personalizeResults(","            _ results: [SearchResult],","            context: UserContext","        ) -> [SearchResult] {","            return results.map { result in","                var personalizedScore = result.score","                ","                \/\/ Boost based on user interests","                for interest in context.interests {","                    if result.document.content.lowercased().contains(interest.lowercased()) ||","                       result.document.title.lowercased().contains(interest.lowercased()) {","                        personalizedScore *= 1.2","                    }","                }","                ","                \/\/ Boost based on recent interactions","                if context.recentlyViewed.contains(result.document.id) {","                    personalizedScore *= 0.8 \/\/ Slightly penalize recently viewed","                }","                ","                \/\/ Boost based on user level","                if let difficulty = result.document.metadata[\"difficulty\"] as? String {","                    if matchesUserLevel(difficulty, userLevel: context.level) {","                        personalizedScore *= 1.1","                    }","                }","                ","                return SearchResult(","                    document: result.document,","                    score: min(personalizedScore, 1.0),","                    highlights: result.highlights","                )","            }.sorted { $0.score > $1.score }","        }","        ","        \/\/\/ Ensure diversity in results","        private func diversifyResults(_ results: [SearchResult]) -> [SearchResult] {","            var diversifiedResults: [SearchResult] = []","            var seenCategories: Set<String> = []","            var categoryCount: [String: Int] = [:]","            ","            for result in results {","                let category = result.document.metadata[\"category\"] as? String ?? \"general\"","                ","                \/\/ Limit results per category","                let count = categoryCount[category, default: 0]","                if count < 3 { \/\/ Max 3 per category in top results","                    diversifiedResults.append(result)","                    categoryCount[category] = count + 1","                    seenCategories.insert(category)","                } else if diversifiedResults.count < 10 {","                    \/\/ After initial diversity, add remaining high-score results","                    diversifiedResults.append(result)","                }","            }","            ","            return diversifiedResults","        }","        ","        \/\/\/ Calculate relevance score with multiple factors","        func calculateRelevanceScore(","            document: SearchDocument,","            query: String,","            embedding: [Double],","            queryEmbedding: [Double]","        ) -> Double {","            \/\/ Base semantic similarity","            let semanticScore = cosineSimilarity(embedding, queryEmbedding)","            ","            \/\/ Text matching score","            let textScore = calculateTextMatchScore(document: document, query: query)","            ","            \/\/ Freshness score","            let freshnessScore = calculateFreshnessScore(timestamp: document.timestamp)","            ","            \/\/ Combine scores with weights","            let weights = (semantic: 0.6, text: 0.3, freshness: 0.1)","            let finalScore = (semanticScore * weights.semantic) +","                           (textScore * weights.text) +","                           (freshnessScore * weights.freshness)","            ","            return finalScore","        }","        ","        \/\/\/ Calculate text matching score","        private func calculateTextMatchScore(document: SearchDocument, query: String) -> Double {","            let queryTerms = query.lowercased().split(separator: \" \").map(String.init)","            let content = document.content.lowercased()","            let title = document.title.lowercased()","            ","            var matchCount = 0","            var titleMatchCount = 0","            ","            for term in queryTerms {","                if content.contains(term) {","                    matchCount += 1","                }","                if title.contains(term) {","                    titleMatchCount += 1","                }","            }","            ","            \/\/ Title matches are worth more","            let score = (Double(matchCount) + Double(titleMatchCount) * 2) \/ Double(queryTerms.count * 3)","            return min(score, 1.0)","        }","        ","        \/\/\/ Calculate freshness score","        private func calculateFreshnessScore(timestamp: Date) -> Double {","            let daysSinceCreation = Date().timeIntervalSince(timestamp) \/ (24 * 60 * 60)","            ","            \/\/ Decay function - documents lose relevance over time","            let decayRate = 0.01","            return exp(-decayRate * daysSinceCreation)","        }","        ","        private func matchesUserLevel(_ difficulty: String, userLevel: String) -> Bool {","            let levelOrder = [\"beginner\", \"intermediate\", \"advanced\"]","            guard let docLevel = levelOrder.firstIndex(of: difficulty),","                  let userLevelIndex = levelOrder.firstIndex(of: userLevel) else {","                return true","            }","            ","            \/\/ Match if document is at or below user level","            return docLevel <= userLevelIndex","        }","        ","        private func cosineSimilarity(_ a: [Double], _ b: [Double]) -> Double {","            guard a.count == b.count else { return 0 }","            ","            let dotProduct = zip(a, b).map(*).reduce(0, +)","            let magnitudeA = sqrt(a.map { $0 * $0 }.reduce(0, +))","            let magnitudeB = sqrt(b.map { $0 * $0 }.reduce(0, +))","            ","            guard magnitudeA > 0 && magnitudeB > 0 else { return 0 }","            return dotProduct \/ (magnitudeA * magnitudeB)","        }","    }","    ","    struct UserContext {","        let interests: [String]","        let level: String","        let recentlyViewed: Set<String>","    }","}","","\/\/ Example usage","Task {","    let engine = SemanticSearchEngine(apiKey: \"your-api-key\")","    let rankingEngine = SemanticSearchEngine.RankingEngine(openAI: engine.openAI)","    ","    \/\/ Search and get initial results","    let initialResults = try await engine.search(query: \"machine learning basics\")","    ","    \/\/ Apply advanced ranking with user context","    let userContext = SemanticSearchEngine.UserContext(","        interests: [\"neural networks\", \"Python\", \"data science\"],","        level: \"intermediate\",","        recentlyViewed: [\"doc123\", \"doc456\"]","    )","    ","    let rankedResults = try await rankingEngine.rankResults(","        initialResults,","        query: \"machine learning basics\",","        userContext: userContext","    )","    ","    \/\/ Display ranked results","    for (index, result) in rankedResults.enumerated() {","        print(\"\\(index + 1). \\(result.document.title) (Score: \\(result.score))\")","    }","}"]},"doc://OpenAIKit/tutorials/OpenAIKit/09-Building-Semantic-Search#Check-Your-Understanding":{"type":"link","identifier":"doc:\/\/OpenAIKit\/tutorials\/OpenAIKit\/09-Building-Semantic-Search#Check-Your-Understanding","url":"\/tutorials\/openaikit\/09-building-semantic-search#Check-Your-Understanding","title":"Check Your Understanding","titleInlineContent":[{"text":"Check Your Understanding","type":"text"}]}}}